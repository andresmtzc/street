<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Viewer — Advanced Path Editing</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Instrument+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: 'Instrument Sans', sans-serif; overflow: hidden; background: #000; }
    #main-container { display: flex; flex-direction: column; height: 100vh; }

    #viewer-section { height: 50%; background: #111; position: relative; display: flex; flex-direction: column; border-bottom: 2px solid #333; }
    #viewer-header { padding: 8px 15px; background: #222; color: white; display: flex; justify-content: space-between; align-items: center; font-size: 13px; z-index: 10; }
    #viewer-body { flex-grow: 1; position: relative; background: #0b1020; }

    #canvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      touch-action: none; pointer-events: auto;
      -webkit-user-select: none; user-select: none;
    }

    #map-section { height: 50%; position: relative; display: flex; }
    #left-panel {
      width: 280px; background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
      border-right: 1px solid #333; overflow-y: auto; z-index: 50;
      box-shadow: 4px 0 12px rgba(0,0,0,0.5);
    }
    #map { flex: 1; height: 100%; }

    .panel-section { border-bottom: 1px solid #2a2a2a; padding: 16px; }

    .section-title {
      font-size: 10px; font-weight: 700; letter-spacing: 1.2px;
      color: #666; text-transform: uppercase; margin-bottom: 12px;
      font-family: 'JetBrains Mono', monospace;
    }

    .checkbox-row {
      display: flex; align-items: center; gap: 10px;
      padding: 6px 0; cursor: pointer;
      border-radius: 4px; margin: 0 -6px; padding-left: 6px;
    }
    .checkbox-row:hover { background: rgba(255,255,255,0.03); }
    .checkbox-row input[type="checkbox"] { accent-color: #1fb6ff; cursor: pointer; }
    .checkbox-row label { color: #ccc; font-size: 13px; cursor: pointer; flex: 1; }

    .btn {
      width: 100%; padding: 10px 14px;
      background: linear-gradient(135deg, #1fb6ff 0%, #0d8fd9 100%);
      border: none; border-radius: 6px; color: white;
      font-weight: 600; font-size: 12px; cursor: pointer; margin: 8px 0;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:disabled { background: #2a2a2a; color: #666; cursor: not-allowed; transform: none; }
    .btn-danger { background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%); }

    /* MARKERS */
    .custom-marker {
      width: 16px; height: 16px; border-radius: 50%;
      border: 1.5px solid white; cursor: pointer; transition: 0.2s;
      display: flex; justify-content: center; align-items: center;
      font-family: 'JetBrains Mono', monospace; font-size: 9px; font-weight: 700;
      color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      z-index: 5;
    }

    /* Blue Dots (Original) */
    .blue-dot { background-color: #2b6df6; }
    .blue-dot.active {
      background-color: #00ffff !important;
      border-color: #000;
      transform: scale(1.5);
      z-index: 20;
      box-shadow: 0 0 12px #00ffff;
    }
    .blue-dot:hover { z-index: 15; transform: scale(1.2); }

    /* Red Dots (Projected) */
    .red-dot { background-color: #ff4444; border-color: #fff; z-index: 10; }
    .red-dot.active {
      background-color: #00ffff !important;
      border-color: #000;
      transform: scale(1.5);
      z-index: 20;
      box-shadow: 0 0 12px #00ffff;
    }
    .red-dot:hover { z-index: 15; transform: scale(1.2); }

    /* Delete Cursor */
    .delete-cursor { cursor: not-allowed !important; }
    .delete-cursor:hover { transform: scale(0.9); opacity: 0.8; }

    /* Control Point Markers */
    .control-point-marker {
      width: 14px; height: 14px; background: #ffeb3b;
      border: 2px solid #000; transform: rotate(45deg);
      cursor: move; box-shadow: 0 0 8px rgba(255,235,59,0.6);
      z-index: 30;
    }

    #ui-overlay {
      position: absolute; top: 10px; right: 10px;
      background: rgba(0,0,0,0.85); padding: 12px; border-radius: 8px;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
      color: white; z-index: 20; border: 1px solid rgba(255,255,255,0.1);
    }

    /* ===== THREE.JS VIEWER STYLES ===== */
    .image-controls {
      position: absolute; bottom: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; flex-direction: column; align-items: center;
      z-index: 20; pointer-events: none;
    }

    .navigation-ring {
      position: relative; width: 160px; height: 160px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      user-select: none;
      transition: transform 0.3s ease;
      pointer-events: none;
    }

    .nav-button.ring-button {
      position: absolute; width: 40px; height: 40px;
      border: none; border-radius: 50%;
      background: rgba(0,0,0,0);
      color: #fcfaf3;
      display: flex; align-items: center; justify-content: center;
      font-size: 20px; cursor: pointer;
      transform: translateX(-50%);
      pointer-events: auto;
      z-index: 21;
    }

    #nextImageBtn.ring-button { top: 15px; left: 50%; }
    #prevImageBtn.ring-button { bottom: 15px; left: 50%; }

    .nav-button.ring-button:hover {
      transform: translateX(-50%) scale(1.2);
    }

    .time {
      position: absolute; right: 20px; bottom: 20px;
      color: #22d3ee; font-weight: 600; font-size: 14px;
      z-index: 25;
      font-family: 'JetBrains Mono', monospace;
    }

    .zoom-controls {
      position: absolute; right: 10px; top: 10px;
      display: flex; flex-direction: column; gap: 8px;
      z-index: 5;
    }

    .zoom-btn {
      width: 36px; height: 36px;
      background: rgba(0,0,0,0.7); border: 1px solid #555;
      color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 18px; cursor: pointer;
    }
    .zoom-btn:hover { background: rgba(0,0,0,0.9); }

    #viewer-loading {
      display: none; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 100; background: rgba(0,0,0,0.7);
      padding: 20px; border-radius: 10px;
      text-align: center; color: white;
    }

    .spinner {
      width: 40px; height: 40px;
      border: 4px solid rgba(255,255,255,0.1);
      border-radius: 50%; border-top: 4px solid #22d3ee;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #empty-msg {
      height: 100%; display: flex; justify-content: center;
      align-items: center; color: #555;
      position: absolute; top: 0; left: 0; width: 100%;
      z-index: 5; pointer-events: none;
    }

    /* ===== TRACK LIST STYLES ===== */
    .track-list { max-height: 180px; overflow-y: auto; }
    .track-item {
      display: flex; align-items: center; gap: 8px;
      padding: 6px 8px; cursor: pointer; border-radius: 4px;
      margin-bottom: 2px; font-size: 12px; color: #ccc;
      border: 1px solid transparent;
    }
    .track-item:hover { background: rgba(255,255,255,0.05); }
    .track-item.active { background: rgba(31,182,255,0.15); border-color: rgba(31,182,255,0.3); }
    .track-color-dot {
      width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
    }
    .track-item-name {
      flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .track-item-count {
      font-size: 10px; color: #666; font-family: 'JetBrains Mono', monospace;
      white-space: nowrap;
    }
    .track-remove-btn {
      background: none; border: none; color: #666; cursor: pointer;
      font-size: 14px; padding: 0 4px; line-height: 1;
    }
    .track-remove-btn:hover { color: #ff4444; }

  </style>
</head>
<body>

<div id="main-container">
  <div id="viewer-section">
    <div id="viewer-header">
      <div><b id="viewer-title">Street View</b> <span id="viewer-meta" style="margin-left:10px; opacity:0.7;"></span></div>
    </div>
    <div id="viewer-body">
      <canvas id="canvas"></canvas>
      <div id="empty-msg">Load data to begin</div>

      <!-- Loading spinner -->
      <div id="viewer-loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading 360 image...</div>
      </div>

      <!-- Navigation ring -->
      <div class="image-controls">
        <div class="navigation-ring">
          <button class="nav-button ring-button" id="nextImageBtn">&#9651;</button>
          <button class="nav-button ring-button" id="prevImageBtn">&#9661;</button>
        </div>
      </div>

      <!-- Image counter -->
      <div class="time" id="time">-/-</div>

      <!-- Zoom controls -->
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomInBtn">+</button>
        <button class="zoom-btn" id="zoomOutBtn">&minus;</button>
      </div>
    </div>
  </div>

  <div id="map-section">
    <div id="left-panel">
      <div class="panel-section">
        <button class="btn btn-danger" id="clearAllBtn">Clear All</button>
      </div>

      <div class="panel-section">
        <div class="section-title">Tracks</div>
        <div class="track-list" id="tracks-list">
          <div style="text-align:center; color:#555; font-size:11px; padding:10px;">No tracks loaded</div>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">View Controls</div>
        <div class="checkbox-row">
          <input type="checkbox" id="showBlueDots" checked>
          <label for="showBlueDots">Show Blue Dots</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showRedDots" checked>
          <label for="showRedDots">Show Red Dots</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showBlueTrack" checked>
          <label for="showBlueTrack">Show Blue Track</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showRedTrack">
          <label for="showRedTrack">Show Red Track</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showControlPoints" checked>
          <label for="showControlPoints">Show Diamond CPs</label>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">Smoothing</div>
        <button class="btn" id="generateRedBtn">Generate Red Track</button>
        <div style="margin-top: 8px;">
          <div class="checkbox-row">
            <input type="checkbox" id="addCPMode">
            <label for="addCPMode">Add CP Mode</label>
          </div>
          <div class="checkbox-row">
            <input type="checkbox" id="removeCPMode">
            <label for="removeCPMode">Remove CP Mode</label>
          </div>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">Editing</div>
        <button class="btn" id="projectPointsBtn" disabled>Project Points to Red</button>

        <div style="margin: 12px 0;">
          <div class="checkbox-row">
            <input type="checkbox" id="autoReproject">
            <label for="autoReproject">Auto-reproject on curve edit</label>
          </div>

          <div class="checkbox-row">
            <input type="checkbox" id="dragMode">
            <label for="dragMode" style="color:#1fb6ff; font-weight:bold;">Drag Mode</label>
          </div>
          <div style="font-size: 10px; color: #666; padding-left: 28px; margin-bottom:5px;">
            Drag Red dots along curve
          </div>

          <div class="checkbox-row">
            <input type="checkbox" id="removePointMode">
            <label for="removePointMode" style="color:#ff4444; font-weight:bold;">Remove Point Mode</label>
          </div>
          <div style="font-size: 10px; color: #666; padding-left: 28px;">
            Click Red dot to delete & re-index
          </div>
        </div>

        <button class="btn btn-danger" id="exportBtn" disabled>Export JSON</button>
        <button class="btn" id="exportGpxBtn" disabled style="background: linear-gradient(135deg, #26a269 0%, #1a7f4f 100%);">Export GPX</button>
      </div>

      <div class="panel-section">
        <div class="section-title">Status</div>
        <div style="font-size: 11px; color: #999;">
          <div>Blue Points: <span id="blueCount" style="color: #2b6df6; font-weight: 600;">0</span></div>
          <div>Red Points: <span id="projectedCount" style="color: #ff4444; font-weight: 600;">0</span></div>
        </div>
      </div>
    </div>

    <div id="map"></div>

    <div id="ui-overlay">
      <div style="display:flex; flex-direction:column; gap:4px; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 6px;">
        <label style="font-size:10px; font-weight:bold; color:#26a269;">CREATE BLUE POINTS</label>
        <input id="gpxInput" type="file" accept=".gpx" multiple style="font-size:11px; max-width: 180px;"/>
        <div style="display:flex; gap:6px; align-items:center;">
          <input id="numPointsInput" type="number" min="2" value="10" style="width:50px; font-size:11px; padding:2px 4px; background:#222; border:1px solid #444; color:white; border-radius:3px;"/>
          <span style="font-size:10px; color:#999;">points</span>
        </div>
        <button id="generateFromGpxBtn" disabled style="background:#26a269; color:white; border:none; padding:4px 8px; font-size:10px; border-radius:4px; cursor:pointer;">Regenerate Points</button>
        <button id="exportCreatedJsonBtn" disabled style="background:#333; color:white; border:none; padding:4px 8px; font-size:10px; border-radius:4px; cursor:pointer;">Export JSON</button>
      </div>
      <div style="display:flex; flex-direction:column; gap:4px;">
        <label style="font-size:10px; font-weight:bold; color:#1fb6ff;">LOAD BLUE POINTS</label>
        <input id="jsonInput" type="file" accept=".json" style="font-size:11px; max-width: 180px;"/>
      </div>
      <div style="display:flex; flex-direction:column; gap:4px;">
        <label style="font-size:10px; font-weight:bold; color:#ff4444;">IMPORT RED PATH</label>
        <input id="importRedInput" type="file" accept=".json" style="font-size:11px; max-width: 180px;"/>
      </div>
      <div style="display:flex; flex-direction:column; gap:4px;">
        <label style="font-size:10px; font-weight:bold; color:#1fb6ff;">LOCAL IMAGES</label>
        <input id="imagesInput" type="file" webkitdirectory directory multiple style="font-size:11px; max-width: 180px;"/>
      </div>
      <button id="fitBtn" style="background:#333; color:white; border:none; padding:4px 8px; font-size:10px; border-radius:4px; cursor:pointer;">Recenter</button>
    </div>
  </div>
</div>

<script>
mapboxgl.accessToken = "pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWl5eWQ0a2gwbDRlM2RweTN6ZXY1MmRsIn0.RDhU90VJPV_Bcjt1tab-MQ";

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-streets-v12',
  center: [-100.3483, 25.6752],
  zoom: 15
});

/* ========================
   TRACK COLORS
======================== */
const trackColors = [
  '#2b6df6', '#EA4335', '#34A853', '#FBBC05', '#FF6D01',
  '#46BDC6', '#9334E6', '#E67C73', '#109D58', '#3F51B5'
];

/* ========================
   MULTI-TRACK STATE
======================== */
let tracks = new Map();
let currentTrackId = null;
let nextTrackId = 1;

/* ========================
   VIEWER STATE
======================== */
let currentIdx = -1;

// Three.js Viewer State
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;
let preloadedImages = {};

// Mode State
let addCPModeActive = false;
let removeCPModeActive = false;
let dragModeActive = false;
let removePointModeActive = false;

/* ========================
   CATMULL-ROM SPLINE
======================== */
function catmullRom(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  return [
    0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 + (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3),
    0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 + (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3)
  ];
}

function generateCatmullRomCurve(controlPts, segmentsPerSection = 20) {
  if (controlPts.length < 2) return controlPts;
  const curve = [];
  const n = controlPts.length;
  for (let i = 0; i < n - 1; i++) {
    const p0 = i === 0 ? controlPts[i] : controlPts[i - 1];
    const p1 = controlPts[i];
    const p2 = controlPts[i + 1];
    const p3 = i === n - 2 ? controlPts[i + 1] : controlPts[i + 2];
    for (let j = 0; j < segmentsPerSection; j++) {
      curve.push(catmullRom(p0, p1, p2, p3, j / segmentsPerSection));
    }
  }
  curve.push(controlPts[n - 1]);
  return curve;
}

/* ========================
   TRACK MANAGEMENT
======================== */
function createTrackData(name) {
  const id = `track-${nextTrackId++}`;
  return {
    id: id,
    name: name,
    color: trackColors[(nextTrackId - 2) % trackColors.length],
    gpxLine: null,
    rawPoints: [],
    blueMarkers: [],
    imagesByIndex: {},
    redMarkers: [],
    controlPointMarkers: [],
    controlPoints: [],
    redTrackLine: null,
  };
}

function getCurrentTrack() {
  return currentTrackId ? tracks.get(currentTrackId) : null;
}

function findTrackByName(name) {
  const nameLower = name.toLowerCase();
  for (const [id, track] of tracks) {
    if (track.name.toLowerCase() === nameLower) return track;
  }
  return null;
}

function selectTrack(trackId) {
  if (currentTrackId === trackId) return;

  const prevTrack = getCurrentTrack();

  // Hide previous track's red markers and control points
  if (prevTrack) {
    prevTrack.redMarkers.forEach(m => m.marker.getElement().style.display = 'none');
    prevTrack.controlPointMarkers.forEach(m => m.getElement().style.display = 'none');
    if (map.getLayer(`red-track-${prevTrack.id}`)) {
      map.setLayoutProperty(`red-track-${prevTrack.id}`, 'visibility', 'none');
    }
  }

  currentTrackId = trackId;
  const track = getCurrentTrack();
  if (!track) return;

  // Show current track's red markers and control points
  const showRed = document.getElementById('showRedDots').checked;
  const showCP = document.getElementById('showControlPoints').checked;
  track.redMarkers.forEach(m => m.marker.getElement().style.display = showRed ? 'flex' : 'none');
  track.controlPointMarkers.forEach(m => m.getElement().style.display = showCP ? 'block' : 'none');

  if (map.getLayer(`red-track-${track.id}`)) {
    const showRedTrack = document.getElementById('showRedTrack').checked;
    map.setLayoutProperty(`red-track-${track.id}`, 'visibility', showRedTrack ? 'visible' : 'none');
  }

  // Update button states
  document.getElementById('projectPointsBtn').disabled = !track.redTrackLine;
  document.getElementById('exportBtn').disabled = track.redMarkers.length === 0;
  document.getElementById('exportGpxBtn').disabled = track.redMarkers.length === 0;
  document.getElementById('generateFromGpxBtn').disabled = !track.gpxLine;
  document.getElementById('exportCreatedJsonBtn').disabled = track.rawPoints.length === 0;

  // Reset modes
  dragModeActive = false;
  removePointModeActive = false;
  document.getElementById('dragMode').checked = false;
  document.getElementById('removePointMode').checked = false;

  updateTracksList();
  updateStatus();

  // Open first point of this track in viewer
  if (track.rawPoints.length > 0) {
    openViewer(track.rawPoints[0].index);
  }
}

function removeTrack(trackId) {
  const track = tracks.get(trackId);
  if (!track) return;

  // Remove map layers
  if (map.getLayer(`blue-track-${trackId}`)) map.removeLayer(`blue-track-${trackId}`);
  if (map.getSource(`blue-track-${trackId}`)) map.removeSource(`blue-track-${trackId}`);
  if (map.getLayer(`red-track-${trackId}`)) map.removeLayer(`red-track-${trackId}`);
  if (map.getSource(`red-track-${trackId}`)) map.removeSource(`red-track-${trackId}`);

  // Remove markers
  track.blueMarkers.forEach(m => m.remove());
  track.redMarkers.forEach(m => m.marker.remove());
  track.controlPointMarkers.forEach(m => m.remove());

  // Revoke blob URLs
  Object.values(track.imagesByIndex).forEach(url => {
    if (url && url.startsWith('blob:')) URL.revokeObjectURL(url);
  });

  tracks.delete(trackId);

  if (currentTrackId === trackId) {
    currentTrackId = null;
    if (tracks.size > 0) {
      selectTrack(tracks.keys().next().value);
    } else {
      updateTracksList();
      updateStatus();
      document.getElementById('empty-msg').style.display = 'flex';
      document.getElementById('empty-msg').textContent = 'Load data to begin';
      document.getElementById('viewer-title').textContent = 'Street View';
      document.getElementById('viewer-meta').textContent = '';
      document.getElementById('time').textContent = '-/-';
      currentIdx = -1;
    }
  } else {
    updateTracksList();
    updateStatus();
  }
}

function updateTracksList() {
  const list = document.getElementById('tracks-list');

  if (tracks.size === 0) {
    list.innerHTML = '<div style="text-align:center; color:#555; font-size:11px; padding:10px;">No tracks loaded</div>';
    return;
  }

  list.innerHTML = '';
  tracks.forEach((track, trackId) => {
    const item = document.createElement('div');
    item.className = `track-item ${trackId === currentTrackId ? 'active' : ''}`;

    const imgCount = Object.keys(track.imagesByIndex).length;

    item.innerHTML = `
      <div class="track-color-dot" style="background:${track.color}"></div>
      <div class="track-item-name" title="${track.name}">${track.name}</div>
      <div class="track-item-count">${track.rawPoints.length}pt${imgCount ? ' · ' + imgCount + 'img' : ''}</div>
      <button class="track-remove-btn" data-track-id="${trackId}" title="Remove">&times;</button>
    `;

    item.addEventListener('click', (e) => {
      if (e.target.classList.contains('track-remove-btn')) {
        removeTrack(e.target.dataset.trackId);
        return;
      }
      selectTrack(trackId);
    });

    list.appendChild(item);
  });
}

/* ========================
   GPX PARSING & POINT GENERATION
======================== */
function parseGpxFile(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, 'application/xml');
  const trkpts = xml.querySelectorAll('trkpt');

  if (trkpts.length === 0) {
    alert('No track points found in GPX file');
    return null;
  }

  const coordinates = [];
  trkpts.forEach(pt => {
    const lat = parseFloat(pt.getAttribute('lat'));
    const lon = parseFloat(pt.getAttribute('lon'));
    if (!isNaN(lat) && !isNaN(lon)) {
      coordinates.push([lon, lat]);
    }
  });

  if (coordinates.length < 2) {
    alert('GPX file must have at least 2 valid track points');
    return null;
  }

  return turf.lineString(coordinates);
}

function generatePointsFromGpx(trackLine, numPoints) {
  if (!trackLine || numPoints < 2) return [];

  const totalLength = turf.length(trackLine);
  const points = [];

  for (let i = 0; i < numPoints; i++) {
    const distance = (i / (numPoints - 1)) * totalLength;
    const pointOnLine = turf.along(trackLine, distance);
    const coord = pointOnLine.geometry.coordinates;

    points.push({
      index: i + 1,
      lat: coord[1],
      lon: coord[0]
    });
  }

  return points;
}

/* ========================
   PROCESS RAW POINTS (per-track)
======================== */
function processRawPoints(track) {
  track.rawPoints.sort((a, b) => a.index - b.index);

  // Clear existing blue markers for this track
  track.blueMarkers.forEach(m => m.remove());
  track.blueMarkers = [];

  // Remove old blue track layer
  if (map.getLayer(`blue-track-${track.id}`)) map.removeLayer(`blue-track-${track.id}`);
  if (map.getSource(`blue-track-${track.id}`)) map.removeSource(`blue-track-${track.id}`);

  // Draw Blue Track line with track color
  map.addSource(`blue-track-${track.id}`, {
    type: 'geojson',
    data: { type: 'Feature', geometry: { type: 'LineString', coordinates: track.rawPoints.map(p => [p.lon, p.lat]) } }
  });
  map.addLayer({
    id: `blue-track-${track.id}`, type: 'line', source: `blue-track-${track.id}`,
    paint: { 'line-color': track.color, 'line-width': 3, 'line-opacity': 0.6 }
  });

  // Create Blue Dots
  track.rawPoints.forEach((p) => {
    const el = document.createElement('div');
    el.className = 'custom-marker blue-dot';
    el.innerText = p.index;
    el.style.backgroundColor = track.color;
    el.onclick = () => {
      if (currentTrackId !== track.id) selectTrack(track.id);
      openViewer(p.index);
    };

    const marker = new mapboxgl.Marker({ element: el })
      .setLngLat([p.lon, p.lat])
      .addTo(map);

    track.blueMarkers.push(marker);
  });

  updateDotsVisibility();
  updateMarkerColors(track);
  updateStatus();
}

/* ========================
   RED TRACK GENERATION (per-track)
======================== */
function generateRedTrack() {
  const track = getCurrentTrack();
  if (!track || track.rawPoints.length === 0) return;

  const cpCount = Math.max(4, Math.round(track.rawPoints.length / 5));
  const step = Math.floor(track.rawPoints.length / (cpCount - 1));

  track.controlPointMarkers.forEach(m => m.remove());
  track.controlPointMarkers = [];
  track.controlPoints = [];

  for (let i = 0; i < track.rawPoints.length; i += step) {
    track.controlPoints.push([track.rawPoints[i].lon, track.rawPoints[i].lat]);
    if (track.controlPoints.length >= cpCount - 1) break;
  }
  const lastP = track.rawPoints[track.rawPoints.length - 1];
  track.controlPoints.push([lastP.lon, lastP.lat]);

  track.controlPoints.forEach(cp => createCPMarker(cp, track));

  updateRedTrackLine(track);
  document.getElementById('showRedTrack').checked = true;
  document.getElementById('projectPointsBtn').disabled = false;
  updateStatus();
}

function createCPMarker(lngLat, track) {
  if (!track) track = getCurrentTrack();
  if (!track) return;

  const el = document.createElement('div');
  el.className = 'control-point-marker';

  const marker = new mapboxgl.Marker({ element: el, draggable: true })
    .setLngLat(lngLat)
    .addTo(map);

  el.onclick = (e) => {
    if (removeCPModeActive && track.controlPointMarkers.length > 3) {
      e.stopPropagation();
      marker.remove();
      track.controlPointMarkers = track.controlPointMarkers.filter(m => m !== marker);
      updateRedTrackLine(track);
    }
  };

  marker.on('drag', () => updateRedTrackLine(track));
  marker.on('dragend', () => {
    updateRedTrackLine(track);
    if (document.getElementById('autoReproject').checked && track.rawPoints.length > 0 && track.redMarkers.length > 0) {
      projectPointsToRed(track);
    }
  });
  track.controlPointMarkers.push(marker);
  updateControlsVisibility();
}

function updateRedTrackLine(track) {
  if (!track) track = getCurrentTrack();
  if (!track) return;

  track.controlPoints = track.controlPointMarkers.map(m => { const ll = m.getLngLat(); return [ll.lng, ll.lat]; });

  const smoothCurve = generateCatmullRomCurve(track.controlPoints, 30);
  track.redTrackLine = turf.lineString(smoothCurve);

  const layerId = `red-track-${track.id}`;
  const sourceId = `red-track-${track.id}`;

  if (map.getLayer(layerId)) map.removeLayer(layerId);
  if (map.getSource(sourceId)) map.removeSource(sourceId);

  map.addSource(sourceId, {
    type: 'geojson',
    data: { type: 'Feature', geometry: { type: 'LineString', coordinates: smoothCurve } }
  });

  map.addLayer({
    id: layerId, type: 'line', source: sourceId,
    paint: { 'line-color': '#ff4444', 'line-width': 3, 'line-opacity': 0.8 },
    layout: { 'visibility': document.getElementById('showRedTrack').checked ? 'visible' : 'none' }
  });
}

/* ========================
   PROJECT TO RED DOTS (per-track)
======================== */
function projectPointsToRed(track) {
  if (!track) track = getCurrentTrack();
  if (!track || !track.redTrackLine) return;

  track.redMarkers.forEach(item => item.marker.remove());
  track.redMarkers = [];

  const blueTrack = turf.lineString(track.rawPoints.map(p => [p.lon, p.lat]));
  const blueLen = turf.length(blueTrack);
  const redLen = turf.length(track.redTrackLine);

  let cumulativeDist = 0;

  track.rawPoints.forEach((p, idx) => {
    if (idx > 0) {
      const prev = track.rawPoints[idx - 1];
      cumulativeDist += turf.distance([prev.lon, prev.lat], [p.lon, p.lat]);
    }

    const ratio = blueLen > 0 ? cumulativeDist / blueLen : 0;
    const pointOnRed = turf.along(track.redTrackLine, ratio * redLen);
    const coord = pointOnRed.geometry.coordinates;

    createRedMarker(coord, idx, p.index, track);
  });

  document.getElementById('showRedDots').checked = true;
  document.getElementById('dragMode').disabled = false;
  document.getElementById('exportBtn').disabled = false;
  document.getElementById('exportGpxBtn').disabled = false;
  updateStatus();
}

function createRedMarker(coord, sequentialIndex, imageIndex, track) {
  if (!track) track = getCurrentTrack();
  if (!track) return;

  const el = document.createElement('div');
  el.className = 'custom-marker red-dot';
  el.innerText = imageIndex;
  el.title = `Sequence ${sequentialIndex}`;

  const marker = new mapboxgl.Marker({ element: el, draggable: false })
    .setLngLat(coord)
    .addTo(map);

  const markerObj = {
    marker: marker,
    data: {
      lon: coord[0],
      lat: coord[1],
      sequentialIndex: sequentialIndex,
      imageIndex: imageIndex,
      associatedImage: track.imagesByIndex[imageIndex]
    }
  };

  el.onclick = (e) => {
    if (removePointModeActive) {
      deleteRedPoint(markerObj, track);
      return;
    }
    if (!dragModeActive && !removePointModeActive) {
      if (currentTrackId !== track.id) selectTrack(track.id);
      openViewer(imageIndex);
    }
  };

  marker.on('dragstart', () => {
    if (!dragModeActive) marker.setDraggable(false);
  });

  marker.on('drag', () => {
    const ll = marker.getLngLat();
    const point = turf.point([ll.lng, ll.lat]);
    const snapped = turf.nearestPointOnLine(track.redTrackLine, point);
    marker.setLngLat(snapped.geometry.coordinates);
    markerObj.data.lon = snapped.geometry.coordinates[0];
    markerObj.data.lat = snapped.geometry.coordinates[1];
  });

  track.redMarkers.push(markerObj);
  updateDotsVisibility();
}

/* ========================
   DELETE & RE-INDEX RED DOTS
======================== */
function deleteRedPoint(targetObj, track) {
  if (!track) track = getCurrentTrack();
  if (!track) return;

  targetObj.marker.remove();
  const indexToRemove = track.redMarkers.indexOf(targetObj);
  if (indexToRemove > -1) {
    track.redMarkers.splice(indexToRemove, 1);
  }

  track.redMarkers.forEach((item, newSeqIndex) => {
    item.data.sequentialIndex = newSeqIndex;
  });

  updateStatus();
}

/* ========================
   UI & TOGGLES
======================== */
function updateDotsVisibility() {
  const showBlue = document.getElementById('showBlueDots').checked;
  const showRed = document.getElementById('showRedDots').checked;

  // Blue dots for ALL tracks
  tracks.forEach(track => {
    track.blueMarkers.forEach(m => m.getElement().style.display = showBlue ? 'flex' : 'none');
  });

  // Red dots only for current track
  const ct = getCurrentTrack();
  if (ct) {
    ct.redMarkers.forEach(m => m.marker.getElement().style.display = showRed ? 'flex' : 'none');
  }
}

function updateControlsVisibility() {
  const show = document.getElementById('showControlPoints').checked;
  const ct = getCurrentTrack();
  if (ct) {
    ct.controlPointMarkers.forEach(m => m.getElement().style.display = show ? 'block' : 'none');
  }
}

function updateStatus() {
  const ct = getCurrentTrack();
  if (!ct) {
    document.getElementById('blueCount').innerText = '0';
    document.getElementById('projectedCount').innerText = '0';
    document.getElementById('viewer-meta').textContent = '';
    return;
  }

  const imgCount = ct.rawPoints.filter(p => ct.imagesByIndex[p.index]).length;
  document.getElementById('blueCount').innerText = `${ct.blueMarkers.length} (${imgCount} imgs)`;
  document.getElementById('projectedCount').innerText = ct.redMarkers.length;

  if (ct.redMarkers.length > 0) {
    const firstImage = ct.redMarkers[0].data.imageIndex;
    const lastImage = ct.redMarkers[ct.redMarkers.length - 1].data.imageIndex;
    document.getElementById('viewer-meta').textContent =
      `${ct.name} · ${firstImage} → ${lastImage} (${ct.redMarkers.length} pts)`;
  } else {
    document.getElementById('viewer-meta').textContent = ct.name;
  }
}

function updateMarkerColors(track) {
  track.blueMarkers.forEach((marker, idx) => {
    const p = track.rawPoints[idx];
    if (!p) return;
    const el = marker.getElement();
    el.style.backgroundColor = track.imagesByIndex[p.index] ? '#26a269' : track.color;
  });
}

document.getElementById('showBlueDots').onchange = updateDotsVisibility;
document.getElementById('showRedDots').onchange = updateDotsVisibility;

document.getElementById('showBlueTrack').onchange = (e) => {
  tracks.forEach(track => {
    if (map.getLayer(`blue-track-${track.id}`)) {
      map.setLayoutProperty(`blue-track-${track.id}`, 'visibility', e.target.checked ? 'visible' : 'none');
    }
  });
};
document.getElementById('showRedTrack').onchange = (e) => {
  const ct = getCurrentTrack();
  if (ct && map.getLayer(`red-track-${ct.id}`)) {
    map.setLayoutProperty(`red-track-${ct.id}`, 'visibility', e.target.checked ? 'visible' : 'none');
  }
};
document.getElementById('showControlPoints').onchange = updateControlsVisibility;

// MODES
document.getElementById('addCPMode').onchange = (e) => {
  addCPModeActive = e.target.checked;
  removeCPModeActive = false; document.getElementById('removeCPMode').checked = false;
  map.getCanvas().style.cursor = addCPModeActive ? 'crosshair' : '';
};

document.getElementById('removeCPMode').onchange = (e) => {
  removeCPModeActive = e.target.checked;
  addCPModeActive = false; document.getElementById('addCPMode').checked = false;
  map.getCanvas().style.cursor = '';
};

document.getElementById('dragMode').onchange = (e) => {
  dragModeActive = e.target.checked;
  removePointModeActive = false; document.getElementById('removePointMode').checked = false;

  const ct = getCurrentTrack();
  if (ct) {
    ct.redMarkers.forEach(m => {
      m.marker.setDraggable(dragModeActive);
      m.marker.getElement().style.cursor = dragModeActive ? 'move' : 'pointer';
    });
  }
};

document.getElementById('removePointMode').onchange = (e) => {
  removePointModeActive = e.target.checked;
  dragModeActive = false; document.getElementById('dragMode').checked = false;

  const ct = getCurrentTrack();
  if (ct) {
    ct.redMarkers.forEach(m => {
      m.marker.setDraggable(false);
      const el = m.marker.getElement();
      if (removePointModeActive) {
        el.classList.add('delete-cursor');
      } else {
        el.classList.remove('delete-cursor');
        el.style.cursor = 'pointer';
      }
    });
  }
};

/* ========================
   MAP EVENTS
======================== */
map.on('click', (e) => {
  if (addCPModeActive) {
    const ct = getCurrentTrack();
    if (ct && ct.redTrackLine) {
      const point = turf.point([e.lngLat.lng, e.lngLat.lat]);
      const snapped = turf.nearestPointOnLine(ct.redTrackLine, point);
      createCPMarker(snapped.geometry.coordinates, ct);
      updateRedTrackLine(ct);
    }
  }
});

/* ========================
   BEARING & GEOMETRY HELPERS
======================== */
function bearingDeg(a, b) {
  const toRad = d => d * Math.PI / 180;
  const toDeg = r => r * 180 / Math.PI;
  const lat1 = toRad(a[1]), lat2 = toRad(b[1]);
  const lon1 = toRad(a[0]), lon2 = toRad(b[0]);
  const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return (toDeg(Math.atan2(y, x)) + 360) % 360;
}

function degToRad(d) { return d * Math.PI / 180; }
function radToDeg(r) { return r * 180 / Math.PI; }

function destFromBearingDistance(lat, lon, brngDeg, distMeters) {
  const R = 6378137;
  const brng = degToRad(brngDeg);
  const lat1 = degToRad(lat), lon1 = degToRad(lon);
  const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distMeters / R) +
    Math.cos(lat1) * Math.sin(distMeters / R) * Math.cos(brng));
  const lon2 = lon1 + Math.atan2(
    Math.sin(brng) * Math.sin(distMeters / R) * Math.cos(lat1),
    Math.cos(distMeters / R) - Math.sin(lat1) * Math.sin(lat2)
  );
  return [radToDeg(lon2), radToDeg(lat2)];
}

/* ========================
   NAVIGATION HELPERS
======================== */
function getActivePoints() {
  const track = getCurrentTrack();
  if (!track) return [];

  if (track.redMarkers.length > 0) {
    return track.redMarkers.map(m => ({
      index: m.data.imageIndex,
      lon: m.data.lon,
      lat: m.data.lat
    }));
  }
  return track.rawPoints;
}

function getCurrentPointPosition() {
  const pts = getActivePoints();
  const pt = pts.find(p => p.index === currentIdx);
  return pt ? [pt.lon, pt.lat] : null;
}

function getNextPointPosition() {
  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);
  if (curPos >= 0 && curPos < pts.length - 1) {
    const next = pts[curPos + 1];
    return [next.lon, next.lat];
  }
  return null;
}

function getPrevPointPosition() {
  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);
  if (curPos > 0) {
    const prev = pts[curPos - 1];
    return [prev.lon, prev.lat];
  }
  return null;
}

function navigateForward() {
  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);
  if (curPos >= 0 && curPos < pts.length - 1) {
    openViewer(pts[curPos + 1].index);
  }
}

function navigateBackward() {
  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);
  if (curPos > 0) {
    openViewer(pts[curPos - 1].index);
  }
}

/* ========================
   THREE.JS VIEWER
======================== */
function initThreeJSViewer() {
  if (viewerInitialized) return;

  scene = new THREE.Scene();
  panoGroup = new THREE.Group();
  scene.add(panoGroup);

  const canvas = document.getElementById('canvas');
  camera = new THREE.PerspectiveCamera(currentFov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 0.1);

  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: false,
    powerPreference: 'high-performance'
  });

  const dpr = Math.min(window.devicePixelRatio || 2, 3);
  renderer.setPixelRatio(dpr);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

  setupViewerEventListeners();
  animateViewer();
  viewerInitialized = true;
}

function animateViewer() {
  requestAnimationFrame(animateViewer);
  updateNavigationRing();
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

function resizeViewer() {
  if (!renderer || !camera) return;
  const canvas = document.getElementById('canvas');
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  if (w === 0 || h === 0) return;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h, false);
}

window.addEventListener('resize', resizeViewer);

/* ========================
   NAVIGATION RING
======================== */
function updateNavigationRing() {
  const ring = document.querySelector('.navigation-ring');
  const nextBtn = document.getElementById('nextImageBtn');
  const prevBtn = document.getElementById('prevImageBtn');
  if (!ring || !sphere) return;

  const yawDegrees = THREE.MathUtils.radToDeg(currentYaw);
  ring.style.transform = `rotateZ(${-yawDegrees}deg)`;

  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);

  const canForward = curPos >= 0 && curPos < pts.length - 1;
  const canBackward = curPos > 0;

  if (nextBtn) {
    nextBtn.style.opacity = canForward ? 1 : 0;
    nextBtn.style.pointerEvents = canForward ? 'auto' : 'none';
  }
  if (prevBtn) {
    prevBtn.style.opacity = canBackward ? 1 : 0;
    prevBtn.style.pointerEvents = canBackward ? 'auto' : 'none';
  }
}

/* ========================
   SPHERE IMAGE DISPLAY
======================== */
function applyImageToSphere(img) {
  if (sphere) {
    panoGroup.remove(sphere);
    if (sphere.geometry) sphere.geometry.dispose();
    if (sphere.material) {
      if (sphere.material.map) sphere.material.map.dispose();
      sphere.material.dispose();
    }
  }

  const geometry = new THREE.SphereGeometry(100, 60, 40);
  geometry.scale(-1, 1, 1);
  geometry.rotateY(Math.PI);

  const texture = new THREE.Texture(img);
  texture.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
  sphere = new THREE.Mesh(geometry, material);

  sphere.rotation.y = currentYaw;
  sphere.rotation.x = currentPitch;

  panoGroup.add(sphere);
  updateNavigationRing();
}

function loadImageToViewer(imageUrl) {
  if (!viewerInitialized) {
    initThreeJSViewer();
  }

  if (preloadedImages[imageUrl]) {
    applyImageToSphere(preloadedImages[imageUrl]);
    hideViewerLoading();
    preloadAdjacentImages();
    return;
  }

  showViewerLoading('Loading 360 image...');

  const img = new Image();
  img.crossOrigin = 'Anonymous';

  img.onload = function() {
    preloadedImages[imageUrl] = img;
    hideViewerLoading();
    applyImageToSphere(img);
    preloadAdjacentImages();
  };

  img.onerror = function() {
    hideViewerLoading();
    console.error('Failed to load image:', imageUrl);
  };

  if (imageUrl.startsWith('blob:')) {
    img.src = imageUrl;
  } else {
    img.src = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
  }
}

/* ========================
   IMAGE PRELOADING
======================== */
function preloadAdjacentImages() {
  const track = getCurrentTrack();
  if (!track) return;

  const pts = getActivePoints();
  const curPos = pts.findIndex(p => p.index === currentIdx);
  if (curPos < 0) return;

  [-1, 1, -2, 2].forEach(offset => {
    const idx = curPos + offset;
    if (idx >= 0 && idx < pts.length) {
      const imgUrl = track.imagesByIndex[pts[idx].index];
      if (imgUrl && !preloadedImages[imgUrl]) {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => { preloadedImages[imgUrl] = img; };
        img.onerror = () => {};
        img.src = imgUrl.startsWith('blob:') ? imgUrl : imgUrl + '?t=' + Date.now();
      }
    }
  });
}

/* ========================
   VIEWER LOADING STATES
======================== */
function showViewerLoading(msg) {
  const el = document.getElementById('viewer-loading');
  const txt = document.getElementById('loading-text');
  if (el && txt) { txt.textContent = msg; el.style.display = 'block'; }
}

function hideViewerLoading() {
  const el = document.getElementById('viewer-loading');
  if (el) el.style.display = 'none';
}

/* ========================
   VIEWER EVENT LISTENERS
======================== */
function setupViewerEventListeners() {
  const canvas = document.getElementById('canvas');

  let isDragging = false;
  let lastX = 0, lastY = 0;

  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    disableNavButtons();
    lastX = e.clientX;
    lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });

  canvas.addEventListener('mousemove', (e) => {
    if (isDragging && sphere) {
      const deltaX = e.clientX - lastX;
      const deltaY = e.clientY - lastY;

      sphere.rotation.y -= deltaX * 0.01;
      sphere.rotation.x -= deltaY * 0.01;
      sphere.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, sphere.rotation.x));

      currentYaw = sphere.rotation.y;
      currentPitch = sphere.rotation.x;

      lastX = e.clientX;
      lastY = e.clientY;

      updateNavigationRing();
      updateViewCone();
    }
  });

  canvas.addEventListener('mouseup', () => {
    isDragging = false;
    setTimeout(enableNavButtons, 50);
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseenter', () => { canvas.style.cursor = 'grab'; });
  canvas.addEventListener('mouseleave', () => { isDragging = false; canvas.style.cursor = 'default'; });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const zoomSpeed = e.deltaMode === 0 ? 2 : 60;
    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
    const oldFov = currentFov;
    currentFov = Math.max(30, Math.min(120, currentFov + delta));
    if (currentFov !== oldFov) {
      camera.fov = currentFov;
      camera.updateProjectionMatrix();
      updateViewCone();
    }
  }, { passive: false });

  setupTouchGestures(canvas);

  document.getElementById('nextImageBtn').addEventListener('click', navigateForward);
  document.getElementById('prevImageBtn').addEventListener('click', navigateBackward);

  document.getElementById('zoomInBtn').addEventListener('click', () => {
    if (currentFov > 30) {
      currentFov -= 5;
      camera.fov = currentFov;
      camera.updateProjectionMatrix();
      updateViewCone();
    }
  });
  document.getElementById('zoomOutBtn').addEventListener('click', () => {
    if (currentFov < 120) {
      currentFov += 5;
      camera.fov = currentFov;
      camera.updateProjectionMatrix();
      updateViewCone();
    }
  });
}

function setupTouchGestures(canvas) {
  let touchStartDistance = 0;
  let touchStartFov = currentFov;
  let isTouching = false;
  let lastTouchX = 0, lastTouchY = 0;

  function getTouchDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isTouching = true;
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
      e.preventDefault();
    } else if (e.touches.length === 2) {
      touchStartDistance = getTouchDistance(e.touches);
      touchStartFov = currentFov;
      e.preventDefault();
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1 && isTouching && sphere) {
      const deltaX = e.touches[0].clientX - lastTouchX;
      const deltaY = e.touches[0].clientY - lastTouchY;

      sphere.rotation.y -= deltaX * 0.01;
      sphere.rotation.x -= deltaY * 0.01;
      sphere.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, sphere.rotation.x));

      currentYaw = sphere.rotation.y;
      currentPitch = sphere.rotation.x;

      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;

      updateViewCone();
      updateNavigationRing();
      e.preventDefault();
    } else if (e.touches.length === 2) {
      const currentDistance = getTouchDistance(e.touches);
      const scale = touchStartDistance / currentDistance;
      const newFov = Math.max(30, Math.min(120, touchStartFov * scale));
      if (newFov !== currentFov) {
        currentFov = newFov;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        updateViewCone();
      }
      e.preventDefault();
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    if (e.touches.length === 0) {
      isTouching = false;
      touchStartDistance = 0;
    } else if (e.touches.length === 1) {
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    }
  }, { passive: false });
}

function disableNavButtons() {
  document.querySelectorAll('.nav-button.ring-button').forEach(b => { b.style.pointerEvents = 'none'; });
}

function enableNavButtons() {
  document.querySelectorAll('.nav-button.ring-button').forEach(b => { b.style.pointerEvents = 'auto'; });
}

/* ========================
   VIEW CONE ON MAP
======================== */
let lastPathBearing = 0;

function initConeSystem() {
  if (!map.getSource('view-cone')) {
    map.addSource('view-cone', {
      type: 'geojson',
      data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] } }
    });

    map.addLayer({
      id: 'view-cone-fill', type: 'fill', source: 'view-cone',
      paint: { 'fill-color': '#ff8400', 'fill-opacity': 0.5 }
    });

    map.addLayer({
      id: 'view-cone-outline', type: 'line', source: 'view-cone',
      paint: { 'line-color': '#ff6b6b', 'line-width': 2, 'line-opacity': 0 }
    });
  }
}

function getHorizontalFovDeg() {
  if (!camera) return 90;
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad / 2) * camera.aspect);
  return THREE.MathUtils.radToDeg(hRad);
}

function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters, steps) {
  radiusMeters = radiusMeters || 15;
  steps = steps || 24;
  const half = Math.max(0, Math.min(89, fovDeg / 2));
  const start = headingDeg - half;
  const end = headingDeg + half;

  const ring = [[lon, lat]];
  for (let s = 0; s <= steps; s++) {
    const t = s / steps;
    const brg = start + (end - start) * t;
    ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
  }
  ring.push([lon, lat]);
  return ring;
}

function updateViewCone() {
  if (!map || !map.getSource('view-cone')) return;

  const pos = getCurrentPointPosition();
  if (!pos) return;

  const nextPos = getNextPointPosition();
  const prevPos = getPrevPointPosition();
  let pathBearing = lastPathBearing;

  if (nextPos) {
    pathBearing = bearingDeg(pos, nextPos);
  } else if (prevPos) {
    pathBearing = bearingDeg(prevPos, pos);
  }

  if (lastPathBearing !== undefined) {
    let diff = pathBearing - lastPathBearing;
    if (Math.abs(diff) > 180) {
      pathBearing += diff > 0 ? -360 : 360;
    }
  }
  lastPathBearing = pathBearing;

  const userYawDeg = THREE.MathUtils.radToDeg(currentYaw);
  const finalHeading = (pathBearing + userYawDeg + 360) % 360;

  const fovH = getHorizontalFovDeg();
  const ring = makeViewConeRing(pos[1], pos[0], finalHeading, fovH, 15, 24);

  map.getSource('view-cone').setData({
    type: 'Feature',
    geometry: { type: 'Polygon', coordinates: [ring] }
  });
}

function hideViewCone() {
  if (map && map.getSource('view-cone')) {
    map.getSource('view-cone').setData({
      type: 'Feature',
      geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] }
    });
  }
}

map.on('zoom', () => { if (currentIdx >= 0) updateViewCone(); });
map.on('move', () => { if (currentIdx >= 0) updateViewCone(); });

/* ========================
   VIEWER & NAVIGATION
======================== */
function openViewer(id) {
  const track = getCurrentTrack();
  if (!track) return;

  const p = track.rawPoints.find(rp => rp.index === id);
  if (!p) return;

  currentIdx = id;

  document.getElementById('empty-msg').style.display = 'none';

  if (track.imagesByIndex[id]) {
    loadImageToViewer(track.imagesByIndex[id]);
  } else {
    if (!viewerInitialized) initThreeJSViewer();
  }

  // Update counter
  const pts = getActivePoints();
  const curPos = pts.findIndex(pt => pt.index === id);
  document.getElementById('time').textContent = curPos >= 0
    ? `${curPos + 1}/${pts.length}`
    : `-/-`;

  // Highlight dots
  document.querySelectorAll('.blue-dot').forEach(el => el.classList.remove('active'));
  document.querySelectorAll('.red-dot').forEach(el => el.classList.remove('active'));

  const activeBlueMarker = track.blueMarkers.find(m => m.getElement().innerText == id);
  if (activeBlueMarker) activeBlueMarker.getElement().classList.add('active');

  const activeRedMarker = track.redMarkers.find(m => m.data.imageIndex == id);
  if (activeRedMarker) activeRedMarker.marker.getElement().classList.add('active');

  map.easeTo({ center: [p.lon, p.lat] });
  document.getElementById('viewer-title').innerText = `${track.name} · Point ${id}`;

  updateViewCone();
}

function fitToTrack() {
  const ct = getCurrentTrack();
  if (ct && ct.rawPoints.length > 0) {
    const b = new mapboxgl.LngLatBounds();
    ct.rawPoints.forEach(p => b.extend([p.lon, p.lat]));
    map.fitBounds(b, { padding: 50 });
    return;
  }
  fitToAllTracks();
}

function fitToAllTracks() {
  const b = new mapboxgl.LngLatBounds();
  let hasPoints = false;
  tracks.forEach(t => {
    t.rawPoints.forEach(p => { b.extend([p.lon, p.lat]); hasPoints = true; });
  });
  if (hasPoints) map.fitBounds(b, { padding: 50 });
}

/* ========================
   BUTTON LISTENERS
======================== */
document.getElementById('generateRedBtn').onclick = generateRedTrack;
document.getElementById('projectPointsBtn').onclick = () => projectPointsToRed();
document.getElementById('fitBtn').onclick = fitToTrack;

document.getElementById('exportBtn').onclick = () => {
  const track = getCurrentTrack();
  if (!track) return;

  const exportData = {
    rawPoints: track.rawPoints.map(p => ({
      index: p.index,
      lat: p.lat,
      lon: p.lon,
      imageUrl: track.imagesByIndex[p.index]
    })),
    controlPoints: track.controlPointMarkers.map(m => {
      const ll = m.getLngLat();
      return { lon: ll.lng, lat: ll.lat };
    }),
    redMarkers: track.redMarkers.map(m => ({
      sequentialIndex: m.data.sequentialIndex,
      originalImageIndex: m.data.imageIndex,
      lat: m.data.lat,
      lon: m.data.lon
    }))
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${track.name}_smoothed_path.json`;
  a.click();
};

document.getElementById('exportGpxBtn').onclick = () => {
  const track = getCurrentTrack();
  if (!track || !track.redTrackLine || track.redMarkers.length === 0) return;

  const curveCoords = track.redTrackLine.geometry.coordinates;

  let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
  gpx += '<gpx version="1.1" creator="Quickview Editor" xmlns="http://www.topografix.com/GPX/1/1">\n';
  gpx += '  <trk>\n';
  gpx += `    <name>${track.name}_smoothed</name>\n`;
  gpx += '    <trkseg>\n';

  curveCoords.forEach(coord => {
    gpx += `      <trkpt lat="${coord[1]}" lon="${coord[0]}"></trkpt>\n`;
  });

  gpx += '    </trkseg>\n';
  gpx += '  </trk>\n';

  track.redMarkers.forEach((m, idx) => {
    gpx += `  <wpt lat="${m.data.lat}" lon="${m.data.lon}">\n`;
    gpx += `    <name>Photo_${idx + 1} - Image ${m.data.imageIndex}</name>\n`;
    gpx += `    <desc>Marble position along route - Image ${m.data.imageIndex}</desc>\n`;
    gpx += `  </wpt>\n`;
  });

  gpx += '</gpx>';

  const blob = new Blob([gpx], {type: 'application/gpx+xml'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${track.name}_smoothed.gpx`;
  a.click();
};

/* ========================
   GPX LOADING (multi-file)
======================== */
document.getElementById('gpxInput').onchange = async (e) => {
  const files = Array.from(e.target.files);
  if (files.length === 0) return;

  const numPoints = parseInt(document.getElementById('numPointsInput').value) || 10;

  for (const f of files) {
    const gpxText = await f.text();
    const gpxLine = parseGpxFile(gpxText);
    if (!gpxLine) continue;

    const name = f.name.replace(/\.gpx$/i, '');
    const track = createTrackData(name);
    track.gpxLine = gpxLine;

    const points = generatePointsFromGpx(gpxLine, numPoints);
    if (points.length > 0) {
      track.rawPoints = points;
      tracks.set(track.id, track);
      processRawPoints(track);
    }
  }

  // Select first track if none selected
  if (!currentTrackId && tracks.size > 0) {
    selectTrack(tracks.keys().next().value);
  }

  updateTracksList();
  fitToAllTracks();

  document.getElementById('generateFromGpxBtn').disabled = false;
  document.getElementById('exportCreatedJsonBtn').disabled = false;
};

/* ========================
   REGENERATE POINTS (current track)
======================== */
document.getElementById('generateFromGpxBtn').onclick = () => {
  const track = getCurrentTrack();
  if (!track || !track.gpxLine) return;

  const numPoints = parseInt(document.getElementById('numPointsInput').value) || 10;
  if (numPoints < 2) {
    alert('Minimum 2 points required');
    return;
  }

  // Clear existing editing state for this track
  track.redMarkers.forEach(m => m.marker.remove());
  track.redMarkers = [];
  track.controlPointMarkers.forEach(m => m.remove());
  track.controlPointMarkers = [];
  track.controlPoints = [];
  if (map.getLayer(`red-track-${track.id}`)) map.removeLayer(`red-track-${track.id}`);
  if (map.getSource(`red-track-${track.id}`)) map.removeSource(`red-track-${track.id}`);
  track.redTrackLine = null;

  const points = generatePointsFromGpx(track.gpxLine, numPoints);
  track.rawPoints = points;
  processRawPoints(track);
  updateTracksList();

  document.getElementById('projectPointsBtn').disabled = true;
  document.getElementById('exportBtn').disabled = true;
  document.getElementById('exportGpxBtn').disabled = true;
};

document.getElementById('exportCreatedJsonBtn').onclick = () => {
  const track = getCurrentTrack();
  if (!track || track.rawPoints.length === 0) return;

  const exportData = {
    points: track.rawPoints.map(p => ({
      index: p.index,
      lat: p.lat,
      lon: p.lon
    }))
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${track.name}_blue_points.json`;
  a.click();
};

/* ========================
   JSON LOAD (creates new track)
======================== */
document.getElementById('jsonInput').onchange = async (e) => {
  const f = e.target.files[0];
  if (!f) return;

  const data = JSON.parse(await f.text());
  const name = f.name.replace(/\.json$/i, '');
  const track = createTrackData(name);
  track.rawPoints = data.points;
  tracks.set(track.id, track);
  processRawPoints(track);

  if (!currentTrackId) selectTrack(track.id);
  else { selectTrack(track.id); }
  updateTracksList();
  fitToTrack();
};

/* ========================
   IMAGE LOADING (multi-track aware)
======================== */
document.getElementById('imagesInput').onchange = (ev) => {
  const files = Array.from(ev.target.files).filter(f =>
    !f.name.startsWith('.') && /\.(jpg|jpeg|png)$/i.test(f.name)
  );

  if (files.length === 0) return;

  // Multi-track pattern: {trackname}{tracknum}-{imagenum}.ext
  // e.g., senterra1-5.jpg → track "senterra1", image 5
  const trackPattern = /^(.+?)(\d+)-(\d+)\.[^.]+$/;
  let multiCount = 0;
  let singleCount = 0;

  files.forEach(f => {
    const multiMatch = f.name.match(trackPattern);
    if (multiMatch) {
      const trackName = multiMatch[1] + multiMatch[2];
      const imageNum = parseInt(multiMatch[3]);
      const track = findTrackByName(trackName);
      if (track) {
        track.imagesByIndex[imageNum] = URL.createObjectURL(f);
        multiCount++;
        return;
      }
    }

    // Fallback: simple number → assign to current track
    const simpleMatch = f.name.match(/(\d+)\.[^.]+$/);
    if (simpleMatch) {
      const ct = getCurrentTrack();
      if (ct) {
        ct.imagesByIndex[parseInt(simpleMatch[1])] = URL.createObjectURL(f);
        singleCount++;
      }
    }
  });

  console.log(`Loaded images: ${multiCount} multi-track, ${singleCount} single-track`);

  // Update all track marker colors
  tracks.forEach(track => updateMarkerColors(track));
  updateTracksList();
  updateStatus();

  // Reload current viewer image if available
  const ct = getCurrentTrack();
  if (ct && currentIdx >= 0 && ct.imagesByIndex[currentIdx]) {
    loadImageToViewer(ct.imagesByIndex[currentIdx]);
  }
};

/* ========================
   CLEAR ALL
======================== */
function clearAll() {
  // Remove all track map layers and markers
  tracks.forEach((track, trackId) => {
    if (map.getLayer(`blue-track-${trackId}`)) map.removeLayer(`blue-track-${trackId}`);
    if (map.getSource(`blue-track-${trackId}`)) map.removeSource(`blue-track-${trackId}`);
    if (map.getLayer(`red-track-${trackId}`)) map.removeLayer(`red-track-${trackId}`);
    if (map.getSource(`red-track-${trackId}`)) map.removeSource(`red-track-${trackId}`);

    track.blueMarkers.forEach(m => m.remove());
    track.redMarkers.forEach(m => m.marker.remove());
    track.controlPointMarkers.forEach(m => m.remove());

    Object.values(track.imagesByIndex).forEach(url => {
      if (url && url.startsWith('blob:')) URL.revokeObjectURL(url);
    });
  });

  tracks.clear();
  currentTrackId = null;
  currentIdx = -1;

  // Clean up Three.js
  if (sphere) {
    panoGroup.remove(sphere);
    if (sphere.geometry) sphere.geometry.dispose();
    if (sphere.material) {
      if (sphere.material.map) sphere.material.map.dispose();
      sphere.material.dispose();
    }
    sphere = null;
  }
  currentYaw = 0;
  currentPitch = 0;
  currentFov = 75;
  preloadedImages = {};

  document.getElementById('empty-msg').style.display = 'flex';
  document.getElementById('empty-msg').textContent = 'Load data to begin';
  document.getElementById('viewer-title').textContent = 'Street View';
  document.getElementById('viewer-meta').textContent = '';
  document.getElementById('time').textContent = '-/-';

  document.getElementById('projectPointsBtn').disabled = true;
  document.getElementById('exportBtn').disabled = true;
  document.getElementById('exportGpxBtn').disabled = true;
  document.getElementById('dragMode').disabled = true;
  document.getElementById('exportCreatedJsonBtn').disabled = true;
  document.getElementById('generateFromGpxBtn').disabled = true;

  addCPModeActive = false;
  removeCPModeActive = false;
  dragModeActive = false;
  removePointModeActive = false;
  document.getElementById('addCPMode').checked = false;
  document.getElementById('removeCPMode').checked = false;
  document.getElementById('dragMode').checked = false;
  document.getElementById('removePointMode').checked = false;

  hideViewCone();
  updateTracksList();
  updateStatus();
}

document.getElementById('clearAllBtn').onclick = clearAll;

/* ========================
   IMPORT RED PATH (creates new track)
======================== */
document.getElementById('importRedInput').onchange = async (e) => {
  const f = e.target.files[0];
  if (!f) return;

  const data = JSON.parse(await f.text());
  const name = f.name.replace(/\.json$/i, '');
  const track = createTrackData(name);

  if (data.rawPoints && data.rawPoints.length > 0) {
    data.rawPoints.forEach(p => {
      if (p.imageUrl && !p.imageUrl.startsWith('blob:')) {
        track.imagesByIndex[p.index] = p.imageUrl;
      }
    });
    track.rawPoints = data.rawPoints;
  }

  tracks.set(track.id, track);
  processRawPoints(track);
  selectTrack(track.id);

  if (data.controlPoints && data.controlPoints.length > 0) {
    data.controlPoints.forEach(cp => {
      createCPMarker([cp.lon, cp.lat], track);
    });
    updateRedTrackLine(track);
    document.getElementById('showRedTrack').checked = true;
    document.getElementById('projectPointsBtn').disabled = false;
  }

  if (data.redMarkers && data.redMarkers.length > 0) {
    data.redMarkers.forEach(p => {
      createRedMarker(
        [p.lon, p.lat],
        p.sequentialIndex,
        p.originalImageIndex,
        track
      );
    });

    document.getElementById('showRedDots').checked = true;
    document.getElementById('dragMode').disabled = false;
    document.getElementById('exportBtn').disabled = false;
    document.getElementById('exportGpxBtn').disabled = false;
  }

  updateTracksList();
  updateStatus();
};

/* ========================
   INIT CONE ON MAP LOAD
======================== */
map.on('load', () => {
  initConeSystem();
});

// Ready
</script>
</body>
</html>
