<!DOCTYPE html>
<!--
  ============================================
  INDEX-ALPHA.HTML - CONFIG IMPLEMENTATION
  ============================================

  This file implements the client configuration system.
  All client-specific values (names, coordinates, logos, etc.) are now
  loaded from client-config.js instead of being hardcoded.

  Changes from index-beta.html:
  - Loads client-config.js
  - Uses CONFIG object for all client-specific values
  - Dynamic page title, logos, community data
  - Configurable mapbox settings, aerial images
  - Dynamic WhatsApp links and contact info
  - All 'marsella' defaults replaced with CONFIG.defaultCommunity
  - All 'INVERTA' text replaced with CONFIG.name

  To switch clients: Change CURRENT_CLIENT variable to match
  a client key in CLIENT_CONFIGS object in client-config.js

  See CLIENT-CONFIG-GUIDE.md for documentation.
  ============================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- ===== LEAD AUTH CHECK (runs first) ===== -->
  <script>
    (function() {
      const CURRENT_CLIENT = 'agora';

      // Cookie helpers
      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return null;
      }

      function setCookie(name, value, days) {
        const expires = new Date(Date.now() + days * 864e5).toUTCString();
        document.cookie = `${name}=${value}; expires=${expires}; path=/; SameSite=Lax`;
      }

      // Check if URL has ?token= query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const urlToken = urlParams.get('token');

      // Check for session cookie
      const sessionToken = getCookie('lead_session_' + CURRENT_CLIENT);

      // If no token in URL and no session, redirect to registro
      if (!urlToken && !sessionToken) {
        window.location.href = '/' + CURRENT_CLIENT + '/registro.html';
        // Stop execution
        throw new Error('Redirecting to registro');
      }

      // Store token for later validation (after Supabase loads)
      window.__leadAuthToken = urlToken;
      window.__leadSessionToken = sessionToken;
      window.__leadClient = CURRENT_CLIENT;
    })();
  </script>

  <title></title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@4.5.0/dist/togeojson.umd.js"></script>
<script src="https://js.stripe.com/v3/"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<link rel="stylesheet" href="https://la-la.land/styles.css">
<link rel="stylesheet" href="https://la-la.land/street-view-nav.css">

<!-- ===== LOAD CLIENT CONFIGURATION ===== -->
<script src="client-config.js"></script>
<script>
// ===== CLIENT CONFIG =====
const CURRENT_CLIENT = 'agora';
const CONFIG = getClientConfig(CURRENT_CLIENT);

// Validate config loaded
if (!CONFIG) {
  console.error('‚ùå Failed to load client config for:', CURRENT_CLIENT);
} else {
  console.log('‚úÖ Client config loaded:', CONFIG.name);
  // Update page title from config
  if (CONFIG.displayName) {
    document.title = CONFIG.displayName;
  }
  // Apply colors to CSS variables
  if (CONFIG.colors) {
    applyColorsToCSS(CURRENT_CLIENT);
  }
  // Apply font family to CSS variable
  if (CONFIG.misc && CONFIG.misc.fontFamily) {
    document.documentElement.style.setProperty('--font-family', `'${CONFIG.misc.fontFamily}', Arial, sans-serif`);
    console.log('‚úÖ Font family set to:', CONFIG.misc.fontFamily);
  }
}

// ===== PERFORMANCE: Client Access Cache =====
// Cache validation results per session to avoid repeated DB queries
window.clientAccessCache = window.clientAccessCache || {};
</script>

  <script>
    // Font loading handler (runs before DOMContentLoaded)
    document.fonts.ready.then(() => {
      document.body.classList.add('fonts-loaded');
    }).catch(() => {
      document.body.classList.add('fonts-loaded'); // Fallback if fonts fail
    });
  </script>
</head>
 
<body>









<div id="map" style="position: absolute; top: 0; bottom: 0; width: 100%; z-index: 0;"></div>


 
<div id="toaster" class="hidden">Loaded most recent aerial image (March 2025)</div>
<a href=""
   target="_blank"
   id="ctaToaster"
   class="hidden">
</a>
<script>
  // Update WhatsApp link from config
  (function() {
    try {
      const ctaToaster = document.getElementById('ctaToaster');
      if (ctaToaster && CONFIG && CONFIG.contact && CONFIG.contact.whatsapp) {
        const wa = CONFIG.contact.whatsapp;
        ctaToaster.href = `https://wa.me/${wa.number}`;
        ctaToaster.dataset.utmSource = wa.utmSource;
        ctaToaster.dataset.utmMedium = wa.utmMedium;
        ctaToaster.dataset.utmCampaign = wa.utmCampaign;
        ctaToaster.textContent = wa.defaultMessage;
      }
    } catch (e) {
      console.error('‚ùå Error loading WhatsApp config:', e);
    }
  })();
</script>

<!-- Lead greeting in top right -->
<div id="lead-greeting" class="lead-greeting">
  Hola, <span id="lead-name"></span>
</div>

<!-- Name Modal (shown when lead has no name) -->
<div id="nameModal" class="name-modal">
  <div class="name-modal-content">
    <h2>¬°Bienvenido!</h2>
    <p>¬øC√≥mo te llamas?</p>
    <form id="nameForm">
      <input type="text" id="leadNameInput" placeholder="Nombre" required>
      <input type="text" id="leadLastNameInput" placeholder="Apellido" required>
      <button type="submit">EMPEZAR</button>
    </form>
  </div>
</div>

<!-- Dashboard button - bottom left above mapbox logo, only visible when authenticated -->
<button id="dashboard-btn" class="dashboard-button" title="Dashboard">
  <!-- Eye Closed Icon (with slash - shown when dashboard is NOT visible) -->
  <svg id="eye-closed-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 7C14.76 7 17 9.24 17 12C17 12.65 16.87 13.26 16.64 13.83L19.56 16.75C21.07 15.49 22.26 13.86 22.99 12C21.26 7.61 16.99 4.5 11.99 4.5C10.59 4.5 9.25 4.75 8.01 5.2L10.17 7.36C10.74 7.13 11.35 7 12 7ZM2 4.27L4.28 6.55L4.74 7.01C3.08 8.3 1.78 10.02 1 12C2.73 16.39 7 19.5 12 19.5C13.55 19.5 15.03 19.2 16.38 18.66L16.8 19.08L19.73 22L21 20.73L3.27 3L2 4.27ZM7.53 9.8L9.08 11.35C9.03 11.56 9 11.78 9 12C9 13.66 10.34 15 12 15C12.22 15 12.44 14.97 12.65 14.92L14.2 16.47C13.53 16.8 12.79 17 12 17C9.24 17 7 14.76 7 12C7 11.21 7.2 10.47 7.53 9.8ZM11.84 9.02L14.99 12.17L15.01 12.01C15.01 10.35 13.67 9.01 12.01 9.01L11.84 9.02Z" fill="var(--color-white)"/>
  </svg>
  <!-- Eye Open Icon (shown when dashboard IS visible) -->
  <svg id="eye-open-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 5C7 5 2.73 8.11 1 12.5C2.73 16.89 7 20 12 20C17 20 21.27 16.89 23 12.5C21.27 8.11 17 5 12 5ZM12 17C9.24 17 7 14.76 7 12C7 9.24 9.24 7 12 7C14.76 7 17 9.24 17 12C17 14.76 14.76 17 12 17ZM12 9C10.34 9 9 10.34 9 12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12C15 10.34 13.66 9 12 9Z" fill="var(--color-white)"/>
  </svg>
  <span>Dashboard</span>
</button>

<div class="lala-wrapper">
   <a href="https://la-la.land/company" title="Go to La-La Land">
  <img src="https://la-la.land/lalaland_bw.svg" alt="Logo"></a>
</div>

<div class="logoinv-wrapper">
   <a href="#" onclick="event.preventDefault(); window.location.reload(true);" title="Reload Site">
  <img id="mainClientLogo" src="" alt="" style="height:40px;"></a>
</div>
<script>
  // Set main logo from config
  (function() {
    try {
      const mainLogo = document.getElementById('mainClientLogo');
      if (mainLogo && CONFIG && CONFIG.branding) {
        mainLogo.src = CONFIG.branding.mainLogo;
        mainLogo.alt = CONFIG.branding.mainLogoAlt;
      }
    } catch (e) {
      console.error('‚ùå Error loading main logo config:', e);
    }
  })();
</script>

<!-- Conditional community logo -->
<div class="community-logo-wrapper" id="communityLogo" style="top:70px;">
  <img id="communityLogoImg" src="" alt="Community Logo">
</div>
<script>
  // Set initial community logo from config (for default community)
  (function() {
    try {
      const communityLogoImg = document.getElementById('communityLogoImg');
      if (communityLogoImg && CONFIG && CONFIG.defaultCommunity) {
        const defaultLogo = getCommunityLogo(CURRENT_CLIENT, CONFIG.defaultCommunity);
        communityLogoImg.src = defaultLogo;
      }
    } catch (e) {
      console.error('‚ùå Error loading community logo config:', e);
    }
  })();
</script>

<!-- Modal Panel -->
<div id="lotModal">
  <div class="modal-header">
    <div class="header-control" id="backButton">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M10 4 L6 8 L10 12" fill="none"/>
      </svg>
    </div>

<!-- Unit controls (left) -->
<div class="unit-controls" id="unitControls">
  <button class="unit-btn unit-btn-sort" data-mode="price" title="Sort by Price" translate="no">$$$</button>
  <button class="unit-btn unit-btn-compare" id="compareBtn" title="Compare Lots" translate="no">COMPARAR</button>
</div>



    <div class="header-title">
      <span id="headerFracc"></span><span class="header-lot-number" id="headerLotNumber"></span>
    </div>
    <script>
      // Set initial header from config
      (function() {
        try {
          const headerFracc = document.getElementById('headerFracc');
          if (headerFracc && CONFIG && CONFIG.name) {
            headerFracc.textContent = CONFIG.name;
          }
        } catch (e) {
          console.error('‚ùå Error loading header config:', e);
        }
      })();
    </script>

<!-- AUTH controls (hidden - using globe button instead) -->
<div class="auth-controls" id="authControls">
  <button id="modal-login-btn" class="header-control auth-btn" title="Login">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="var(--color-grayMedium)" aria-hidden="true">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V9h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
    </svg>
  </button>
</div>

<!-- üü¢ SHARE BUTTON (only visible in detail mode, positioned near X) -->
<button class="unit-btn" id="shareButton" title="Share this lot" translate="no">
  <svg width="12" height="12" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11 6C12.6569 6 14 4.65685 14 3C14 1.34315 12.6569 0 11 0C9.34315 0 8 1.34315 8 3C8 3.22371 8.02449 3.44169 8.07092 3.65143L4.86861 5.65287C4.35599 5.24423 3.70652 5 3 5C1.34315 5 0 6.34315 0 8C0 9.65685 1.34315 11 3 11C3.70652 11 4.35599 10.7558 4.86861 10.3471L8.07092 12.3486C8.02449 12.5583 8 12.7763 8 13C8 14.6569 9.34315 16 11 16C12.6569 16 14 14.6569 14 13C14 11.3431 12.6569 10 11 10C10.2935 10 9.644 10.2442 9.13139 10.6529L5.92908 8.65143C5.97551 8.44169 6 8.22371 6 8C6 7.77629 5.97551 7.55831 5.92908 7.34857L9.13139 5.34713C9.644 5.75577 10.2935 6 11 6Z" fill="var(--color-cream)"/>
  </svg>COMPARTIR
</button>

<!-- üü¢ POI BUTTON (only visible in list mode, positioned near X) -->
<button class="unit-btn" id="poiButton" title="Add Point of Interest" translate="no">PIN</button>

<!-- üîí LOCK BUTTON (only visible in pin mode when authenticated, positioned on left side) -->
<button class="unit-btn" id="pinLockButton" title="Lock/Unlock Pin" translate="no">
  <!-- Unlocked icon (default) -->
  <svg id="unlockIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M18 8H17V6C17 3.24 14.76 1 12 1C9.24 1 7 3.24 7 6H9C9 4.34 10.34 3 12 3C13.66 3 15 4.34 15 6V8H6C4.9 8 4 8.9 4 10V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V10C20 8.9 19.1 8 18 8ZM18 20H6V10H18V20ZM12 17C13.1 17 14 16.1 14 15C14 13.9 13.1 13 12 13C10.9 13 10 13.9 10 15C10 16.1 10.9 17 12 17Z" fill="var(--color-cream)"/>
  </svg>
  <!-- Locked icon -->
  <svg id="lockIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M18 8H17V6C17 3.24 14.76 1 12 1C9.24 1 7 3.24 7 6V8H6C4.9 8 4 8.9 4 10V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V10C20 8.9 19.1 8 18 8ZM12 17C10.9 17 10 16.1 10 15C14 13.9 10.9 13 12 13C13.1 13 14 13.9 14 15C14 16.1 13.1 17 12 17ZM15.1 8H8.9V6C8.9 4.29 10.29 2.9 12 2.9C13.71 2.9 15.1 4.29 15.1 6V8Z" fill="var(--color-cream)"/>
  </svg>
</button>

<!-- üåê GLOBAL DASHBOARD BUTTON (only visible in dashboard mode, positioned on right side) -->
<button class="unit-btn" id="globalDashboardButton" title="View All Communities" translate="no">GLOBAL</button>

    <div class="header-control close-x" onclick="console.log('‚ùå X BUTTON CLICKED'); closeModal();" id="closeModalBtn">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M4 4 L12 12 M12 4 L4 12" fill="none"/>
      </svg>
    </div>
<div class="header-control plus-button" onclick="handlePlusButton()">
<svg viewBox="0 0 16 16">
  <!-- Plus sign (centered) -->
  <path class="plus-icon" d="M8 3 L8 13 M3 8 L13 8"
        fill="none" stroke="var(--color-grayMedium)" stroke-width="1.5" stroke-linecap="round" />

  <!-- Minus sign (centered) -->
  <path class="minus-icon" d="M3 8 L13 8"
        fill="none" stroke="var(--color-grayMedium)" stroke-width="1.5" stroke-linecap="round"/>
</svg>
</div>



  </div>
  <div class="modal-divider"></div>
  <div class="modal-content-wrapper">
    <div class="loading-spinner" id="loadingSpinner"></div>

<div class="lot-details" id="lotDetails"></div>

<!-- Calendly must be a sibling, not inside lotDetails -->
<div id="calendlyEmbed" class="calendly-embed-container">

  <iframe id="calendly-iframe"
          src="about:blank"
          frameborder="0"></iframe>
</div>

<!-- üü¢ ADD 360 VIEWER HERE (right after calendly) -->
    <div id="viewer-container" class="viewer-mode">
      <canvas id="canvas"></canvas>

      <div class="viewer-controls">
        <button id="prevImageBtnTop">‚Üê Prev</button>
        <span id="viewer-info">No images loaded</span>
        <button id="nextImageBtnTop">Next ‚Üí</button>
      </div>

      <div class="image-controls">
        <div class="navigation-ring">
          <button class="nav-button ring-button" id="nextImageBtn">‚ñ≥</button>
          <button class="nav-button ring-button" id="prevImageBtn">‚ñΩ</button>
          <button class="nav-button ring-button" id="branchImageBtn">‚ñ∑</button>
        </div>
      </div>

      <div class="time" id="time">-/-</div>

      <div class="loading" id="viewer-loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading 360¬∞ image...</div>
      </div>
    </div>
    <!-- üü¢ END 360 VIEWER -->

<div class="modal-info" id="modalInfo"></div>
    <div class="custom-scrollbar" id="customScrollbar">
      <div class="custom-scrollthumb" id="customScrollthumb"></div>
    </div>
  </div>
  <div class="bottom-plus-button" onclick="handlePlusButton()">
  <svg viewBox="0 0 16 16" class="wiggle-arrow">
    <path d="M4 6 L8 10 L12 6"
          fill="none" stroke="var(--color-white)" stroke-width="1.5" stroke-linecap="round" />
  </svg>
  </div>
</div>

<!-- AUTH MODAL -->
<div id="auth-modal">
  <div class="auth-box">
    <h2>Iniciar sesi√≥n</h2>

    <div id="auth-step-email">
      <label for="auth-email">Correo electr√≥nico</label>
      <input type="email" id="auth-email" placeholder="tu@correo.com">
      <button class="primary" id="request-otp">Enviar c√≥digo</button>
      <button class="secondary" id="auth-cancel">Cancelar</button>
    </div>

    <div id="auth-step-otp">
      <label for="auth-otp">C√≥digo enviado a <span id="otp-email-display"></span></label>
      <input type="text" id="auth-otp" maxlength="6" placeholder="123456">
      <button class="primary" id="verify-otp">Verificar</button>
      <button class="secondary" id="auth-cancel">Cancelar</button>
    </div>
  </div>
</div>

<!-- LOGOUT CONFIRMATION MODAL -->
<div id="logout-modal">
  <div class="auth-box">
    <h2>Cerrar sesi√≥n</h2>
    <p>¬øEst√°s seguro de que quieres cerrar sesi√≥n?</p>
    <button class="primary" id="confirm-logout">Cerrar sesi√≥n</button>
    <button class="secondary" id="cancel-logout">Cancelar</button>
  </div>
</div>


<!-- Whatsapp button 
<a href="https://wa.me/5218185261819" target="_blank" class="whatsapp-button"
   data-utm-source="website"
   data-utm-medium="button"
   data-utm-campaign="lead_generation">
  <img src="https://la-la.land/whatrans.png" alt="WhatsApp" />
</a> -->

<!-- Lalaland Info Button 
<button class="lalaland-button" id="lalalandInfoBtn">
<svg width="36" height="36" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <path style="fill:none;stroke:${CONFIG.colors.white};stroke-width:1.3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" 
        d="M20.749.039a2.235 2.235 0 0 0-1.084 2.06v.01a1.87 1.87 0 0 0-1.155 2.5l-.016.023a1.501 1.501 0 0 0-.775 1.95 1.492 1.492 0 0 0 2.168.674l5.576-3.218-.001-.003c.813-.486 1.14-1.5.763-2.37A1.878 1.878 0 0 0 23.76.71l-.007.004a2.21 2.21 0 0 0-2.033-.988 2.253 2.253 0 0 0-.97.313z" 
        transform="rotate(30 8.172 -24.122) scale(2) translate(-7, -.7)"/>
</svg>
</button> -->


<!-- Old Search Button removed - replaced by new search button component at bottom of file --> 

  <!-- GPS button - bottom right above lalaland logo -->
<button id="gpsButton" class="gps-button" title="Enable GPS">
 <svg viewBox="0 0 24 24" width="18" height="18" stroke="var(--color-white)" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="9" />
    <line x1="12" y1="2" x2="12" y2="5" />
    <line x1="12" y1="19" x2="12" y2="22" />
    <line x1="2" y1="12" x2="5" y2="12" />
    <line x1="19" y1="12" x2="22" y2="12" />
    <circle cx="12" cy="12" r="4.5" fill="var(--color-white)" stroke="none" />
  </svg>
</button>

<!-- info button
<button id="infoBtn" class="map-info-button" title="View Info">
  <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">

    <circle cx="12" cy="12" r="9" stroke-width="2"></circle>


    <line x1="12" y1="7"  x2="12" y2="7"  stroke-width="3" stroke="var(--color-textMedium)" fill="none"></line>
    <line x1="12" y1="12" x2="12" y2="17" stroke-width="3" stroke="var(--color-textMedium)" fill="none"></line>
  </svg>
</button> -->

<!-- AVAILABILITY BUTTON -->
<button id="cycleAvailabilityBtn" class="gps-button" title="Cycle Availability">
  <svg viewBox="0 0 24 24" width="24" height="24" stroke="var(--color-textMedium)" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M23 4L23 10 17 10"></path>
    <path d="M1 20L1 14 7 14"></path>
    <path d="M3.51 9a9 9 0 0114.85-3.36L23 10"></path>
    <path d="M20.49 15a9 9 0 01-14.85 3.36L1 14"></path>
  </svg>
</button>

<!-- Compare BUTTON - HIDDEN (moved to modal header) -->
<button id="compareBtnOld" class="gps-button" title="Compare Lots">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="black" stroke-width="2.3" stroke-linecap="round" stroke-linejoin="round">
  <!-- Left cover -->
  <path d="M2.5 5c3.2-1.6 6.5-1.6 9.5 0v14c-3.2-1.6-6.5-1.6-9.5 0z"/>
  <!-- Right cover -->
  <path d="M21.5 5c-3.2-1.6-6.5-1.6-9.5 0v14c3.2-1.6 6.5-1.6 9.5 0z"/>
</svg>
</button>

<!-- Edit BUTTON -->
<button id="editBtn" class="gps-button" title="Edit Button">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 17.25V21H6.75L17.81 9.94L14.06 6.19L3 17.25ZM20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C17.98 2.9 17.35 2.9 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04Z" fill="currentColor"/>
</svg>
</button>

<script>

// ===== 360 VIEWER GLOBALS =====
let allTracks = new Map();
let currentTrackId = null;
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;
let selectedMarbleId = null;
// Marriage system
let marriageGroups = []; // Array of arrays: [["gpxName.gpx:15", "gpxName2.gpx:42"], ...]
let antiMarriageGroups = []; // Array of arrays: pairs that block navigation between them
let lastHopBearingDeg = null;
let currentImages = [];
let currentImageIndex = -1;
let imageNumberToArrayIndex = {}; // Maps original image number (from filename) to currentImages array position
let preloadedImages = {};
let viewConeMarker = null;
let isSwitchingTrack = false;

// Dynamic frames base - changes based on current fraccionamiento
// Initialize from framesBase URL to ensure we start with the right location
const _fraccMatch = (CONFIG.data.framesBase || '').match(/\/([^\/]+)\/frames\/?$/);
let currentFraccionamiento = _fraccMatch ? _fraccMatch[1] : (CONFIG.defaultCommunity || Object.keys(CONFIG.communities)[0]);

function getFramesBase() {
  const community = Object.values(CONFIG.communities)
    .find(c => c.fracc === currentFraccionamiento || c.id === currentFraccionamiento);
  return community?.framesBase || CONFIG.data.framesBase;
}
// ===== REST OF YOUR EXISTING CODE STARTS HERE =====
//button tracking here
</script>

<script>
console.log('üîß Loading VIEW CONE and VIEWER functions...');
// ===== VIEW CONE SYSTEM =====
function initConeSystem(){
  if (!map.getSource('view-cone')){
    map.addSource('view-cone', {
      type:'geojson',
      data:{ type:'Feature', geometry:{ type:'Polygon', coordinates:[[[0,0],[0,0],[0,0]]] } }
    });
    map.addLayer({
      id:'view-cone-fill',
      type:'fill',
      source:'view-cone',
      paint:{ 'fill-color':CONFIG.colors.primary, 'fill-opacity':0.5 }
    });
    map.addLayer({
      id:'view-cone-outline',
      type:'line',
      source:'view-cone',
      paint:{ 'line-color':CONFIG.colors.primaryLight, 'line-width':2, 'line-opacity':0 }
    });
  }
}
console.log('‚úÖ initConeSystem defined');

function hideViewCone(){
  if (map && map.getSource('view-cone')){
    map.getSource('view-cone').setData({
      type:'Feature',
      geometry:{ type:'Polygon', coordinates:[[[0,0],[0,0],[0,0]]] }
    });
  }
}

function getHorizontalFovDeg(){
  const c=document.getElementById('canvas');
  const aspect = (camera && camera.aspect) || (c && c.clientHeight ? c.clientWidth/c.clientHeight : 16/9);
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad/2)*aspect);
  return THREE.MathUtils.radToDeg(hRad);
}

function updateViewCone() {
  if (!map || !map.getSource('view-cone')) return;

  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) return;

  const marble = track.marbles.find(m => m.id === selectedMarbleId);
  if (!marble) return;

  const currentIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);

  // 1. GET PATH DIRECTION (base bearing)
  let pathBearing = track._lastPathBearing || 0; // keep last good direction as fallback

  if (currentIndex < track.marbles.length - 1) {
    const nextMarble = track.marbles[currentIndex + 1];
    const dx = nextMarble.position[0] - marble.position[0];
    const dy = nextMarble.position[1] - marble.position[1];
    pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
  } else if (currentIndex > 0) {
    const prevMarble = track.marbles[currentIndex - 1];
    const dx = marble.position[0] - prevMarble.position[0]; // invert vector so it still points forward
    const dy = marble.position[1] - prevMarble.position[1];
    pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
  }

  // smooth continuity near endpoints (avoid 180¬∞ flip)
  if (track._lastPathBearing !== undefined) {
    const diff = pathBearing - track._lastPathBearing;
    if (Math.abs(diff) > 180) {
      // wrap around direction instead of flipping
      pathBearing += diff > 0 ? -360 : 360;
    }
  }
  track._lastPathBearing = pathBearing;

  // 2. GET USER OFFSET (convert yaw to degrees and apply to path)
  const userYawDeg = THREE.MathUtils.radToDeg(currentYaw);
  const finalHeading = (pathBearing + userYawDeg + 360) % 360;

  const fovH = getHorizontalFovDeg();
  const radiusMeters = 15;

  const ring = makeViewConeRing(
    marble.position[1],
    marble.position[0],
    finalHeading,
    fovH,
    radiusMeters,
    24
  );

  map.getSource('view-cone').setData({
    type: 'Feature',
    geometry: { type: 'Polygon', coordinates: [ring] }
  });
}

function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters=7, steps=24){
  const half = Math.max(0, Math.min(89, fovDeg/2));
  const start = headingDeg - half, end = headingDeg + half;
  const ring = [[lon,lat]];
  for (let s=0;s<=steps;s++){
    const t=s/steps, brg=start + (end-start)*t;
    ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
  }
  ring.push([lon,lat]);
  return ring;
}

// ===== 360 VIEWER AND MAP INTERACTION FUNCTIONS =====
// These functions MUST be defined before map initialization calls them
function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b[1]-a[1])*Math.PI/180;
  const dLon = (b[0]-a[0])*Math.PI/180;
  const lat1 = a[1]*Math.PI/180, lat2 = b[1]*Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
}

function bearingDeg(a, b){
  const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
  const œÜ1 = toRad(a[1]), œÜ2 = toRad(b[1]);
  const Œª1 = toRad(a[0]), Œª2 = toRad(b[0]);
  const y = Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
  const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}

function angularDiffDeg(a,b){ 
  let d=Math.abs(a-b)%360; 
  return d>180?360-d:d; 
}

function findClosestPointOnSegment(P, A, B){
  const Ax=A[0], Ay=A[1], Bx=B[0], By=B[1], Px=P[0], Py=P[1];
  const ABx=Bx-Ax, ABy=By-Ay, APx=Px-Ax, APy=Py-Ay;
  const ab2 = ABx*ABx + ABy*ABy;
  let t = ab2 ? (APx*ABx + APy*ABy)/ab2 : 0;
  t = Math.max(0, Math.min(1, t));
  const Qx = Ax + ABx*t, Qy = Ay + ABy*t;
  return { point:[Qx,Qy], distance: Math.sqrt(ab2)*t };
}

function findClosestPointOnRoute(point, coordinates){
  let closestPoint=null, minDistance=Infinity, accumulatedDistance=0;
  for (let i=1;i<coordinates.length;i++){
    const A=coordinates[i-1], B=coordinates[i];
    const segLen = calculateDistance(A,B);
    const cps = findClosestPointOnSegment(point, A, B);
    const d = calculateDistance(point, cps.point);
    if (d<minDistance){ minDistance=d; closestPoint={ point: cps.point, distance: accumulatedDistance + cps.distance }; }
    accumulatedDistance += segLen;
  }
  return closestPoint;
}

function destFromBearingDistance(lat, lon, bearingDegVal, distMeters){
  const R=6378137, brng=degToRad(bearingDegVal);
  const œÜ1=degToRad(lat), Œª1=degToRad(lon);
  const œÜ2=Math.asin(Math.sin(œÜ1)*Math.cos(distMeters/R)+Math.cos(œÜ1)*Math.sin(distMeters/R)*Math.cos(brng));
  const Œª2=Œª1+Math.atan2(Math.sin(brng)*Math.sin(distMeters/R)*Math.cos(œÜ1), Math.cos(distMeters/R)-Math.sin(œÜ1)*Math.sin(œÜ2));
  return [radToDeg(Œª2), radToDeg(œÜ2)];
}

function radToDeg(r){ return r*180/Math.PI; }
function degToRad(d){ return d*Math.PI/180; }

// ===== 360 VIEWER INITIALIZATION =====
function initializeViewer() {
  console.log('360 Viewer system ready');
  setupViewerEventListeners();
  loadGPXFromManifest();
}

function initThreeJSViewer() {
  if (viewerInitialized) return;
  
  console.log('üîÑ Initializing Three.js viewer...');
  
  const viewerContainer = document.getElementById('viewer-container');
  const canvas = document.getElementById('canvas');
  
  if (!viewerContainer || !canvas) {
    console.error('‚ùå Viewer container or canvas not found');
    return;
  }

  // Get dimensions with fallbacks
  let width = viewerContainer.clientWidth || canvas.clientWidth || 800;
  let height = viewerContainer.clientHeight || canvas.clientHeight || 600;
  
  
  // Set canvas dimensions
  canvas.width = width;
  canvas.height = height;
  
  scene = new THREE.Scene();
  panoGroup = new THREE.Group();
  scene.add(panoGroup);

  camera = new THREE.PerspectiveCamera(
    currentFov, 
    width / height, 
    0.1, 
    1000
  );
  camera.position.set(0, 0, 0.1);

  renderer = new THREE.WebGLRenderer({
    canvas, 
    antialias: true, 
    alpha: false, 
    powerPreference: 'high-performance'
  });
  
const dpr = Math.min(window.devicePixelRatio, 2);
  renderer.setPixelRatio(dpr);
  renderer.setSize(width, height, false);
  
  console.log('‚úÖ Three.js initialized successfully');

  viewerInitialized = true;
  
  // Start animation loop
  animateViewer();
}

function animateViewer(){
  if (!viewerInitialized) return;
  requestAnimationFrame(animateViewer);
  updateNavigationRing();
  if (renderer && scene && camera) {
    try {
      renderer.render(scene, camera);
    } catch(e) {}
  }
}

function setupViewerEventListeners(){
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  let isDragging=false, lastX=0, lastY=0;
  let touchStartX = 0, touchStartY = 0;
  let initialDistance = 0;

  // Mouse events
  canvas.addEventListener('mousedown', e=>{
    isDragging=true; lastX=e.clientX; lastY=e.clientY; 
    canvas.style.cursor='grabbing';
    document.body.classList.add('dragging-pano');
  });
  
  canvas.addEventListener('mousemove', e=>{
    if (!isDragging || !sphere) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    
    sphere.rotation.y -= dx*0.01;
    sphere.rotation.x -= dy*0.01;
    
    currentYaw = sphere.rotation.y; 
    currentPitch = sphere.rotation.x;
    
    lastX=e.clientX; lastY=e.clientY;
    updateNavigationRing();
    updateViewCone();
  });

  canvas.addEventListener('mouseup', ()=>{
    isDragging=false; 
    setTimeout(()=>{ canvas.style.cursor='grab'; }, 50);
    document.body.classList.remove('dragging-pano');
  });

  canvas.addEventListener('mouseenter', ()=>{ canvas.style.cursor='grab'; });
  canvas.addEventListener('mouseleave', ()=>{ isDragging=false; canvas.style.cursor='default'; });

  canvas.addEventListener('wheel', handleWheelZoom, { passive:false });

  // Touch events
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent double-tap zoom
    if (e.touches.length == 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
    if (e.touches.length == 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initialDistance = Math.sqrt(dx * dx + dy * dy);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); // Prevent pull-to-refresh and scroll
    if (e.touches.length == 1 && sphere) {
      const dx = e.touches[0].clientX - touchStartX;
      const dy = e.touches[0].clientY - touchStartY;

      sphere.rotation.y -= dx * 0.01;
      sphere.rotation.x -= dy * 0.01;

      currentYaw = sphere.rotation.y;
      currentPitch = sphere.rotation.x;

      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;

      updateNavigationRing();
      updateViewCone();
    }

    if (e.touches.length == 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);

      if (initialDistance > 0) {
        const zoomChange = initialDistance - currentDistance;
        const zoomSpeed = 2;
        currentFov = Math.max(30, Math.min(120, currentFov + zoomChange * zoomSpeed * 0.1));
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        initialDistance = currentDistance;
        updateViewCone();
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault(); // Prevent double-tap zoom
    // If we still have one finger remaining after lifting, update touchStart
    // to prevent jumpy rotation (fixes upside-down flip on pinch release)
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    } else {
      touchStartX = 0;
      touchStartY = 0;
    }
    initialDistance = 0;
  }, { passive: false });
}

function handleWheelZoom(e){
  e.preventDefault(); 
  e.stopPropagation();
  const zoomSpeed = e.deltaMode===0 ? 2 : 60;
  const delta = e.deltaY>0 ? zoomSpeed : -zoomSpeed;
  const old = currentFov;
  currentFov = Math.max(30, Math.min(120, currentFov + delta));
  if (currentFov !== old){
    camera.fov = currentFov; 
    camera.updateProjectionMatrix();
    updateViewCone(); 
    if (renderer) renderer.render(scene, camera);
  }
}

// ===== NAVIGATION CONTROLS =====
function updateNavigationRing(instant = false) {
  const ring = document.querySelector('.navigation-ring');
  const nextBtn = document.getElementById('nextImageBtn');
  const prevBtn = document.getElementById('prevImageBtn');
  const branchBtn = document.getElementById('branchImageBtn');
  if (!ring || !sphere) return;

  const yawDegrees = THREE.MathUtils.radToDeg(currentYaw);
  ring.style.transform = `rotateZ(${-yawDegrees}deg)`;

  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) return;

  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  const total = track.marbles.length;

  // Detect position in track (including anti-marriage blocks)
  const isFirst = marbleIndex === 0;
  const isLast = marbleIndex === total - 1;
  const nextBlocked = !isLast && areAntiMarried(selectedMarbleId, track.marbles[marbleIndex + 1]?.id);
  const prevBlocked = !isFirst && areAntiMarried(selectedMarbleId, track.marbles[marbleIndex - 1]?.id);
  const canForward = !isLast && !nextBlocked;
  const canBackward = !isFirst && !prevBlocked;

  // Branch only available if marble has married partners
  const canBranch = hasMarriedPartners(selectedMarbleId);

  // Clear all branch position classes
  ring.classList.remove('branch-left', 'branch-right', 'branch-top', 'branch-bottom');

  // Determine branch button position
  if (canBranch) {
    if (isFirst && !canBackward) {
      // At first marble, no previous button - branch takes 6 o'clock
      ring.classList.add('branch-bottom');
    } else if (isLast && !canForward) {
      // At last marble, no next button - branch takes 12 o'clock
      ring.classList.add('branch-top');
    } else {
      // Middle marble - calculate if branch should be left or right
      const branchPosition = calculateBranchPosition();
      if (branchPosition === 'left') {
        ring.classList.add('branch-left');
      } else {
        // Default to right (3 o'clock)
        ring.classList.add('branch-right');
      }
    }
  }

  // Show/hide buttons based on availability
  nextBtn.style.opacity = canForward ? 1 : 0;
  nextBtn.style.pointerEvents = canForward ? 'auto' : 'none';

  prevBtn.style.opacity = canBackward ? 1 : 0;
  prevBtn.style.pointerEvents = canBackward ? 'auto' : 'none';

  branchBtn.style.opacity = canBranch ? 1 : 0;
  branchBtn.style.pointerEvents = canBranch ? 'auto' : 'none';

  // Update titles
  nextBtn.title = canForward ? 'Move forward' : 'No next marble';
  prevBtn.title = canBackward ? 'Move backward' : 'No previous marble';
  branchBtn.title = canBranch ? 'Branch to married partner' : 'No branch available';

  if (instant) {
    ring.style.transition = 'none';
    requestAnimationFrame(() => (ring.style.transition = ''));
  }
}

// Calculate if branch button should be on left or right based on married marble position
function calculateBranchPosition() {
  if (!selectedMarbleId) return 'right';

  const marriedPartners = getMarriedPartners(selectedMarbleId);
  if (marriedPartners.length === 0) return 'right';

  const track = getCurrentTrack();
  if (!track) return 'right';

  const currentMarble = track.marbles.find(m => m.id === selectedMarbleId);
  if (!currentMarble) return 'right';

  // Get first married partner's position
  const partner = marriedPartners[0];
  const partnerMarble = partner.marble;

  // Calculate bearing from current marble to partner marble
  const dx = partnerMarble.position[0] - currentMarble.position[0];
  const dy = partnerMarble.position[1] - currentMarble.position[1];
  const bearingToPartner = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;

  // Get path bearing (direction cone is facing)
  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  let pathBearing = 0;

  if (marbleIndex < track.marbles.length - 1) {
    const nextMarble = track.marbles[marbleIndex + 1];
    const dx2 = nextMarble.position[0] - currentMarble.position[0];
    const dy2 = nextMarble.position[1] - currentMarble.position[1];
    pathBearing = (Math.atan2(dx2, dy2) * 180 / Math.PI + 360) % 360;
  } else if (marbleIndex > 0) {
    const prevMarble = track.marbles[marbleIndex - 1];
    const dx2 = currentMarble.position[0] - prevMarble.position[0];
    const dy2 = currentMarble.position[1] - prevMarble.position[1];
    pathBearing = (Math.atan2(dx2, dy2) * 180 / Math.PI + 360) % 360;
  }

  // Calculate relative angle: positive = partner is to the right, negative = to the left
  let relativeAngle = bearingToPartner - pathBearing;

  // Normalize to -180 to 180
  while (relativeAngle > 180) relativeAngle -= 360;
  while (relativeAngle < -180) relativeAngle += 360;

  // If partner is to the left (negative angle), place button on left (9 o'clock)
  // If partner is to the right (positive angle), place button on right (3 o'clock)
  return relativeAngle < 0 ? 'left' : 'right';
}

// ===== GPX LOADING AND MARBLE MANAGEMENT =====
async function loadGPXFromManifest() {
  try {
    // Collect all unique framesBase URLs from communities
    const framesBaseUrls = new Set();
    Object.values(CONFIG.communities).forEach(c => {
      if (c.framesBase) framesBaseUrls.add(c.framesBase);
    });
    // Also add the global fallback in case it's not in any community
    if (CONFIG.data.framesBase) framesBaseUrls.add(CONFIG.data.framesBase);

    window.yawFixesByFile = {};
    let loadedCount = 0;

    for (const framesBase of framesBaseUrls) {
      try {
        const res = await fetch(framesBase + 'index.json', { cache: 'no-store' });
        if (!res.ok) {
          console.log('No manifest at:', framesBase);
          continue;
        }

        const manifest = await res.json();

        // Merge yawfix mappings
        if (manifest.yawfixes) {
          Object.assign(window.yawFixesByFile, manifest.yawfixes);
          console.log("Yaw fixes loaded from:", framesBase);
        }

        // Merge marriages if present
        if (manifest.marriages && Array.isArray(manifest.marriages)) {
          marriageGroups = marriageGroups.concat(manifest.marriages);
          console.log("Marriages loaded from:", framesBase);
        }

        // Merge anti-marriages if present
        if (manifest.antiMarriages && Array.isArray(manifest.antiMarriages)) {
          antiMarriageGroups = antiMarriageGroups.concat(manifest.antiMarriages);
          console.log("Anti-marriages loaded from:", framesBase);
        }

        // Get GPX files from manifest
        let gpxFiles = [];
        if (manifest.gpxFiles && manifest.gpxFiles.length) gpxFiles = manifest.gpxFiles;
        else if (manifest.files) gpxFiles = manifest.files.filter(f => f.toLowerCase().endsWith('.gpx'));

        for (const gpxFile of gpxFiles) {
          try {
            await loadSingleGPX(gpxFile, framesBase);
            loadedCount++;
          } catch(e) {
            console.error('Failed GPX:', gpxFile, e);
          }
        }
      } catch(e) {
        console.log('No manifest or error at:', framesBase, e.message);
      }
    }

    if (loadedCount > 0 && allTracks.size > 0) {
      const firstTrackId = Array.from(allTracks.keys())[0];
      selectTrack(firstTrackId);
      console.log(`Loaded ${loadedCount} GPX files from ${framesBaseUrls.size} sources`);

      // Preload images for married marbles after tracks are loaded
      if (marriageGroups.length > 0) {
        setTimeout(() => preloadMarriedMarbleImages(), 500);
      }
    }

  } catch(e) {
    console.error('Error loading manifests:', e);
  }
}

async function loadSingleGPX(filename, framesBaseOverride) {
  const framesBase = framesBaseOverride || getFramesBase();
  const fullPath = filename.startsWith('http') ? filename : framesBase + filename;
  const response = await fetch(fullPath);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);

  const baseName = filename.split('/').pop();
  const yawFixDeg = window.yawFixesByFile?.[baseName] ?? 0;
  console.log(`Applying yaw fix ${yawFixDeg}¬∞ to ${baseName}`);

  const gpxContent = await response.text();
  parseGPX(gpxContent, baseName, true, yawFixDeg, framesBase);
}

function parseGPX(gpxContent, fileName, isPredefined=false, yawFixDeg=0, framesBase='') {
  const parser = new DOMParser();
  const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');

  const trkpts = gpxDoc.querySelectorAll('trkpt');
  const pointsWithTime = [];
  trkpts.forEach((trkpt, idx) => {
    const lat = parseFloat(trkpt.getAttribute('lat'));
    const lon = parseFloat(trkpt.getAttribute('lon'));
    const t = trkpt.querySelector('time');
    pointsWithTime.push({
      id: idx,
      coordinates: [lon, lat],
      originalIndex: idx,
      time: t ? t.textContent : null
    });
  });
  if (!pointsWithTime.length) return;

  const trackId = `track-${allTracks.size + 1}`;
  const trackColor = CONFIG.colors.info;

  const trackData = {
    id: trackId,
    name: fileName.replace('.gpx',''),
    color: trackColor,
    yawFixDeg: yawFixDeg,
    originalPoints: pointsWithTime,
    activePoints: pointsWithTime.map(p => ({...p})),
    isActive: false,
    isPredefined,
    originalStats: calculateOriginalStatsFromPoints(pointsWithTime),
    marbles: [],
    marbleSpacing: 10,
    framesBase: framesBase
  };

  parseWaypointsFromGPX(gpxDoc, trackData);

  allTracks.set(trackId, trackData);

  updateMarbleDisplay();
  console.log(`Parsed ${fileName} with ${trackData.marbles.length} marbles`);
}

function parseWaypointsFromGPX(gpxDoc, trackData) {
  const waypoints = gpxDoc.querySelectorAll('wpt');
  const coordinates = getDisplayCoordinates(trackData);
  const totalDistance = calculateTotalDistance(coordinates);

  waypoints.forEach((wpt, index) => {
    const lat = parseFloat(wpt.getAttribute('lat'));
    const lon = parseFloat(wpt.getAttribute('lon'));
    const nameEl = wpt.querySelector('name');
    const descEl = wpt.querySelector('desc');
    const timeEl = wpt.querySelector('time');

    const name = nameEl ? nameEl.textContent : `Waypoint_${index+1}`;
    const description = descEl ? descEl.textContent : '';
    const time = timeEl ? timeEl.textContent : null;

    const marble = {
      id: Date.now() + index + Math.random(),
      index: trackData.marbles.length,
      position: [lon, lat],
      distanceAlongRoute: 0,
      isLocked: false,
      isFixed: false,
      assignedImage: extractImageIndexFromWaypoint(name, description),
      isWaypoint: true,
      originalName: name,
      description,
      time
    };

    const closestPoint = findClosestPointOnRoute([lon, lat], coordinates);
    if (closestPoint) marble.distanceAlongRoute = closestPoint.distance;

    trackData.marbles.push(marble);
  });

  trackData.marbles.sort((a,b)=>a.distanceAlongRoute - b.distanceAlongRoute);
  trackData.marbles.forEach((m,i)=>{ m.index = i; });
}

function getDisplayCoordinates(track) {
  return track.activePoints.map(p => p.coordinates);
}

function calculateTotalDistance(points) {
  if (points.length < 2) return 0;
  let sum = 0;
  for (let i=1;i<points.length;i++) sum += calculateDistance(points[i-1], points[i]);
  return sum;
}

function calculateOriginalStatsFromPoints(points){
  const coords = points.map(p=>p.coordinates);
  const timeData = points.map(p=>p.time).filter(Boolean);
  const distance = calculateTotalDistance(coords);
  const duration = calculateDurationFromTimes(timeData);
  const avgSpeed = calculateAverageSpeedFromStats(distance, duration);
  return { distance, duration, avgSpeed, pointCount: points.length };
}

function calculateDurationFromTimes(timeData){
  if (timeData.length < 2) return '0s';
  const start = new Date(timeData[0]), end = new Date(timeData[timeData.length-1]);
  const ms = end - start;
  const h = Math.floor(ms/3600000), m = Math.floor((ms%3600000)/60000), s = Math.floor((ms%60000)/1000);
  if (h>0) return `${h}h ${m}m ${s}s`;
  if (m>0) return `${m}m ${s}s`;
  return `${s}s`;
}

function calculateAverageSpeedFromStats(distanceMeters, durationString){
  if (durationString==='0s' || !distanceMeters) return 0;
  const hMatch = durationString.match(/(\d+)h/), mMatch = durationString.match(/(\d+)m/), sMatch = durationString.match(/(\d+)s/);
  const hours = (hMatch?+hMatch[1]:0) + (mMatch?+mMatch[1]/60:0) + (sMatch?+sMatch[1]/3600:0);
  const km = distanceMeters/1000;
  return hours>0 ? km/hours : 0;
}

function extractImageIndexFromWaypoint(name, description){
  const text = (name + ' ' + description).toLowerCase();
  const m1 = text.match(/image[^\d]*(\d+)/); if (m1) return parseInt(m1[1])-1;
  const m2 = text.match(/photo[^\d]*(\d+)/); if (m2) return parseInt(m2[1])-1;
  const m3 = name?.match(/(\d+)$/); if (m3) return parseInt(m3[1])-1;
  return null;
}

// ===== TRACK AND MARBLE SELECTION =====
async function selectTrack(trackId){
  if (currentTrackId && allTracks.has(currentTrackId)) {
    allTracks.get(currentTrackId).isActive = false;
  }

  currentTrackId = trackId;
  const track = allTracks.get(trackId);
  track.isActive = true;

  updateMarbleDisplay();
  await load360Images();
  console.log(`Selected track: ${track.name}`);
}

async function selectTrackWithoutMapReset(trackId){
  if (currentTrackId && allTracks.has(currentTrackId)) {
    allTracks.get(currentTrackId).isActive = false;
  }

  currentTrackId = trackId;
  const track = allTracks.get(trackId);
  track.isActive = true;

  resetViewerOrientationForTrack(track);
  updateMarbleDisplay();

  if (viewConeMarker){
    viewConeMarker.remove();
    viewConeMarker = null;
  }

  updateNavigationRing(true);
  updateViewCone();
  await load360Images();

  console.log(`Switched to track: ${track.name} - ${track.marbles.length} marbles`);
}

function resetViewerOrientationForTrack(track) {
  if (!track || !panoGroup) return;
  
  currentYaw = 0;
  currentPitch = 0;
  
  if (panoGroup) {
    panoGroup.rotation.y = currentYaw;
    panoGroup.rotation.x = currentPitch;
  }
  
  lastHopBearingDeg = null;
  console.log(`Orientation reset for track: ${track.name}`);
}

function getCurrentTrack(){ 
  return currentTrackId ? allTracks.get(currentTrackId) : null; 
}

function selectMarble(marbleId){
  const prevSelected = selectedMarbleId;
  selectedMarbleId = marbleId;

  const track = getCurrentTrack();
  if (!track) return;

// Update last hop bearing for navigation (only when actually switching marbles)
  if (prevSelected && prevSelected !== marbleId){
    const prev = track.marbles.find(m=>m.id===prevSelected);
    const curr = track.marbles.find(m=>m.id===marbleId);
    if (prev && curr) {
      lastHopBearingDeg = bearingDeg(prev.position, curr.position);
    }
  }

  updateMarbleDisplay();
  updateViewCone();
  console.log(`Selected marble: ${marbleId}`);
}

function deselectMarble(){
  selectedMarbleId = null;
  updateMarbleDisplay();
  hideViewCone();
}

// ===== MARRIAGE SYSTEM =====

// Get marble identifier string (gpxName:marbleIndex)
function getMarbleIdentifier(marbleId) {
  for (const [trackId, track] of allTracks) {
    const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
    if (marbleIndex !== -1) {
      const gpxName = track.name.endsWith('.gpx') ? track.name : `${track.name}.gpx`;
      return `${gpxName}:${marbleIndex + 1}`;
    }
  }
  return null;
}

// Find marble by identifier string (indices are 1-based in index.json)
function findMarbleByIdentifier(identifier) {
  const [gpxName, indexStr] = identifier.split(':');
  const index = parseInt(indexStr) - 1;

  for (const [trackId, track] of allTracks) {
    const trackName = track.name.replace(/\.gpx$/i, '');
    const searchName = gpxName.replace(/\.gpx$/i, '');

    if (trackName === searchName && track.marbles[index]) {
      return { marble: track.marbles[index], track, trackId };
    }
  }
  return null;
}

// Get married partners for a marble
function getMarriedPartners(marbleId) {
  const identifier = getMarbleIdentifier(marbleId);
  if (!identifier) return [];

  for (const group of marriageGroups) {
    if (group.includes(identifier)) {
      // Return all other marbles in this group
      return group.filter(id => id !== identifier).map(id => {
        const result = findMarbleByIdentifier(id);
        return result ? { ...result, identifier: id } : null;
      }).filter(Boolean);
    }
  }
  return [];
}

// Check if marble has married partners
function hasMarriedPartners(marbleId) {
  return getMarriedPartners(marbleId).length > 0;
}

// Check if two marbles are anti-married (navigation blocked between them)
function areAntiMarried(marbleId1, marbleId2) {
  if (!marbleId1 || !marbleId2) return false;
  const id1 = getMarbleIdentifier(marbleId1);
  const id2 = getMarbleIdentifier(marbleId2);
  if (!id1 || !id2) return false;
  for (const group of antiMarriageGroups) {
    if ((group.includes(id1) && group.includes(id2))) return true;
  }
  return false;
}

// Preload images for all married marbles
function preloadMarriedMarbleImages() {
  const imagesToPreload = new Set();

  for (const group of marriageGroups) {
    for (const identifier of group) {
      const result = findMarbleByIdentifier(identifier);
      if (result && result.marble.assignedImage !== null) {
        // Find the image URL for this marble
        const trackName = result.track.name.replace(/\.gpx$/i, '');
        const imageIndex = result.marble.assignedImage;
        const imageUrl = `${getFramesBase()}${trackName}-${imageIndex + 1}.jpg`;
        imagesToPreload.add(imageUrl);
      }
    }
  }

  console.log(`Preloading ${imagesToPreload.size} married marble images`);

  // Preload each image
  for (const url of imagesToPreload) {
    if (!preloadedImages[url]) {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.onload = () => {
        preloadedImages[url] = img;
        console.log('Preloaded married marble image:', url);
      };
      img.onerror = () => console.log('Failed to preload:', url);
      img.src = url;
    }
  }
}

// Branch button main handler - jump to married partner
document.getElementById('branchImageBtn').addEventListener('click', async () => {
  if (!selectedMarbleId) return;

  // Only jump to married partners
  const marriedPartners = getMarriedPartners(selectedMarbleId);

  if (marriedPartners.length === 0) {
    console.log('No married partner available');
    return;
  }

  // Get old marble position for map panning
  const track = getCurrentTrack();
  const oldMarble = track?.marbles.find(m => m.id === selectedMarbleId);
  const oldPos = oldMarble?.position;

  // Jump to first married partner
  const target = marriedPartners[0];
  const targetTrack = target.track;
  const targetMarble = target.marble;

  if (targetTrack.id !== currentTrackId) {
    selectTrackWithoutMapReset(targetTrack.id);
    await new Promise(r => setTimeout(r, 100));
  }
  selectMarble(targetMarble.id);
  if (targetMarble.assignedImage != null) showMarbleImage(targetMarble.id);

  // Pan map to follow marble
  panMapToFollowMarble(oldPos, targetMarble.position);

  console.log(`Jumped to married partner on ${targetTrack.name}`);
});

// ===== MARBLE VISUALIZATION =====
function updateMarbleDisplay(){
  const src = map.getSource('marbles');
  if (!src) return;

  const all = [];
  allTracks.forEach((track, trackId)=>{
    track.marbles.forEach((m, index)=>{
      const hasImage = m.assignedImage !== null;
      all.push({
        type:'Feature',
        geometry:{ type:'Point', coordinates: m.position },
        properties:{
          id: m.id,
          trackId,
          index,
          isSelected: (m.id === selectedMarbleId),
          hasImage
        }
      });
    });
  });

  src.setData({ type:'FeatureCollection', features: all });
}

// ===== MAP INTERACTIONS FOR MARBLES =====
function setupMapInteractions(){
  map.on('move', ()=> { if (selectedMarbleId) updateViewCone(); });
  map.on('zoom', ()=> { if (selectedMarbleId) updateViewCone(); });
  
  // üü¢ ADD MARBLE CLICK HANDLERS
  enableMarbleClickOnly();
}

function enableMarbleClickOnly(){
  // Remove existing handlers to avoid duplicates
  map.off('click','marbles-click-layer',handleMarbleClick);
  map.off('click', handleMapClickForDeselect);

  // Add new handlers
  map.on('click','marbles-click-layer', handleMarbleClick);
  map.on('click', handleMapClickForDeselect);
}

function handleMarbleClick(e){
  // üü¢ STOP EVENT PROPAGATION - PREVENT MODAL FROM CLOSING
  e.originalEvent.stopPropagation();
  
  if (!e.features?.length) { 
    deselectMarble(); 
    return; 
  }
  const marbleId = e.features[0].properties.id;
  const trackId = e.features[0].properties.trackId;

  if (trackId !== currentTrackId) {
    selectTrackAndThenMarble(trackId, marbleId);
  } else {
    selectMarble(marbleId);
    showMarbleImage(marbleId);
  }
}

function handleMapClickForDeselect(e){
  const f = map.queryRenderedFeatures(e.point, { layers:['marbles-click-layer'] });
  if (!f.length) deselectMarble();
}


// ===== IMAGE LOADING AND DISPLAY =====
function showImageInViewer(imageUrl, imageData) {
  console.log('üñºÔ∏è Loading image:', imageUrl);
  showViewerLoading('Loading 360¬∞ image...');

  // üü¢ REMOVED: Don't initialize Three.js here anymore
  // if (!viewerInitialized) initThreeJSViewer();

  if (preloadedImages[imageUrl]) {
    console.log('‚úÖ Using preloaded image');
    hideViewerLoading();
    applyImageToSphere(preloadedImages[imageUrl], imageData);
    preloadAdjacentImages();
    return;
  }

  const img = new Image();
  img.crossOrigin = 'Anonymous';
  
  img.onload = function() {
    console.log('‚úÖ Image loaded successfully:', imageUrl);
    preloadedImages[imageUrl] = img;
    hideViewerLoading();
    applyImageToSphere(img, imageData);
    preloadAdjacentImages();
  };
  
  img.onerror = function() {
    console.error('‚ùå Failed to load image:', imageUrl);
    hideViewerLoading();
    showToaster('Failed to load 360 image');
  };
  
  console.log('üì§ Setting image src:', imageUrl);
  img.src = imageUrl + (imageUrl.includes('?')?'&':'?') + 't=' + Date.now();
}

function applyImageToSphere(img, imageData) {
 
  if (sphere) {
    panoGroup.remove(sphere);
    sphere.geometry?.dispose();
    if (sphere.material) {
      sphere.material.map?.dispose();
      sphere.material.dispose();
    }
  }

  const geometry = new THREE.SphereGeometry(500, 60, 40);
  geometry.scale(-1, 1, 1);
  geometry.rotateY(Math.PI);

  // Apply per-track yaw correction
  const track = getCurrentTrack();
  if (track && track.yawFixDeg) {
    geometry.rotateY(THREE.MathUtils.degToRad(track.yawFixDeg));
  }

  const texture = new THREE.Texture(img);
  texture.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({ map: texture });
  sphere = new THREE.Mesh(geometry, material);
  
  // Apply the current orientation to the sphere
  sphere.rotation.y = currentYaw;
  sphere.rotation.x = currentPitch;
  
  panoGroup.add(sphere);

  updateNavigationRing(true);
}

function preloadAdjacentImages() {
  // Preload adjacent marble images (not sequential array indices)
  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) return;
  const marbleIdx = track.marbles.findIndex(m => m.id === selectedMarbleId);
  const neighbors = [marbleIdx - 1, marbleIdx + 1];
  for (const ni of neighbors) {
    if (ni >= 0 && ni < track.marbles.length) {
      const m = track.marbles[ni];
      if (m.assignedImage !== null && m.assignedImage !== undefined) {
        const arrIdx = imageNumberToArrayIndex.hasOwnProperty(m.assignedImage) ? imageNumberToArrayIndex[m.assignedImage] : m.assignedImage;
        if (arrIdx >= 0 && arrIdx < currentImages.length && !preloadedImages[currentImages[arrIdx].url]) {
          preloadOne(arrIdx);
        }
      }
    }
  }
}

function preloadOne(index) {
  return new Promise(res => {
    const item = currentImages[index]; 
    if (!item) return res();
    const src = item.url; 
    if (preloadedImages[src]) return res();
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => { preloadedImages[src] = img; res(); };
    img.onerror = () => res();
    img.src = src;
    if (img.decode) img.decode().catch(() => {});
  });
}

// Pan map to follow marble navigation (relative pan by delta between positions)
function panMapToFollowMarble(oldPos, newPos) {
  if (!oldPos || !newPos) return;
  const center = map.getCenter();
  const deltaLng = newPos[0] - oldPos[0];
  const deltaLat = newPos[1] - oldPos[1];
  map.easeTo({
    center: [center.lng + deltaLng, center.lat + deltaLat],
    duration: 500,
    easing: t => 1 - Math.pow(1 - t, 3) // ease-out cubic
  });
}

// Get marble position by image index
function getMarblePositionByImageIndex(imageIndex) {
  const track = getCurrentTrack();
  if (!track) return null;
  const marble = track.marbles.find(m => m.assignedImage === imageIndex);
  return marble ? marble.position : null;
}

function nextImage() {
  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) { updateViewerUI(); return; }
  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  if (marbleIndex < 0 || marbleIndex >= track.marbles.length - 1) { updateViewerUI(); return; }
  const nextMarble = track.marbles[marbleIndex + 1];
  if (areAntiMarried(selectedMarbleId, nextMarble.id)) { updateViewerUI(); return; }
  if (nextMarble.assignedImage !== null && nextMarble.assignedImage !== undefined) {
    const oldPos = getMarblePositionByImageIndex(currentImageIndex);
    selectMarble(nextMarble.id);
    showImageByIndex(nextMarble.assignedImage);
    updateNavigationRing(true);
    const newPos = nextMarble.position;
    panMapToFollowMarble(oldPos, newPos);
  }
  updateViewerUI();
}

function previousImage() {
  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) { updateViewerUI(); return; }
  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  if (marbleIndex <= 0) { updateViewerUI(); return; }
  const prevMarble = track.marbles[marbleIndex - 1];
  if (areAntiMarried(selectedMarbleId, prevMarble.id)) { updateViewerUI(); return; }
  if (prevMarble.assignedImage !== null && prevMarble.assignedImage !== undefined) {
    const oldPos = getMarblePositionByImageIndex(currentImageIndex);
    selectMarble(prevMarble.id);
    showImageByIndex(prevMarble.assignedImage);
    updateNavigationRing(true);
    const newPos = prevMarble.position;
    panMapToFollowMarble(oldPos, newPos);
  }
  updateViewerUI();
}

function showImageByIndex(index) {
  // index = marble's assignedImage (original image number, may have gaps)
  // Use lookup map to find actual position in currentImages array
  const arrayIdx = imageNumberToArrayIndex.hasOwnProperty(index) ? imageNumberToArrayIndex[index] : index;
  if (arrayIdx < 0 || arrayIdx >= currentImages.length) return;
  const image = currentImages[arrayIdx];
  if (preloadedImages[image.url]) {
    applyImageToSphere(preloadedImages[image.url], image);
    currentImageIndex = index;
    updateViewerUI();
    highlightMarbleWithImage(index);
  } else {
    showImageInViewer(image.url, image);
    currentImageIndex = index;
    updateViewerUI();
    highlightMarbleWithImage(index);
  }
  preloadAdjacentImages();
}

function updateViewerUI() {
  const track = getCurrentTrack();
  const marbleIdx = track ? track.marbles.findIndex(m => m.id === selectedMarbleId) : -1;
  const total = track ? track.marbles.length : currentImages.length;
  const display = marbleIdx >= 0 ? marbleIdx + 1 : currentImageIndex + 1;
  document.getElementById('time').textContent = `${display}/${total}`;
  document.getElementById('viewer-info').textContent = `Image ${display}/${total}`;
}

// Set up navigation button event listeners
document.getElementById('nextImageBtn').addEventListener('click', nextImage);
document.getElementById('prevImageBtn').addEventListener('click', previousImage);
document.getElementById('nextImageBtnTop').addEventListener('click', nextImage);
document.getElementById('prevImageBtnTop').addEventListener('click', previousImage);

function highlightMarbleWithImage(imageIndex) {
  const track = getCurrentTrack(); 
  if (!track) return;
  const marble = track.marbles.find(m => m.assignedImage === imageIndex);
  if (marble) selectMarble(marble.id);
}

function showMarbleImage(marbleId) {
  const track = getCurrentTrack(); 
  if (!track) return;
  const m = track.marbles.find(x => x.id === marbleId); 
  if (!m) return;
  
  if (m.assignedImage == null) {
    console.log('‚ùå Marble has no assigned image:', m);
    showToaster(`Marble ${m.index+1} has no image`);
    return;
  }
  
  console.log('üñºÔ∏è Showing image for marble:', m);
  console.log('üñºÔ∏è Assigned image index:', m.assignedImage);
  
 open360ViewerInModal();

// Wait for Three.js to initialize before showing image
setTimeout(() => {
  showImageByIndex(m.assignedImage);
}, 300); // Wait for Three.js to initialize
}

// Loading overlay functions
function showViewerLoading(msg) {
  const l = document.getElementById('viewer-loading'), 
        t = document.getElementById('loading-text');
  if (l && t) { 
    t.textContent = msg; 
    l.style.display = 'block'; 
  }
}

function hideViewerLoading() { 
  const l = document.getElementById('viewer-loading'); 
  if (l) l.style.display = 'none'; 
}

// ===== IMAGE SOURCING =====
async function load360Images() {
  try {
    await createImagesFromFramesFolder();
    if (currentImages.length > 0) {

      startBackgroundPreload(3);
    }
  } catch(e) { 
    console.error(e);
    showToaster('Error loading 360 images');
  }
}
  
async function createImagesFromFramesFolder() {
  currentImages = []; 
  currentImageIndex = -1;
  const track = getCurrentTrack(); 
  if (!track) { 
    showToaster('No track selected'); 
    return; 
  }
  const gpxName = (track.name || '').replace(/\.[^.]+$/, '');
    if (!gpxName) {
    showToaster('GPX name missing');
    return;
  }
  // case-insensitive prefix match: "<gpx>-" or "<gpx>_"
  const gpxNameLC = gpxName.toLowerCase();
  const prefixHyphen = gpxNameLC + '-';
  const prefixUnderscore = gpxNameLC + '_';
  const framesBase = track.framesBase || getFramesBase();
  let list;
  try {
    const res = await fetch(framesBase + 'index.json', { cache: 'no-store' });
    if (!res.ok) {
      showToaster('Could not fetch frames index');
      return;
    }
    const data = await res.json();
    list = Array.isArray(data) ? data : Array.isArray(data.files) ? data.files : [];
  } catch(e) {
    showToaster('Error reading frames manifest');
    return;
  }
  const files = list.map(x => String(x).split('/').pop()).filter(Boolean);
  const matches = files
    .filter(n => {
      const nameLC = n.toLowerCase();
      return nameLC.startsWith(prefixHyphen) || nameLC.startsWith(prefixUnderscore);
    })
    .filter(n => /\.(?:jpe?g|png)$/i.test(n))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
  if (!matches.length) {
    showToaster(`No frames for "${gpxName}"`);
    return; 
  }

  currentImages = matches.map((filename, i) => ({
    url: framesBase + filename,
    index: i,
    filename,
    timestamp: filename,
    sequence: i
  }));

  // Build lookup: original image number (from filename) ‚Üí array position
  // e.g. "track-4.jpg" ‚Üí image number 3 (0-based) ‚Üí array position 2 (if track-3 was removed)
  imageNumberToArrayIndex = {};
  currentImages.forEach((img, i) => {
    const numMatch = img.filename.match(/[-_](\d+)\.[^.]+$/);
    if (numMatch) {
      const originalImageNumber = parseInt(numMatch[1]) - 1; // 1-based filename ‚Üí 0-based index
      imageNumberToArrayIndex[originalImageNumber] = i;
    }
  });
}

// Background preload
function startBackgroundPreload(concurrency = 3) {
  if (currentImages.length <= 1) return;
  const order = buildPreloadOrder(currentImageIndex, currentImages.length);
  runPreloadPool(order, concurrency);
}

function buildPreloadOrder(center, total) {
  const seq = []; 
  for (let step = 1; step < total; step++) { 
    const f = center + step, b = center - step; 
    if (f < total) seq.push(f); 
    if (b >= 0) seq.push(b); 
  }
  return seq;
}

function runPreloadPool(indexes, concurrency) {
  let i = 0;
  const workers = Array.from({length: Math.min(concurrency, indexes.length)}, async () => {
    while (i < indexes.length) { 
      const idx = indexes[i++]; 
      await preloadOne(idx).catch(() => {}); 
    }
  });
  Promise.all(workers).then(() => console.log('Background preload complete'));
}

// ===== MODAL INTEGRATION FUNCTIONS =====
function open360ViewerInModal() {
  const modal = document.getElementById('lotModal');
  const viewerContainer = document.getElementById('viewer-container');
  const contentWrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const modalInfo = document.getElementById('modalInfo');
  const calendlyEl = document.getElementById('calendlyEmbed');
  const backButton = document.getElementById('backButton');
  const headerFracc = document.getElementById('headerFracc');
  const headerLotNumber = document.getElementById('headerLotNumber');

  const plusButton = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');
  const customScrollbar = document.getElementById('customScrollbar');
  const customScrollthumb = document.getElementById('customScrollthumb');

  // Hide other modal content
  if (lotDetails) lotDetails.style.display = 'none';
  if (modalInfo) modalInfo.style.display = 'none';
  if (calendlyEl) calendlyEl.style.display = 'none';
  
  // Hide custom scrollbar and thumb
  if (customScrollbar) {
    customScrollbar.style.display = 'none';
    customScrollbar.style.visibility = 'hidden';
  }
  if (customScrollthumb) {
    customScrollthumb.style.display = 'none';
    customScrollthumb.style.visibility = 'hidden';
  }

  // Show viewer container
  if (viewerContainer) {
    viewerContainer.style.display = 'block';
  }

  // Update modal classes and state
  modal.classList.add('viewer-mode');
  modal.classList.remove('pin-mode', 'info-mode', 'lot-mode');
  
  // Update header
  if (headerFracc) headerFracc.textContent = 'STREET VIEW';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  
  // Hide back button and plus buttons
  if (backButton) backButton.style.display = 'none';
  if (plusButton) plusButton.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';

  // Ensure modal is open
  if (!modal.classList.contains('show')) {
    modal.classList.add('show');
    modal.style.display = 'block';
    adjustMapForModal();
  }

  // Update internal state
  isDetailOpen = true;
  
  // Hide floating buttons
  document.getElementById('searchBtnStage')?.classList.add('hide');
  document.getElementById('lalalandInfoBtn')?.classList.add('hide');

  console.log('360 Viewer opened in modal');
  
  // Wait for layout before initializing viewer
  requestAnimationFrame(() => {
    setTimeout(() => {
      if (!viewerInitialized || !renderer || !scene || !camera) {
        viewerInitialized = false;
        initThreeJSViewer();
      }
    }, 100);
  });
}

function close360ViewerInModal(targetBaseIndex = null) {
  const modal = document.getElementById('lotModal');
  const viewerContainer = document.getElementById('viewer-container');
  const wrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');
  const backButton = document.getElementById('backButton');
  const headerLotNumber = document.getElementById('headerLotNumber');
  const headerFracc = document.getElementById('headerFracc');
  const plusBtn = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');

  // Hide viewer
  if (viewerContainer) viewerContainer.style.display = 'none';

  // --- Copy working logic from closeModal ---
  
  // Remove all modal mode classes
  modal.classList.remove('info-mode', 'pin-mode', 'viewer-mode', 'expanded');
  modal.classList.add('lot-mode');

  window.isDetailOpen = false;

  // Reset panes (detail vs list) & content
  if (wrapper) wrapper.classList.remove('show-details');
  if (lotDetails) {
    lotDetails.classList.remove('active');
    lotDetails.style.display = 'block';
    lotDetails.innerHTML = '';
  }
  if (modalInfo) {
    modalInfo.style.display = '';
    modalInfo.style.opacity = '1';
  }
  if (customScrollbar) {
    customScrollbar.style.display = '';
    customScrollbar.style.visibility = '';
  }
  const customScrollthumb = document.getElementById('customScrollthumb');
  if (customScrollthumb) {
    customScrollthumb.style.display = '';
    customScrollthumb.style.visibility = '';
  }

  // Reset controls visibility & header
  if (backButton) backButton.style.display = 'none';
  if (headerFracc) headerFracc.textContent = CONFIG.name;
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  if (plusBtn) plusBtn.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';

  // Hide lock button when closing viewer (not in pin mode)
  const lockButton = document.getElementById('pinLockButton');
  if (lockButton) lockButton.style.display = 'none';

  // Reset internal scroll/animation flags
  try { scrollHandlerAttached = true; } catch {}
  try { clampCooldown = false; } catch {}

  // Show floating buttons
  document.getElementById('searchBtnStage')?.classList.remove('hide');
  document.getElementById('lalalandInfoBtn')?.classList.remove('hide');

  // --- End copied logic ---

  // üü¢ Load list data if never loaded before
  if (!isDataLoaded) {
    const loadingSpinner = document.getElementById('loadingSpinner');
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    
    fetchLots().then(() => {
      render();
      setupLotClickHandlers();
      
      try {
        enableInfiniteScrollbar();
        highlightCenter();
        updateScrollbar();
      } catch {}

      const scrollTarget = (targetBaseIndex !== null && typeof targetBaseIndex === 'number') 
        ? targetBaseIndex 
        : (typeof targetBaseIndex === 'string' 
          ? baseLots.findIndex(l => l.number === targetBaseIndex)
          : lastOpenedBaseIndex);
          
      if (typeof scrollTarget === 'number' && scrollTarget !== -1) {
        requestAnimationFrame(() => {
          scrollToBaseIndex(scrollTarget, false);
        });
      }
      
      if (loadingSpinner) loadingSpinner.style.display = 'none';
      console.log('List loaded and 360 Viewer closed');
    });
  } else {
    // List already loaded
    try {
      enableInfiniteScrollbar();
      highlightCenter();
      updateScrollbar();
    } catch {}

    const scrollTarget = (targetBaseIndex !== null) ? targetBaseIndex : lastOpenedBaseIndex;
    if (typeof scrollTarget === 'number' && scrollTarget !== -1) {
      requestAnimationFrame(() => {
        scrollToBaseIndex(scrollTarget, false);
      });
    }
    
    console.log('360 Viewer closed in modal');
  }
}

// Update closeModal to handle 360 viewer
const originalCloseModal = window.closeModal;
console.log('üì¶ Saving originalCloseModal:', typeof originalCloseModal);
window.closeModal = function() {
  console.log('üéØ Wrapper closeModal CALLED');
  const modal = document.getElementById('lotModal');

  // If in viewer mode, just close the viewer, not the whole modal
  if (modal.classList.contains('viewer-mode')) {
    console.log('üìπ In viewer mode, closing viewer only');
    close360ViewerInModal();
    return;
  }

  // Otherwise, call original closeModal
  if (originalCloseModal) {
    originalCloseModal();
  }
};

console.log('‚úÖ All VIEW CONE and VIEWER functions loaded successfully');
</script>

<script>
  const btn = document.querySelector('.lalaland-button');

  function bounceButton() {
    if (!btn) return;
    btn.style.animation = 'bounce 1s';
    btn.addEventListener('animationend', () => {
      btn.style.animation = '';
    }, { once: true });
  }

  // Initial bounce after 10 seconds
  setTimeout(bounceButton, 10000);

  // Subsequent bounces every 3 minutes
  setInterval(bounceButton, 3 * 60 * 1000);

const ctaToaster = document.getElementById('ctaToaster');
const whatsappBtn = document.querySelector('.lalaland-button');

const ctaobserver = new MutationObserver(() => {
  if (ctaToaster.classList.contains('show')) {
    setTimeout(() => {
      whatsappBtn.classList.add('bounce');

      // Remove after animation so it can be triggered again later
      setTimeout(() => {
        whatsappBtn.classList.remove('bounce');
      }, 600); // duration of bounce animation
    }, 4000); // ‚è≥ 2s delay before bounce
  }
});

ctaobserver.observe(ctaToaster, {
  attributes: true,
  attributeFilter: ['class']
});

</script>

<script>
  //HASH FOR URL
  function openInitialLotModal() {
    const hash = window.location.hash;
    if (hash.startsWith('#lot=')) {
      const lotName = decodeURIComponent(hash.slice(5));
      const lot = lotData.find(l => l.name === lotName);
      if (lot) openModal(lot);
    }
  }
</script>
   
<script>
  // LOAD SUPABASE
  window.supabaseReady = new Promise((resolve, reject) => {
    const supabaseScript = document.createElement('script');
    supabaseScript.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
    
    supabaseScript.onload = () => {
      fetch('https://la-la.land/sb_config.json')
        .then(r => r.json())
        .then(cfg => {
          window.supabaseClient = supabase.createClient(cfg.url, cfg.key, {
            auth: {
              storageKey: `sb-${CURRENT_CLIENT}-auth`
            }
          });
          console.log(`‚úÖ Supabase client initialized with config.json (storageKey: sb-${CURRENT_CLIENT}-auth)`);
          resolve();

          // ‚úÖ ‚úÖ ‚úÖ ADD REALTIME SUBSCRIPTION HERE
         // Track manually cycled lots to skip next realtime render
         window.skipNextRealtimeRender = window.skipNextRealtimeRender || new Set();

         // Debounce render for rapid updates (e.g., bulk price edits)
         let realtimeRenderTimeout = null;

         const channel = window.supabaseClient
  .channel('lots-realtime')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'lots',
      filter: `client_id=eq.${CURRENT_CLIENT}`
    },
    (payload) => {
      console.log('üì° Change detected:', payload);

      const updatedLotName = payload.new?.lot_name || payload.old?.lot_name;
      const lotNumber = extractLotNumber(updatedLotName);

      // Check if we should skip re-render (manual cycle in list mode)
      const skipRender = window.skipNextRealtimeRender.has(updatedLotName);
      if (skipRender) {
        console.log('‚è≠Ô∏è Skipping realtime re-render for manually cycled lot');
        // Keep skipping until modal closes or detail view opens
      }

      // üü¢ UPDATE ALL DATA SOURCES, not just lotData

      // 1. Update lotData (map data)
      const updatedIndex = lotData.findIndex(l => l.name === updatedLotName);
      if (updatedIndex !== -1) {
        const lot = lotData[updatedIndex];
        const raw = payload.new?.availability ?? lot.availability ?? 'Available';
        const wasAvailable = (lot.availability ?? '').toLowerCase() !== 'sold';
        const nowSold = raw.toLowerCase() === 'sold';

        lot.availability = raw;
        lot.featured = raw.toLowerCase() === 'featured';
        lot.rSize = payload.new?.rSize ?? lot.rSize;
        lot.millones = payload.new?.millones ?? lot.millones;

        // Update map source data so filters work properly
        if (map && map.getSource('lots-final')) {
          const source = map.getSource('lots-final');

          // Create features matching the lotFeature format exactly
          const updatedGeojson = {
            type: "FeatureCollection",
            features: lotData.map((l, i) => {
              const c = [...l.coords];
              // Ensure polygon is closed
              if (c[0][0] !== c[c.length - 1][0] || c[0][1] !== c[c.length - 1][1]) {
                c.push(c[0]);
              }
              return {
                type: "Feature",
                geometry: { type: "Polygon", coordinates: [c] },
                properties: {
                  name: l.name,
                  availability: l.availability || 'Available'
                },
                id: i
              };
            })
          };
          source.setData(updatedGeojson);
        }

        // If lot just became sold, add X mark
        if (wasAvailable && nowSold && typeof addSoldXs === 'function') {
          addSoldXs(map, [lot], 300);

          // Auto-remove sold lots from lead's saved lots
          if (window.currentLead && window.leadSavedLots?.has(lot.name)) {
            window.leadSavedLots.delete(lot.name);
            // Remove from database
            window.supabaseClient?.from('lead_saved_lots')
              .delete()
              .eq('lead_id', window.currentLead.id)
              .eq('lot_name', lot.name)
              .eq('client', CURRENT_CLIENT)
              .then(() => console.log('üóëÔ∏è Auto-removed sold lot from favorites:', lot.name));
            // Refresh map layer
            if (typeof refreshSavedLotsLayer === 'function') refreshSavedLotsLayer();
          }
        }
      }

      // üü¢ NEW: Update baseLotsAll (modal data source)
      if (window.baseLotsAll) {
        const baseLotAll = window.baseLotsAll.find(bl => bl.name === updatedLotName);
        if (baseLotAll) {
          baseLotAll.availability = payload.new?.availability ?? baseLotAll.availability;
          baseLotAll.rSize = payload.new?.rSize ?? baseLotAll.rSize;
          baseLotAll.price = payload.new?.millones ?? baseLotAll.price;
        }
      }

      // üü¢ NEW: Update baseLots (current filtered list)
      if (baseLots) {
        const baseLot = baseLots.find(bl => bl.name === updatedLotName);
        if (baseLot) {
          baseLot.availability = payload.new?.availability ?? baseLot.availability;
          baseLot.rSize = payload.new?.rSize ?? baseLot.rSize;
          baseLot.price = payload.new?.millones ?? baseLot.price;
        }
      }

      // üü¢ NEW: Re-render modal if it's open (debounced for bulk edits)
      if (!skipRender && document.getElementById('lotModal').classList.contains('show')) {
        // Clear any pending render
        if (realtimeRenderTimeout) clearTimeout(realtimeRenderTimeout);

        // Debounce render - wait 150ms after last update
        realtimeRenderTimeout = setTimeout(() => {
          // Clear animated featured lots set so animation can play again
          if (typeof animatedFeaturedLots !== 'undefined') {
            animatedFeaturedLots.clear();
          }
          render();
        }, 150);
      }
    }
  )
  .subscribe((status) => {
    if (status === 'SUBSCRIBED') {
      console.log('‚úÖ Realtime subscription active');
    }
    if (status === 'CHANNEL_ERROR') {
      console.error('‚ùå Realtime subscription failed');
    }
  });
        })
        .catch(e => {
          console.error('Failed to load Supabase config:', e);
          reject(new Error("‚ùå Failed to load Supabase config"));
        });
    };
    
    supabaseScript.onerror = () => {
      console.error("‚ùå Failed to load Supabase script");
      reject(new Error("‚ùå Failed to load Supabase script"));
    };
    
    document.head.appendChild(supabaseScript);
  });
</script>

<!-- ===== LEAD TOKEN AUTH VALIDATION ===== -->
<script>
(async function validateLeadAuth() {
  const CURRENT_CLIENT = window.__leadClient || 'agora';

  // Cookie helpers
  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }

  function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 864e5).toUTCString();
    document.cookie = `${name}=${value}; expires=${expires}; path=/; SameSite=Lax`;
  }

  // Wait for Supabase
  await window.supabaseReady;

  const urlToken = window.__leadAuthToken;
  const sessionToken = window.__leadSessionToken;

  // If we have a URL token, validate and claim it
  if (urlToken) {
    try {
      // Look up the token
      const { data: tokenData, error: tokenError } = await window.supabaseClient
        .from('lead_tokens')
        .select('id, lead_id, claimed, leads(id, phone, name, last_name, is_agent)')
        .eq('token', urlToken)
        .single();

      if (tokenError || !tokenData) {
        // Invalid token
        console.error('Invalid token:', urlToken);
        window.location.href = '/' + CURRENT_CLIENT + '/registro.html?error=invalid';
        return;
      }

      if (tokenData.claimed) {
        // Token already claimed by another device
        console.error('Token already claimed:', urlToken);
        window.location.href = '/' + CURRENT_CLIENT + '/registro.html?error=claimed';
        return;
      }

      // Claim the token
      await window.supabaseClient
        .from('lead_tokens')
        .update({ claimed: true, claimed_at: new Date().toISOString() })
        .eq('id', tokenData.id);

      // Update lead's last_seen_at
      await window.supabaseClient
        .from('leads')
        .update({ last_seen_at: new Date().toISOString() })
        .eq('id', tokenData.lead_id);

      // Save session cookie (365 days)
      setCookie('lead_session_' + CURRENT_CLIENT, urlToken, 365);

      // Store lead info globally
      window.currentLead = {
        id: tokenData.lead_id,
        phone: tokenData.leads?.phone,
        name: tokenData.leads?.name,
        lastName: tokenData.leads?.last_name,
        token: urlToken,
        isAgent: (tokenData.leads?.is_agent || []).includes(CURRENT_CLIENT)
      };

      // Set global agent flag
      window.isAgent = (tokenData.leads?.is_agent || []).includes(CURRENT_CLIENT);

      console.log('‚úÖ Lead authenticated via token:', window.currentLead.phone, window.isAgent ? '(AGENT)' : '');

      // Start session tracking
      await startLeadSession();

      // Update lead greeting and show name modal if needed
      updateLeadGreeting();
      if (!window.currentLead.name) {
        showNameModal();
      }

      // Clean URL (remove /m/token, keep just /client/)
      const cleanUrl = window.location.origin + '/' + CURRENT_CLIENT + '/index-m.html';
      window.history.replaceState({}, '', cleanUrl);

    } catch (err) {
      console.error('Token validation error:', err);
      window.location.href = '/' + CURRENT_CLIENT + '/registro.html?error=invalid';
      return;
    }
  }
  // If we have a session cookie, validate it
  else if (sessionToken) {
    try {
      const { data: tokenData, error: tokenError } = await window.supabaseClient
        .from('lead_tokens')
        .select('id, lead_id, leads(id, phone, name, last_name, is_agent)')
        .eq('token', sessionToken)
        .single();

      if (tokenError || !tokenData) {
        // Session token no longer valid
        console.error('Session token invalid');
        document.cookie = 'lead_session_' + CURRENT_CLIENT + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
        window.location.href = '/' + CURRENT_CLIENT + '/registro.html';
        return;
      }

      // Update lead's last_seen_at
      await window.supabaseClient
        .from('leads')
        .update({ last_seen_at: new Date().toISOString() })
        .eq('id', tokenData.lead_id);

      // Store lead info globally
      window.currentLead = {
        id: tokenData.lead_id,
        phone: tokenData.leads?.phone,
        name: tokenData.leads?.name,
        lastName: tokenData.leads?.last_name,
        token: sessionToken,
        isAgent: (tokenData.leads?.is_agent || []).includes(CURRENT_CLIENT)
      };

      // Set global agent flag
      window.isAgent = (tokenData.leads?.is_agent || []).includes(CURRENT_CLIENT);

      console.log('‚úÖ Lead authenticated via session:', window.currentLead.phone, window.isAgent ? '(AGENT)' : '');

      // Start session tracking
      await startLeadSession();

      // Update lead greeting and show name modal if needed
      updateLeadGreeting();
      if (!window.currentLead.name) {
        showNameModal();
      }

    } catch (err) {
      console.error('Session validation error:', err);
      window.location.href = '/' + CURRENT_CLIENT + '/registro.html';
      return;
    }
  }

  // ===== SESSION TRACKING =====
  window.currentSessionId = null;
  window.sessionStartTime = null;

  async function startLeadSession() {
    if (!window.currentLead || !window.supabaseClient) return;

    try {
      window.sessionStartTime = new Date();

      const { data, error } = await window.supabaseClient
        .from('lead_sessions')
        .insert({
          lead_id: window.currentLead.id,
          client_id: CURRENT_CLIENT,
          started_at: window.sessionStartTime.toISOString(),
          page_url: window.location.href,
          user_agent: navigator.userAgent
        })
        .select('id')
        .single();

      if (error) {
        console.error('Failed to create session:', error);
        return;
      }

      window.currentSessionId = data.id;
      console.log('üìä Session started:', window.currentSessionId);

      // Set up session end tracking
      setupSessionEndTracking();
    } catch (err) {
      console.error('Session tracking error:', err);
    }
  }

  async function endLeadSession() {
    if (!window.currentSessionId || !window.sessionStartTime || !window.supabaseClient) return;

    try {
      const endTime = new Date();
      const durationSeconds = Math.floor((endTime - window.sessionStartTime) / 1000);

      await window.supabaseClient
        .from('lead_sessions')
        .update({
          ended_at: endTime.toISOString(),
          duration_seconds: durationSeconds
        })
        .eq('id', window.currentSessionId);

      console.log(`üìä Session ended: ${durationSeconds}s`);
    } catch (err) {
      console.error('Failed to end session:', err);
    }
  }

  function setupSessionEndTracking() {
    // Track when user leaves the page
    window.addEventListener('beforeunload', () => {
      if (!window.currentSessionId) return;

      // Use sendBeacon for reliable delivery during page unload
      const endTime = new Date();
      const durationSeconds = Math.floor((endTime - window.sessionStartTime) / 1000);

      // We can't use async/await in beforeunload, so use sendBeacon
      // But Supabase doesn't support sendBeacon directly, so we do best effort with fetch keepalive
      if (window.supabaseClient) {
        window.supabaseClient
          .from('lead_sessions')
          .update({
            ended_at: endTime.toISOString(),
            duration_seconds: durationSeconds
          })
          .eq('id', window.currentSessionId)
          .then(() => console.log('üìä Session ended on unload'))
          .catch(err => console.error('Failed to end session on unload:', err));
      }
    });

    // Also track visibility changes (tab switches, minimizing)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // User switched away - update session
        endLeadSession();
      }
    });
  }

  // Helper function to update lead greeting
  function updateLeadGreeting() {
    const leadNameEl = document.getElementById('lead-name');
    if (leadNameEl && window.currentLead) {
      const fullName = `${window.currentLead.name || ''} ${window.currentLead.lastName || ''}`.trim();
      leadNameEl.textContent = fullName || 'Usuario';
    }
  }

  // Show name modal
  function showNameModal() {
    const modal = document.getElementById('nameModal');
    if (modal) {
      modal.classList.add('show');
    }
  }

  // Hide name modal
  function hideNameModal() {
    const modal = document.getElementById('nameModal');
    if (modal) {
      modal.classList.remove('show');
    }
  }

  // Handle name form submission
  const nameForm = document.getElementById('nameForm');
  if (nameForm) {
    nameForm.addEventListener('submit', async (e) => {
      e.preventDefault();

      const nameInput = document.getElementById('leadNameInput');
      const lastNameInput = document.getElementById('leadLastNameInput');
      const submitBtn = nameForm.querySelector('button');

      const name = nameInput.value.trim();
      const lastName = lastNameInput.value.trim();

      if (!name || !lastName) return;

      submitBtn.disabled = true;
      submitBtn.textContent = 'Guardando...';

      try {
        // Update lead in Supabase
        await window.supabaseClient
          .from('leads')
          .update({ name, last_name: lastName })
          .eq('id', window.currentLead.id);

        // Update local state
        window.currentLead.name = name;
        window.currentLead.lastName = lastName;

        // Update greeting
        updateLeadGreeting();

        // Hide modal
        hideNameModal();

      } catch (err) {
        console.error('Error saving name:', err);
        alert('Error al guardar. Intenta de nuevo.');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Continuar';
      }
    });
  }

  // Load saved lots for this lead
  if (window.currentLead) {
    try {
      const { data: savedLots } = await window.supabaseClient
        .from('lead_saved_lots')
        .select('lot_name')
        .eq('lead_id', window.currentLead.id)
        .eq('client', CURRENT_CLIENT);

      window.leadSavedLots = new Set(savedLots?.map(s => s.lot_name) || []);
      console.log('‚úÖ Loaded', window.leadSavedLots.size, 'saved lots for lead');

      // Add saved lots layer to map if map is already loaded
      if (window.map && typeof addSavedLotsLayer === 'function') {
        addSavedLotsLayer(window.map);
      }
    } catch (err) {
      console.error('Error loading saved lots:', err);
      window.leadSavedLots = new Set();
    }
  }
})();
</script>


<script>
// ===== AUTH (Supabase OTP) =====
(() => {
  const $  = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));

  // ‚¨áÔ∏è Keep toaster behavior exactly as before (one-arg showToaster)
  const toast = (m) => {
    try { window.showToaster?.(m); } catch { /* no-op to match previous behavior */ }
  };

  // Header controls (only where that header includes .auth-controls)
  const btnLogin  = $('#modal-login-btn');

  // Modal + steps
  const modal     = $('#auth-modal');
  const stepEmail = $('#auth-step-email');
  const stepOtp   = $('#auth-step-otp');
  const emailInp  = $('#auth-email');
  const otpInp    = $('#auth-otp');
  const otpEmail  = $('#otp-email-display');

  const reqBtn     = $('#request-otp');
  const verifyBtn  = $('#verify-otp');
  const cancelBtns = $$('#auth-cancel'); // support cancel buttons in both steps

  let pendingEmail = '';

  function showAuthModal() {
    if (!modal) return;
    // reset to email step
    if (stepEmail) stepEmail.style.display = 'block';
    if (stepOtp)   stepOtp.style.display   = 'none';
    if (emailInp)  emailInp.value = '';
    if (otpInp)    otpInp.value   = '';
    modal.style.display = 'block';
    setTimeout(() => emailInp?.focus(), 0);
  }

  function hideAuthModal() {
    if (!modal) return;
    modal.style.display = 'none';
  }

  function resetModalState() {
    pendingEmail = '';
    if (emailInp) emailInp.value = '';
    if (otpInp)   otpInp.value   = '';
    if (stepEmail) stepEmail.style.display = 'block';
    if (stepOtp)   stepOtp.style.display   = 'none';
  }

  function updateButtons(loggedIn) {
    if (btnLogin)  btnLogin.style.display  = loggedIn ? 'none' : 'flex';

    // Update globe button visual state
    const globeBtn = $('#globe-login-btn');
    if (globeBtn) {
      if (loggedIn) {
        globeBtn.classList.add('logged-in');
        globeBtn.title = 'Logout';
        globeBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="var(--color-white)" aria-hidden="true"><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>';
      } else {
        globeBtn.classList.remove('logged-in');
        globeBtn.title = 'Login';
        globeBtn.textContent = 'Login';
      }
    }

    // Update dashboard button visibility
    const dashboardBtn = $('#dashboard-btn');
    if (dashboardBtn) {
      dashboardBtn.style.display = loggedIn ? 'flex' : 'none';
    }

    // Update global auth state and re-render list to show/hide action buttons
    window.isUserAuthenticated = loggedIn;

    // Show road labels (always visible)
    if (typeof toggleRoadLabels === 'function') {
      toggleRoadLabels();
    }

    if (typeof render === 'function') {
      render();
      if (typeof highlightCenter === 'function') highlightCenter();
      if (typeof updateScrollbar === 'function') updateScrollbar();
    }
  }

  // --- Logout modal ---
  const logoutModal = $('#logout-modal');
  const confirmLogoutBtn = $('#confirm-logout');
  const cancelLogoutBtn = $('#cancel-logout');

  function showLogoutModal() {
    if (!logoutModal) return;
    logoutModal.style.display = 'block';
  }

  function hideLogoutModal() {
    if (!logoutModal) return;
    logoutModal.style.display = 'none';
  }

  confirmLogoutBtn && confirmLogoutBtn.addEventListener('click', async () => {
    try {
      window.clientAccessCache = {}; // PERFORMANCE: Clear cache on sign out
      await window.supabaseClient?.auth.signOut();
      updateButtons(false);
      hideLogoutModal();
      toast('Sesi√≥n cerrada.');
    } catch (e) {
      console.error(e);
      toast('Error al cerrar sesi√≥n.');
    }
  });

  cancelLogoutBtn && cancelLogoutBtn.addEventListener('click', () => {
    hideLogoutModal();
  });

  // Click backdrop to close logout modal
  logoutModal && logoutModal.addEventListener('click', (e) => {
    if (e.target === logoutModal) {
      hideLogoutModal();
    }
  });

  // Close on ESC for logout modal
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && logoutModal?.style.display === 'block') {
      hideLogoutModal();
    }
  });

  // --- UI bindings ---
  btnLogin && btnLogin.addEventListener('click', showAuthModal);

  // Globe login button - check auth state and show appropriate modal
  const globeLoginBtn = $('#globe-login-btn');
  globeLoginBtn && globeLoginBtn.addEventListener('click', async () => {
    // Check if user is logged in
    const session = (await window.supabaseClient?.auth.getSession())?.data?.session;
    const isLoggedIn = !!(session && session.user);

    if (isLoggedIn) {
      showLogoutModal();
    } else {
      showAuthModal();
    }
  });

  // Dashboard button - toggle dashboard modal
  window.isDashboardOpen = false;
  const dashboardBtn = $('#dashboard-btn');
  dashboardBtn && dashboardBtn.addEventListener('click', async () => {
    const wasOpen = window.isDashboardOpen;
    window.isDashboardOpen = !window.isDashboardOpen;

    // Exit compare mode when opening dashboard
    if (window.isDashboardOpen && window.compareMode) {
      const modal = document.getElementById('lotModal');
      const compareBtn = document.getElementById('compareBtn');
      if (compareBtn) {
        compareBtn.classList.remove('active');
      }
      window.compareMode = false;
      window.selectedLots.clear();
      if (typeof removeEditOutlines === 'function') {
        removeEditOutlines();
      }
      console.log('Compare mode OFF (opening dashboard)');

      // Restore from backup
      if (window.originalBaseLots) {
        baseLots = [...window.originalBaseLots];
        window.originalBaseLots = null;
      }

      // Reset modal.dataset.fracc from baseLots (get from first lot)
      if (baseLots && baseLots.length > 0 && baseLots[0].fraccionamiento) {
        modal.dataset.fracc = baseLots[0].fraccionamiento;
        console.log('Reset modal.dataset.fracc to:', baseLots[0].fraccionamiento);
      } else {
        modal.dataset.fracc = CONFIG.defaultCommunity; // Default from config
      }
    }

    // Open or close dashboard modal
    if (window.isDashboardOpen) {
      await openDashboardModal();
    } else {
      closeModal();
    }

    // Toggle eye icons AFTER opening/closing to avoid closeModal resetting them
    const eyeOpen = $('#eye-open-icon');
    const eyeClosed = $('#eye-closed-icon');
    if (eyeOpen && eyeClosed) {
      if (window.isDashboardOpen) {
        eyeOpen.style.display = 'inline-block';  // Show open eye when dashboard is visible
        eyeClosed.style.display = 'none';
        dashboardBtn.classList.add('active');
      } else {
        eyeOpen.style.display = 'none';
        eyeClosed.style.display = 'inline-block';  // Show closed eye when dashboard is hidden
        dashboardBtn.classList.remove('active');
      }
    }
  });

  // Global dashboard button - toggle between global and previous community
  const globalDashboardBtn = $('#globalDashboardButton');
  window.previousDashboardCommunity = null; // Store previous community

  globalDashboardBtn && globalDashboardBtn.addEventListener('click', async () => {
    const isActive = globalDashboardBtn.classList.contains('active');

    if (isActive) {
      // Already showing global - go back to previous community
      globalDashboardBtn.classList.remove('active');

      // Re-open the previous community dashboard
      if (window.previousDashboardCommunity) {
        const modal = document.getElementById('lotModal');
        if (modal) {
          modal.dataset.fracc = window.previousDashboardCommunity;
        }
      }
      await openDashboardModal();
    } else {
      // Not showing global - store current community and show global
      const modal = document.getElementById('lotModal');
      if (modal && modal.dataset.fracc) {
        window.previousDashboardCommunity = modal.dataset.fracc;
      }

      globalDashboardBtn.classList.add('active');
      await openGlobalDashboard();
    }
  });

  // Cancel buttons (both steps)
  cancelBtns.forEach(btn => {
    btn.type = 'button';
    btn.addEventListener('click', () => {
      resetModalState();
      hideAuthModal();
    });
  });

  // Close on ESC
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal?.style.display === 'block') {
      resetModalState();
      hideAuthModal();
    }
  });

  // Click backdrop to close (only if clicking outside the inner box)
  modal && modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      resetModalState();
      hideAuthModal();
    }
  });

  // ======================
  // ALLOWLIST CHECK (editors.email)
  // ======================
  async function isEmailAllowed(email) {
    const { data, error } = await window.supabaseClient
      .from('editors')
      .select('id') // minimal; don't expose lot_table
      .eq('email', email.trim().toLowerCase())
      .eq('client_id', CURRENT_CLIENT)
      .maybeSingle();

    if (error) {
      console.error('Allowlist check failed:', error);
      return false; // fail closed
    }
    return !!data; // true if found
  }

  // ======================
  // CLIENT ACCESS VALIDATION (DATABASE-LEVEL SECURITY)
  // ======================
  async function validateClientAccess(session, retryCount = 0) {
    if (!session || !session.user) {
      return false;
    }

    // PERFORMANCE: Check cache first (per user + client combination)
    const cacheKey = `${session.user.id}_${CURRENT_CLIENT}`;
    if (window.clientAccessCache[cacheKey] !== undefined) {
      console.log('‚úÖ Using cached client access validation');
      return window.clientAccessCache[cacheKey];
    }

    const MAX_RETRIES = 3;
    const RETRY_DELAY_MS = 500; // Wait 500ms between retries

    try {
      // Check if the authenticated user has access to the CURRENT_CLIENT
      const { data, error } = await window.supabaseClient
        .from('editors')
        .select('id')
        .eq('user_id', session.user.id)
        .eq('client_id', CURRENT_CLIENT)
        .maybeSingle();

      if (error) {
        console.error('Client access validation failed:', error);
        return false;
      }

      // If no matching record, might be a race condition with the trigger
      if (!data) {
        // Retry logic: The database trigger might not have completed yet
        if (retryCount < MAX_RETRIES) {
          console.log(`No user_id match found (attempt ${retryCount + 1}/${MAX_RETRIES}). Retrying in ${RETRY_DELAY_MS}ms to allow trigger to complete...`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
          return validateClientAccess(session, retryCount + 1);
        }

        // After all retries, user truly doesn't have access
        console.warn(`User ${session.user.email} attempted to access unauthorized client: ${CURRENT_CLIENT}`);
        // Sign them out immediately - they're logged in but not authorized for this client
        await window.supabaseClient.auth.signOut();
        toast('No tienes acceso a este cliente. Has sido desconectado.');

        // PERFORMANCE: Cache negative result
        window.clientAccessCache[cacheKey] = false;
        return false;
      }

      // PERFORMANCE: Cache positive result
      window.clientAccessCache[cacheKey] = true;
      return true;
    } catch (e) {
      console.error('Client validation error:', e);
      return false;
    }
  }

  // --- Send OTP (guarded by allowlist) ---
  // Security: Prevent duplicate event listeners and rate limit OTP requests
  if (reqBtn && !window.__otpListenerSetup) {
    window.__otpListenerSetup = true;

    // Rate limiting: Track last OTP request time
    let lastOtpRequestTime = 0;
    const OTP_COOLDOWN_MS = 60000; // 60 seconds cooldown between requests

    // Set button type to prevent form submission
    reqBtn.type = 'button';

    reqBtn.addEventListener('click', async () => {
      const email = (emailInp?.value || '').trim().toLowerCase();
      if (!email) { toast('Escribe tu email.'); return; }

      // Basic email format guard
      const looksLikeEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
      if (!looksLikeEmail) { toast('Ingresa un correo v√°lido.'); return; }

      // Rate limiting: Check cooldown period
      const now = Date.now();
      const timeSinceLastRequest = now - lastOtpRequestTime;
      if (lastOtpRequestTime > 0 && timeSinceLastRequest < OTP_COOLDOWN_MS) {
        const remainingSeconds = Math.ceil((OTP_COOLDOWN_MS - timeSinceLastRequest) / 1000);
        toast(`Por favor espera ${remainingSeconds} segundos antes de solicitar otro c√≥digo.`);
        return;
      }

      // Allowlist guard against public.editors(email)
      const allowed = await isEmailAllowed(email);
      if (!allowed) {
        toast('Este correo no est√° autorizado.');
        return;
      }

      // Disable button and show loading state
      const originalText = reqBtn.textContent;
      reqBtn.disabled = true;
      reqBtn.textContent = 'Enviando...';

      try {
        const { error } = await window.supabaseClient.auth.signInWithOtp({
          email,
          options: { emailRedirectTo: window.location.origin }
        });
        if (error) throw error;

        // Update last request time on success
        lastOtpRequestTime = now;

        pendingEmail = email;
        if (otpEmail) otpEmail.textContent = email; // "C√≥digo enviado a ‚Ä¶"
        if (stepEmail) stepEmail.style.display = 'none';
        if (stepOtp)   stepOtp.style.display   = 'block';
        setTimeout(() => otpInp?.focus(), 0);
        toast('C√≥digo enviado. Revisa tu correo.');
      } catch (e) {
        console.error('OTP Error:', e);
        console.error('Error message:', e.message);
        console.error('Error details:', e.error_description || e.msg);

        // Show more specific error to help debug
        const errMsg = e.message || e.error_description || 'No pudimos enviar el c√≥digo.';

        // If rate limit error, provide helpful message
        if (e.message && e.message.includes('rate limit')) {
          toast('Se han enviado demasiados c√≥digos. Por favor espera unos minutos e intenta de nuevo.');
          // Update cooldown to prevent immediate retry
          lastOtpRequestTime = now;
        } else {
          toast(`Error: ${errMsg}`);
        }
      } finally {
        // Re-enable button after request completes
        reqBtn.disabled = false;
        reqBtn.textContent = originalText;
      }
    });
  }

  // --- Verify OTP ---
  // Security: Prevent duplicate event listeners
  if (verifyBtn && !window.__verifyOtpListenerSetup) {
    window.__verifyOtpListenerSetup = true;

    // Set button type to prevent form submission
    verifyBtn.type = 'button';

    verifyBtn.addEventListener('click', async () => {
      const token = (otpInp?.value || '').trim();
      if (token.length !== 6) { toast('El c√≥digo debe tener 6 d√≠gitos.'); return; }

      // Disable button and show loading state
      const originalText = verifyBtn.textContent;
      verifyBtn.disabled = true;
      verifyBtn.textContent = 'Verificando...';

      try {
        const { data, error } = await window.supabaseClient.auth.verifyOtp({
          email: pendingEmail,
          token,
          type: 'email'
        });
        if (error) throw error;

        // SECURITY: Validate user has access to this client
        const hasAccess = await validateClientAccess(data.session);
        if (!hasAccess) {
          // validateClientAccess already signed out and showed toast
          resetModalState();
          hideAuthModal();
          return;
        }

        resetModalState();
        hideAuthModal();
        toast('Has iniciado sesi√≥n.');
        // UI will also update via auth state listener below
      } catch (e) {
        console.error(e);
        toast('C√≥digo inv√°lido o vencido.');
      } finally {
        // Re-enable button after request completes
        verifyBtn.disabled = false;
        verifyBtn.textContent = originalText;
      }
    });
  }

  // --- Initialize auth state (no toast on page refresh) ---
  const initAuth = async () => {
    try {
      const { data: { session } = { session: null } } =
        await window.supabaseClient.auth.getSession();

      // SECURITY: Validate client access on page load
      if (session && session.user) {
        const hasAccess = await validateClientAccess(session);
        updateButtons(hasAccess);
      } else {
        updateButtons(false);
      }
    } catch (e) {
      console.warn('getSession failed:', e);
    }

    window.supabaseClient.auth.onAuthStateChange(async (_event, session) => {
      // SECURITY: Validate client access on auth state change
      if (session && session.user) {
        const hasAccess = await validateClientAccess(session);
        updateButtons(hasAccess);
      } else {
        updateButtons(false);
      }
      // No toast here‚Äîonly in explicit login/logout actions above
    });
  };

  if (window.supabaseReady && typeof window.supabaseReady.then === 'function') {
    window.supabaseReady.then(initAuth);
  } else {
    const iv = setInterval(() => {
      if (window.supabaseClient) {
        clearInterval(iv);
        initAuth();
      }
    }, 200);
  }

  // ===== DASHBOARD MODAL FUNCTIONALITY =====
  window.openDashboardModal = async function() {
    await window.supabaseReady;
    const modal = document.getElementById('lotModal');
    const lotDetails = document.getElementById('lotDetails');
    const modalInfo = document.getElementById('modalInfo');
    const headerFracc = document.getElementById('headerFracc');
    const headerLotNumber = document.getElementById('headerLotNumber');
    const wrapper = document.querySelector('.modal-content-wrapper');
    const backButton = document.getElementById('backButton');
    const customScrollbar = document.getElementById('customScrollbar');

    // Exit compare mode completely before opening dashboard
    if (window.compareMode) {
      const compareBtn = document.getElementById('compareBtn');
      if (compareBtn) {
        compareBtn.classList.remove('active');
      }
      window.compareMode = false;
      window.selectedLots.clear();
      if (typeof removeEditOutlines === 'function') {
        removeEditOutlines();
      }
      console.log('Compare mode OFF (opening dashboard modal)');

      // Restore from backup
      if (window.originalBaseLots) {
        baseLots = [...window.originalBaseLots];
        window.originalBaseLots = null;
      }

      // Reset modal.dataset.fracc from baseLots (get from first lot)
      if (baseLots && baseLots.length > 0 && baseLots[0].fraccionamiento) {
        modal.dataset.fracc = baseLots[0].fraccionamiento;
        console.log('openDashboardModal: Reset modal.dataset.fracc to:', baseLots[0].fraccionamiento);
      } else {
        modal.dataset.fracc = CONFIG.defaultCommunity; // Default from config
      }
    }

    // Get current community based on modal dataset, default to 'marsella'
    const defaultComm = CONFIG.defaultCommunity;
    const currentFracc = modal?.dataset?.fracc || defaultComm;
    const communityName = (currentFracc || defaultComm).toUpperCase();

    // Show modal
    if (!modal.classList.contains('show')) {
      modal.classList.add('show');
      modal.style.display = 'block';
      if (typeof adjustMapForModal === 'function') adjustMapForModal();
    }

    // Set modal to dashboard mode
    modal.classList.add('info-mode');
    modal.classList.remove('lot-mode', 'pin-mode');

    // Hide list/modal info area, show only lotDetails for dashboard
    if (modalInfo) {
      modalInfo.style.display = 'none';
      modalInfo.innerHTML = '';
    }
    if (customScrollbar) {
      customScrollbar.style.display = 'none';
    }

    // Set header
    if (headerFracc) {
      headerFracc.textContent = communityName;
      headerFracc.contentEditable = 'false';
    }
    if (headerLotNumber) headerLotNumber.style.display = 'none';
    if (backButton) backButton.style.display = 'none';

    // Hide PIN button in dashboard mode, show GLOBAL button
    const poiBtn = document.getElementById('poiButton');
    if (poiBtn) poiBtn.style.display = 'none';

    const globalBtn = document.getElementById('globalDashboardButton');
    if (globalBtn) {
      globalBtn.style.display = 'block';
      // When opening community dashboard, ensure global button is NOT active
      globalBtn.classList.remove('active');
    }

    // Clear and prepare content area
    if (lotDetails) {
      lotDetails.classList.remove('active');
      lotDetails.innerHTML = '';
      lotDetails.style.display = 'block';
    }
    if (wrapper) wrapper.classList.add('show-details');

    // Show loading state
    lotDetails.innerHTML = `<div style="padding: 40px; text-align: center; color: ${CONFIG.colors.textLight};">Cargando datos...</div>`;

    try {
      // Fetch dashboard data
      const dashboardData = await fetchDashboardData(currentFracc);

      // Debug log
      console.log('Dashboard data for', currentFracc, ':', dashboardData);

      // Render dashboard
      renderDashboard(lotDetails, dashboardData);
    } catch (error) {
      console.error('Error loading dashboard:', error);
      lotDetails.innerHTML = `<div style="padding: 40px; text-align: center; color: ${CONFIG.colors.error};">Error al cargar el dashboard</div>`;
    }
  };

// Update fetchDashboardData with pagination
async function fetchDashboardData(fracc) {
  await window.supabaseReady;

  console.log('üîÑ Fetching dashboard data for', fracc);

  // Fetch all lots for this community with pagination
  const BATCH_SIZE = 1000;
  let allLots = [];
  let start = 0;
  let hasMore = true;

  while (hasMore) {
    const { data: batch, error: lotsError } = await window.supabaseClient
      .from('lots')
      .select('*')
      .eq('client_id', CURRENT_CLIENT)
      .eq('fraccionamiento', fracc)
      .range(start, start + BATCH_SIZE - 1);

    if (lotsError) {
      console.error('‚ùå ERROR fetching lot batch from Supabase:', lotsError);
      throw lotsError;
    }

    if (batch && batch.length > 0) {
      allLots = [...allLots, ...batch];
      start += BATCH_SIZE;
      // If we got less than a full batch, we're done
      hasMore = batch.length === BATCH_SIZE;
    } else {
      hasMore = false;
    }
  }

  console.log('‚úÖ Successfully fetched', allLots?.length || 0, 'lots for dashboard');

  // Rest of your existing dashboard calculation logic...
  const availableLots = allLots?.filter(lot =>
    lot.availability?.toLowerCase() !== 'sold'
  ).length || 0;
  const totalLots = allLots?.length || 0;

  // Calculate projected income
  let projectedIncome = 0;
  allLots?.forEach(lot => {
    if (lot.availability?.toLowerCase() !== 'sold') {
      const priceStr = String(lot.price || '0').replace(/[$,\s]/g, '');
      const price = parseFloat(priceStr) || 0;
      projectedIncome += price;
    }
  });

  // Fetch audit data with pagination
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const sixtyDaysAgo = new Date();
  sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);

  // Paginate audit data too
  let allAuditData = [];
  let auditStart = 0;
  let hasMoreAudit = true;

  while (hasMoreAudit) {
    const auditQueryPromise = window.supabaseClient
      .from('lot_updates_audit')
      .select('*')
      .eq('fraccionamiento', fracc)
      .gte('updated_at', sixtyDaysAgo.toISOString())
      .order('updated_at', { ascending: false })
      .range(auditStart, auditStart + BATCH_SIZE - 1);

    const auditTimeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Audit query timeout')), 10000)
    );

    const { data: auditBatch, error: auditError } = await Promise.race([auditQueryPromise, auditTimeoutPromise]);

    if (auditError) {
      console.error('‚ùå ERROR fetching audit batch:', auditError);
      break;
    }

    if (auditBatch && auditBatch.length > 0) {
      allAuditData = [...allAuditData, ...auditBatch];
      auditStart += BATCH_SIZE;
      hasMoreAudit = auditBatch.length === BATCH_SIZE;
    } else {
      hasMoreAudit = false;
    }
  }

  console.log('‚úÖ Successfully fetched', allAuditData?.length || 0, 'audit records');

  // Count lots sold in last 30 days
  const last30DaysRecords = allAuditData?.filter(record =>
    record.new_availability?.toLowerCase() === 'sold' &&
    record.old_availability?.toLowerCase() !== 'sold' &&
    new Date(record.updated_at) >= thirtyDaysAgo
  ) || [];

  // Filter out lots where the sale fell through
  const validSalesLast30Days = last30DaysRecords.filter(saleRecord => {
    const laterReverts = allAuditData?.filter(record =>
      record.lot_name === saleRecord.lot_name &&
      new Date(record.updated_at) > new Date(saleRecord.updated_at) &&
      record.new_availability?.toLowerCase() === 'available'
    ) || [];
    return laterReverts.length === 0;
  });

  const soldLast30Days = validSalesLast30Days.length;

  // Count lots sold between 30-60 days ago
  const prev30DaysRecords = allAuditData?.filter(record =>
    record.new_availability?.toLowerCase() === 'sold' &&
    record.old_availability?.toLowerCase() !== 'sold' &&
    new Date(record.updated_at) >= sixtyDaysAgo &&
    new Date(record.updated_at) < thirtyDaysAgo
  ) || [];

  const validSalesPrev30Days = prev30DaysRecords.filter(saleRecord => {
    const laterReverts = allAuditData?.filter(record =>
      record.lot_name === saleRecord.lot_name &&
      new Date(record.updated_at) > new Date(saleRecord.updated_at) &&
      record.new_availability?.toLowerCase() === 'available'
    ) || [];
    return laterReverts.length === 0;
  });

  const soldLast60Days = validSalesPrev30Days.length;

  // Calculate percentage change
  let percentageChange = 0;
  if (soldLast60Days > 0) {
    percentageChange = ((soldLast30Days - soldLast60Days) / soldLast60Days * 100);
  } else if (soldLast30Days > 0) {
    percentageChange = 100;
  }

  return {
    availableLots,
    totalLots,
    projectedIncome,
    soldLast30Days,
    percentageChange
  };
}

// Update fetchGlobalDashboardData with pagination
async function fetchGlobalDashboardData() {
  await window.supabaseReady;

  console.log('üîÑ Fetching GLOBAL dashboard data');

  // Fetch ALL lots with pagination
  const BATCH_SIZE = 1000;
  let allLots = [];
  let start = 0;
  let hasMore = true;

  while (hasMore) {
    const { data: batch, error: lotsError } = await window.supabaseClient
      .from('lots')
      .select('*')
      .eq('client_id', CURRENT_CLIENT)
      .range(start, start + BATCH_SIZE - 1);

    if (lotsError) {
      console.error('‚ùå ERROR fetching lots for GLOBAL dashboard:', lotsError);
      throw lotsError;
    }

    if (batch && batch.length > 0) {
      allLots = [...allLots, ...batch];
      start += BATCH_SIZE;
      hasMore = batch.length === BATCH_SIZE;
    } else {
      hasMore = false;
    }
  }

  console.log('‚úÖ Successfully fetched', allLots?.length || 0, 'lots for GLOBAL dashboard');

  // Calculate dashboard metrics
  const availableLots = allLots?.filter(lot =>
    lot.availability?.toLowerCase() !== 'sold'
  ).length || 0;
  const totalLots = allLots?.length || 0;

  let projectedIncome = 0;
  allLots?.forEach(lot => {
    if (lot.availability?.toLowerCase() !== 'sold') {
      const priceStr = String(lot.price || '0').replace(/[$,\s]/g, '');
      const price = parseFloat(priceStr) || 0;
      projectedIncome += price;
    }
  });

  console.log('Global projected income:', projectedIncome);

  // Fetch audit data with pagination
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const sixtyDaysAgo = new Date();
  sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);

  let allAuditData = [];
  let auditStart = 0;
  let hasMoreAudit = true;

  while (hasMoreAudit) {
    const auditQueryPromise = window.supabaseClient
      .from('lot_updates_audit')
      .select('*')
      .eq('client_id', CURRENT_CLIENT)
      .gte('updated_at', sixtyDaysAgo.toISOString())
      .order('updated_at', { ascending: false })
      .range(auditStart, auditStart + BATCH_SIZE - 1);

    const auditTimeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Audit query timeout')), 10000)
    );

    const { data: auditBatch, error: auditError } = await Promise.race([auditQueryPromise, auditTimeoutPromise]);

    if (auditError) {
      console.error('‚ùå ERROR fetching GLOBAL audit batch:', auditError);
      break;
    }

    if (auditBatch && auditBatch.length > 0) {
      allAuditData = [...allAuditData, ...auditBatch];
      auditStart += BATCH_SIZE;
      hasMoreAudit = auditBatch.length === BATCH_SIZE;
    } else {
      hasMoreAudit = false;
    }
  }

  console.log('‚úÖ Successfully fetched', allAuditData?.length || 0, 'GLOBAL audit records');

  // Count lots sold in last 30 days
  const last30DaysRecords = allAuditData?.filter(record =>
    record.new_availability?.toLowerCase() === 'sold' &&
    record.old_availability?.toLowerCase() !== 'sold' &&
    new Date(record.updated_at) >= thirtyDaysAgo
  ) || [];

  const validSalesLast30Days = last30DaysRecords.filter(saleRecord => {
    const laterReverts = allAuditData?.filter(record =>
      record.lot_name === saleRecord.lot_name &&
      new Date(record.updated_at) > new Date(saleRecord.updated_at) &&
      record.new_availability?.toLowerCase() === 'available'
    ) || [];
    return laterReverts.length === 0;
  });

  const soldLast30Days = validSalesLast30Days.length;

  // Count lots sold between 30-60 days ago
  const prev30DaysRecords = allAuditData?.filter(record =>
    record.new_availability?.toLowerCase() === 'sold' &&
    record.old_availability?.toLowerCase() !== 'sold' &&
    new Date(record.updated_at) >= sixtyDaysAgo &&
    new Date(record.updated_at) < thirtyDaysAgo
  ) || [];

  const validSalesPrev30Days = prev30DaysRecords.filter(saleRecord => {
    const laterReverts = allAuditData?.filter(record =>
      record.lot_name === saleRecord.lot_name &&
      new Date(record.updated_at) > new Date(saleRecord.updated_at) &&
      record.new_availability?.toLowerCase() === 'available'
    ) || [];
    return laterReverts.length === 0;
  });

  const soldLast60Days = validSalesPrev30Days.length;

  // Calculate percentage change
  let percentageChange = 0;
  if (soldLast60Days > 0) {
    percentageChange = ((soldLast30Days - soldLast60Days) / soldLast60Days * 100);
  } else if (soldLast30Days > 0) {
    percentageChange = 100;
  }

  console.log('GLOBAL percentage change calculation:');
  console.log(`  Last 30 days: ${soldLast30Days} lots`);
  console.log(`  Previous 30 days: ${soldLast60Days} lots`);
  console.log(`  Change: ${percentageChange.toFixed(1)}%`);

  return {
    availableLots,
    totalLots,
    projectedIncome,
    soldLast30Days,
    percentageChange
  };
}

  // Open global dashboard showing all communities
  window.openGlobalDashboard = async function() {
    const headerFracc = document.getElementById('headerFracc');
    const lotDetails = document.getElementById('lotDetails');

    // Update header to show GLOBAL
    if (headerFracc) {
      headerFracc.textContent = 'GLOBAL';
    }

    // Show loading state
    if (lotDetails) {
      lotDetails.innerHTML = `<div style="padding: 40px; text-align: center; color: ${CONFIG.colors.textLight};">Cargando datos globales...</div>`;
    }

    try {
      // Fetch global dashboard data
      const dashboardData = await fetchGlobalDashboardData();
      console.log('Global dashboard data:', dashboardData);

      // Render dashboard
      renderDashboard(lotDetails, dashboardData);
    } catch (error) {
      console.error('Error loading global dashboard:', error);
      lotDetails.innerHTML = `<div style="padding: 40px; text-align: center; color: ${CONFIG.colors.error};">Error al cargar el dashboard global</div>`;
    }
  };

  function renderDashboard(container, data) {
    // Calculate percentage of available lots
    const availablePercentage = data.totalLots > 0
      ? ((data.availableLots / data.totalLots) * 100).toFixed(1)
      : 0;

    // Calculate 1% commission (what sellers get)
    const commission = data.projectedIncome * 0.01;

    // Format percentage change with arrow
    const percentageChange = data.percentageChange || 0;
    const isPositive = percentageChange > 0;
    const isNegative = percentageChange < 0;
    const arrow = isPositive ? '‚Üë' : isNegative ? '‚Üì' : '';
    const changeColor = isPositive ? CONFIG.colors.success : isNegative ? CONFIG.colors.error : CONFIG.colors.textLight;
    const changeText = percentageChange !== 0
      ? `${arrow} ${Math.abs(percentageChange).toFixed(1)}%`
      : '';

    const dashboardHTML = `
      <div style="padding: 16px; display: flex; flex-direction: column; gap: 12px; height: 100%; box-sizing: border-box;">
        <!-- Lotes Disponibles -->
        <div style="background: ${CONFIG.colors.primaryPale}; border-left: 4px solid ${CONFIG.colors.primary}; padding: 16px; border-radius: 6px; flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0;">
          <div style="font-size: 12px; color: ${CONFIG.colors.textLight}; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">
            Lotes Disponibles
          </div>
          <div style="font-size: clamp(24px, 5vw, 32px); font-weight: 700; color: ${CONFIG.colors.textDark}; line-height: 1.2; display: flex; justify-content: space-between; align-items: baseline;">
            <div>
              ${data.availableLots} <span style="font-size: clamp(18px, 3.5vw, 22px); color: ${CONFIG.colors.textLight};">/ ${data.totalLots}</span>
            </div>
            <span style="font-size: clamp(14px, 3vw, 16px); color: ${CONFIG.colors.primary};">${availablePercentage}%</span>
          </div>
        </div>

        <!-- Vendidos en los √∫ltimos 30 d√≠as -->
        <div style="background: ${CONFIG.colors.successPale}; border-left: 4px solid ${CONFIG.colors.success}; padding: 16px; border-radius: 6px; flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0;">
          <div style="font-size: 12px; color: ${CONFIG.colors.textLight}; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">
            Vendidos en los √∫ltimos 30 d√≠as
          </div>
          <div style="font-size: clamp(24px, 5vw, 32px); font-weight: 700; color: ${CONFIG.colors.success}; line-height: 1.2;">
            ${data.soldLast30Days}
            ${changeText ? `<span style="font-size: clamp(14px, 3vw, 16px); color: ${changeColor}; margin-left: 8px;">${changeText}</span>` : ''}
          </div>
        </div>

        <!-- Ingresos Proyectados -->
        <div style="background: ${CONFIG.colors.grayDarkPale}; border-left: 4px solid ${CONFIG.colors.grayDark}; padding: 16px; border-radius: 6px; flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0;">
          <div style="font-size: 12px; color: ${CONFIG.colors.textLight}; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">
            Ingresos Proyectados
          </div>
          <div style="font-size: clamp(24px, 5vw, 30px); font-weight: 700; color: ${CONFIG.colors.grayDark}; line-height: 1.2; display: flex; justify-content: space-between; align-items: baseline;">
            <div>
              $${data.projectedIncome.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
              <span style="font-size: clamp(12px, 2.5vw, 16px); vertical-align: super; font-weight: 600; color: ${CONFIG.colors.textLight};">MXN</span>
            </div>
            <span style="font-size: clamp(14px, 3vw, 16px); color: ${CONFIG.colors.grayDark};">$${commission.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
          </div>
          <div style="font-size: 10px; color: ${CONFIG.colors.textLight}; margin-top: 4px; display: flex; justify-content: space-between; align-items: center;">
            <span>Basado en ${data.availableLots} lotes disponibles</span>
            <span>Comisiones disponibles</span>
          </div>
        </div>
      </div>
    `;

    container.innerHTML = dashboardHTML;
    container.classList.add('active');
  }

})();
</script>


 

<script>
// MAP INITIALIZE
let lotData = [];
let map;  // global map variable
window.hoveredId = null;  // Use window.hoveredId globally for map hover state
let currentLotIndex = -1;
let sideLengthLabels = []; // Array to store side length label elements
let currentLabeledLot = null; // Track which lot has labels
let isDetailOpen = false;
let lastOpenedBaseIndex = null;

// Global authentication state
window.isUserAuthenticated = false;

// Function to show road labels and hide built-in Mapbox labels
function toggleRoadLabels() {
  if (!map || !map.getStyle()) return;

  const style = map.getStyle();
  if (!style) return;

  // Always show custom labels from labels.json (the 'road' layer)
  if (map.getLayer('road')) {
    try {
      map.setLayoutProperty('road', 'visibility', 'visible');
      map.setPaintProperty('road', 'line-opacity', 1);
    } catch (e) {
      console.warn('Could not show road layer:', e);
    }
  }

  // Always hide built-in Mapbox label layers
  // Handle both regular styles and v3 styles with imports
  try {
    if (style.layers && Array.isArray(style.layers)) {
      style.layers.forEach(layer => {
        // Skip our custom labels layers
        if (layer.id === 'lot-labels' || layer.id === 'manzana-labels' ||
            layer.id === 'custom-road-labels' || layer.id === 'custom-place-labels') return;

        if (layer.id.includes('label') ||
            layer.id.includes('shield') ||
            layer.id.includes('symbol')) {
          try {
            map.setLayoutProperty(
              layer.id,
              'visibility',
              'none'
            );
          } catch (e) {
            // Layer might not support visibility property
            console.warn(`Could not toggle visibility for layer: ${layer.id}`);
          }
        }
      });
    }
  } catch (e) {
    console.warn('Could not iterate over style layers:', e);
  }
}

// Initialize map
const mapboxTokenUrl = CONFIG.mapbox.tokenUrl;
const mapboxStyle = CONFIG.mapbox.style;
const initialCenter = CONFIG.mapbox.initialView.center;
const initialZoom = CONFIG.mapbox.initialView.zoom;

fetch(mapboxTokenUrl)
  .then(r => r.text())
  .then(token => {
    mapboxgl.accessToken = token.trim();

    // Calculate bounds that contain BOTH satellite image areas
    const communityBounds = new mapboxgl.LngLatBounds();

    // First community bounds (drone image - barcelona.jpg)
    communityBounds.extend([-100.16483, 25.457155]);   // Bottom-left
    communityBounds.extend([-100.154874, 25.467111]);  // Top-right

    // Second community bounds (agora image - agora.jpg)
    communityBounds.extend([-100.183685, 25.433407]);  // Bottom-left
    communityBounds.extend([-100.173731, 25.443361]);  // Top-right

    // YC DEMO: Start zoomed in on default community instead of showing all bounds INITIAL ZOOM
    const m = new mapboxgl.Map({
      container: 'map',
      style: mapboxStyle,
      center: initialCenter,
      zoom: initialZoom
    });
   
    window.map = m;
    map = m;

    map.doubleClickZoom.disable();

       map.on('load', async () => {
      console.log('‚úÖ Map loaded successfully!');

      // Add custom road and place labels with Barlow Condensed
      // (Note: Road/Place labels should be disabled in Mapbox Studio style)
      map.once('idle', () => {
        console.log('üîÑ Adding custom labels with Barlow Condensed...');

        // Add our own Mapbox Streets source (v3 imports don't expose sources directly)
        if (!map.getSource('mapbox-streets-custom')) {
          map.addSource('mapbox-streets-custom', {
            type: 'vector',
            url: 'mapbox://mapbox.mapbox-streets-v8'
          });
          console.log('‚úÖ Added mapbox-streets-custom source');
        }

        // Road labels - only major roads
        if (!map.getLayer('custom-road-labels')) {
          map.addLayer({
            id: 'custom-road-labels',
            type: 'symbol',
            source: 'mapbox-streets-custom',
            'source-layer': 'road',
            filter: ['all',
              ['has', 'name'],
              ['in', 'class', 'motorway', 'trunk', 'primary', 'secondary']
            ],
            layout: {
              'text-field': ['get', 'name'],
              'text-font': [CONFIG.misc.mapboxFont, 'Arial Unicode MS Regular'],
              'text-size': ['interpolate', ['linear'], ['zoom'], 10, 10, 18, 14],
              'symbol-placement': 'line',
              'text-rotation-alignment': 'map',
              'text-max-angle': 30,
              'text-transform': 'uppercase'
            },
            paint: {
              'text-color': '#fff',
              'text-halo-color': '#333',
              'text-halo-width': 0.5
            }
          });
          console.log('‚úÖ Added custom road labels');
        }

        // City/Town labels - only cities and towns (not villages/hamlets)

        if (!map.getLayer('custom-place-labels')) {

          map.addLayer({

            id: 'custom-place-labels',

            type: 'symbol',

            source: 'mapbox-streets-custom',

            'source-layer': 'place_label',

            filter: ['in', ['get', 'type'], ['literal', ['city', 'town']]],
            layout: {
              'text-field': ['get', 'name'],
              'text-font': [CONFIG.misc.mapboxFont, 'Arial Unicode MS Regular'],
              'text-size': ['interpolate', ['linear'], ['zoom'],
                6, 12,
                10, 16,
                14, 20
              ],
              'text-anchor': 'center',
              'text-transform': 'uppercase'
            },
            paint: {
              'text-color': '#fff',
              'text-halo-color': '#333',
              'text-halo-width': 0.5
            }
          });
          console.log('‚úÖ Added custom place labels');
        }

        map.triggerRepaint();
      });

      // Load road labels (or create empty 'road' layer if labels.json doesn't exist)
      await loadRoad(map, async () => {
        await loadLotsAsync(map);
        await window.supabaseReady;
        await enrichLotsWithAvailability();

        animateLots(map, async () => {
          addCustomImage(map);
          await loadManzanaLabels(map);
          addFeaturedLotsLayer(map, () => {
    // This callback runs AFTER featured lots have completed initial pulse

    // Add saved lots layer for leads
    if (window.currentLead && window.leadSavedLots) {
      addSavedLotsLayer(map);
    }

    // ===== MOVE ALL MAP INTERACTIONS HERE =====

        // ===== COMMUNITY SEARCH CIRCULAR MENU =====
// ===== COMMUNITY SEARCH CIRCULAR MENU =====
function setupCommunitySearchMenu() {
  const searchBtn = document.getElementById('searchBtnStage');
  const circleMenu = document.getElementById('communityCircleMenu');
  if (!searchBtn || !circleMenu) return; // Exit if elements don't exist

  // Build communities object from CONFIG
  const communities = {};
  Object.keys(CONFIG.communities).forEach(key => {
    const comm = CONFIG.communities[key];
    communities[comm.fracc] = {
      center: comm.center,
      zoom: comm.zoom,
      fracc: comm.fracc,
      name: comm.name
    };
  });

  let menuActive = false;

  // Toggle menu on search button click
  searchBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    menuActive = !menuActive;
    circleMenu.classList.toggle('active', menuActive);
  });

  // Handle community selection
  document.querySelectorAll('.community-option').forEach(option => {
    option.addEventListener('click', function(e) {
      e.stopPropagation();
      const communityId = this.dataset.community;
      
      if (communities[communityId]) {
        const community = communities[communityId];

        // Fly to the community
        map.flyTo({
          center: community.center,
          zoom: community.zoom,
          speed: 1.2,
          curve: 1.5
        });

        // ALWAYS set the current fracc so getCurrentFraccZoom works correctly
        const modal = document.getElementById('lotModal');
        if (modal) {
          modal.dataset.fracc = community.fracc;

          // Update community logo
          if (typeof window.updateCommunityLogo === 'function') {
            window.updateCommunityLogo();
          }

          // Filter the modal list if it's open
          if (modal.classList.contains('show')) {
            if (typeof window.resetUnitButtons === 'function') {
              window.resetUnitButtons();
            }
          }
        }

        // Show toast with community name
        showToaster(`Navegando a ${community.name}`);
      }
      
      // Close menu after selection
      menuActive = false;
      circleMenu.classList.remove('active');
    });
  });

  // Close menu when clicking elsewhere
  document.addEventListener('click', function() {
    menuActive = false;
    circleMenu.classList.remove('active');
  });

  // Prevent menu close when clicking inside menu
  circleMenu.addEventListener('click', function(e) {
    e.stopPropagation();
  });
}

        // Initialize the community search menu
        setupCommunitySearchMenu();
        // ===== END COMMUNITY SEARCH =====

// ===== üü¢ ADD MARBLE LAYERS HERE =====
        // üü¢ MARBLES SOURCE
        map.addSource('marbles', { 
          type: 'geojson', 
          data: { type:'FeatureCollection', features: [] } 
        });

        // VISIBLE marbles layer (fades in/out based on zoom)
        map.addLayer({
          id: 'marbles-layer',
          type: 'circle',
          source: 'marbles',
          minzoom: 16,
          paint: {
            'circle-radius': ['case',
              ['==', ['get', 'isSelected'], true], 6,
              ['==', ['get', 'hasImage'], true], 2,
              3
            ],
            'circle-color': ['case',
              ['==', ['get', 'isSelected'], true], CONFIG.colors.primary,
              ['==', ['get', 'hasImage'], true], CONFIG.colors.lotMarkerWithImage,
              CONFIG.colors.brown
            ],
            'circle-stroke-width': ['case',
              ['==', ['get', 'isSelected'], true], 0,
              ['==', ['get', 'hasImage'], true], 1,
              0
            ],
            'circle-stroke-color': CONFIG.colors.white,
            'circle-opacity': [
              'interpolate', ['linear'], ['zoom'],
              16.0, 0,
              16.5, 1
            ],
            'circle-stroke-opacity': [
              'interpolate', ['linear'], ['zoom'],
              16.0, 0,
              16.5, 1
            ]
          }
        });

        // INVISIBLE, larger hit area for clicks
        map.addLayer({
          id: 'marbles-click-layer',
          type: 'circle',
          source: 'marbles',
          minzoom: 16,
          paint: {
            'circle-radius': 8,
            'circle-opacity': 0,
            'circle-stroke-width': 0
          }
        });

        // VIEW CONE source + layers
        console.log('üîç About to call initConeSystem, typeof:', typeof initConeSystem);
        if (typeof initConeSystem === 'undefined') {
          console.error('‚ùå ERROR: initConeSystem is not defined!');
        } else {
          initConeSystem();
        }
        // ===== üü¢ END MARBLE LAYERS =====

        // ===== üü¢ INITIALIZE 360 VIEWER SYSTEM =====
        console.log('Initializing 360 viewer system...');
        console.log('üîç typeof initializeViewer:', typeof initializeViewer);
        console.log('üîç typeof setupMapInteractions:', typeof setupMapInteractions);
        initializeViewer();
        setupMapInteractions();
        // ===== üü¢ END 360 VIEWER INIT =====

// Replace your map.on('moveend') event handler with this:
let isUserDragging = false;

map.on('dragstart', () => {
  isUserDragging = true;
});

map.on('dragend', () => {
  isUserDragging = false;
  // Only remove labels if zoom drops below threshold after user dragging
  const currentZoom = map.getZoom();
  if (currentLabeledLot && currentZoom < getMinZoomForDimensions(currentLabeledLot)) {
    removeSideLengthLabels();
  }
});

map.on('moveend', () => {
  // Only handle non-drag movements (like zoom changes)
  if (!isUserDragging) {
    const currentZoom = map.getZoom();
    if (currentLabeledLot && currentZoom < getMinZoomForDimensions(currentLabeledLot)) {
      removeSideLengthLabels();
    }
  }
});

    // Clear labels when clicking a different lot
map.on('click', 'lots-final-click', (e) => {
  if (e.features.length > 0) {
    // üî• FIX: Use feature.id directly instead of searching by name
    const newLot = lotData[e.features[0].id];

    // Always remove existing labels first
    if (currentLabeledLot) {
      removeSideLengthLabels();
    }

    // Add labels for the new lot if zoom is high enough
    const currentZoom = map.getZoom();
    if (newLot && currentZoom >= getMinZoomForDimensions(newLot)) {
      addSideLengthLabels(newLot);
    }
  }
});

    // Main map click handler
    map.on('click', (e) => {
      // Don't close if clicking inside modal
      if (e.originalEvent?.target.closest('#lotModal')) return;
  
   // Check if clicking on lots OR marbles
      const lotFeatures = map.queryRenderedFeatures(e.point, { 
        layers: ['lots-final-click'] 
      });
      
      const marbleFeatures = map.queryRenderedFeatures(e.point, { 
        layers: ['marbles-click-layer'] 
      });
      
      // If clicking on a lot while pin modal is open
      if (lotFeatures.length > 0 && document.getElementById('lotModal').classList.contains('pin-mode')) {
        const feature = lotFeatures[0];
        // üî• FIX: Use feature.id directly instead of searching by name
        const lot = lotData[feature.id];
        if (lot) {
          // Switch from pin modal to lot modal without closing
          document.getElementById('lotModal').classList.remove('pin-mode');
          openModal(lot); // This will handle the transition to lot view
          return; // Exit early
        }
      }

      // If clicking on a lot while dashboard is open
      const modal = document.getElementById('lotModal');

      if (lotFeatures.length > 0 && modal.classList.contains('info-mode') && window.isDashboardOpen) {
        const feature = lotFeatures[0];
        // üî• FIX: Use feature.id directly instead of searching by name
        const lot = lotData[feature.id];

        if (lot) {
          // Set flag FIRST to prevent ANY panning during this transition
          window.skipNextMapPan = true;

          // Reset dashboard button state
          const dashboardBtn = document.getElementById('dashboard-btn');
          const eyeOpen = document.getElementById('eye-open-icon');
          const eyeClosed = document.getElementById('eye-closed-icon');
          if (dashboardBtn) {
            dashboardBtn.classList.remove('active');
            if (eyeOpen) eyeOpen.style.display = 'none';  // Hide open eye
            if (eyeClosed) eyeClosed.style.display = 'inline-block';  // Show closed eye (dashboard hidden)
          }
          window.isDashboardOpen = false;

          // Remove active state from GLOBAL button
          const globalBtn = document.getElementById('globalDashboardButton');
          if (globalBtn) {
            console.log('  Removing GLOBAL button active state');
            globalBtn.classList.remove('active');
          }

          // Clear dashboard content from lotDetails
          const lotDetails = document.getElementById('lotDetails');
          if (lotDetails) {
            console.log('  Clearing dashboard content');
            lotDetails.classList.remove('active');
            lotDetails.innerHTML = '';
          }

          // Clear modalInfo to ensure lot list renders
          const modalInfo = document.getElementById('modalInfo');
          if (modalInfo) {
            console.log('  Clearing modalInfo');
            modalInfo.innerHTML = '';
            modalInfo.style.display = '';
            modalInfo.style.opacity = '1';
          }

          // Switch to lot list modal
          console.log('  Removing info-mode and opening lot modal');
          modal.classList.remove('info-mode');

          // Force modal to reset by temporarily hiding it
          modal.classList.remove('show');
          console.log('  Temporarily hiding modal to force reset');

          // Small delay to ensure DOM updates
          setTimeout(() => {
            console.log('  Now opening lot list modal (skipping pan - already positioned)');
            openModal(lot, 0, true); // Opens the lot list for this community, skipPan=true
          }, 10);

          return; // Exit early
        }
      }

      // Only close if clicking outside lots AND marbles AND not in POI mode
      if (lotFeatures.length === 0 && marbleFeatures.length === 0 && !window.poiModeActive) {
        // üü¢ SIMPLE FIX: Only call closeModal if modal is actually open
        const modal = document.getElementById('lotModal');
        if (modal && modal.classList.contains('show')) {
          closeModal();
        }
      }
    });

    // Add hover outline layer after lots-final source is ready
    map.addLayer({
      id: 'lots-hover-outline',
      type: 'line',
      source: 'lots-final',
      paint: {
        'line-color': resolveLotStyleColor(CONFIG, CONFIG.lotStyles.hover.outline.color),
        'line-width': lotStyleWidth(CONFIG.lotStyles.hover.outline.width),
        'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], CONFIG.lotStyles.hover.outline.opacity, 0]
      }
    });

    console.log('Ready to open initial modal, lotData:', lotData);
    openInitialLotModal();

    map.on('mousemove', 'lots-final-click', (e) => {
      // Don't override modal highlight
      if (document.getElementById('lotModal').classList.contains('show')) return;
      if (window.hoveredId !== null) {
        map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
      }
      if (e.features.length > 0) {
        window.hoveredId = e.features[0].id;
        map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: true });
      }
    });

    map.on('mouseleave', 'lots-final-click', () => {
      if (document.getElementById('lotModal').classList.contains('show')) return;
      if (window.hoveredId !== null) {
        map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
      }
      window.hoveredId = null;
    });

    // SINGLE CLICK HANDLER - REMOVED THE DUPLICATE
map.on('click', 'lots-final-click', (e) => {
  if (e.features.length === 0) return;

  // üü¢ FIX: Check if we're in 360 viewer mode and exit to list mode
  const modal = document.getElementById('lotModal');
  if (modal.classList.contains('viewer-mode')) {
    // Get the clicked lot info before closing viewer
    const feature = e.features[0];
    const lotName = feature.properties.name;
    const lot = lotData.find(l => l.name === lotName);
    
    // Get the baseIndex to scroll to
    let targetBaseIndex = null;
    if (lot) {
      targetBaseIndex = baseLots.findIndex(l => l.name === lot.name);
      // If baseLots is empty (data not loaded yet), store the lot number for later
      if (targetBaseIndex === -1 && !isDataLoaded) {
        targetBaseIndex = extractLotNumber(lot.name);
      }
    }
    
    // Close the viewer and pass the target index
    close360ViewerInModal(targetBaseIndex);
    
    e.preventDefault();
    e.originalEvent.stopPropagation();
    return; // Exit here - just close viewer and scroll to lot
  }

  // üü¢ UPDATED: Check edit mode first (now includes marble check)
  if (handleEditClick(e)) return;

  const feature = e.features[0];
  // üî• FIX: Use feature.id directly instead of searching by name
  // This ensures we get the EXACT lot that was clicked, even when duplicate lot numbers exist
  const idx = feature.id;
  const lot = lotData[idx];

  console.log('üîç CLICK DEBUG - Clicked feature id:', idx);
  console.log('üîç CLICK DEBUG - Lot:', lot?.name);

  if (!lot) {
    console.error('‚ùå CLICK DEBUG - Lot not found at index:', idx);
    return;
  }

  // Check if sold lot should be clickable based on soldLotsClickable config
  const isSoldLot = (lot.availability ?? '').toLowerCase() === 'sold';
  if (isSoldLot && CONFIG.misc && CONFIG.misc.soldLotsClickable === false) {
    console.log('üö´ Sold lot click disabled (soldLotsClickable is false)');
    return; // Don't allow clicks on sold lots when soldLotsClickable is false
  }

  // üü¢ FIX: Check if we're already in detail view
  const isInDetailView = modal.classList.contains('info-mode') && window.isDetailOpen;

  // üî• FIX: Clear hover state for ALL lots to ensure no orphaned hover states
  // This is more aggressive but guarantees clean state
  lotData.forEach((_, lotIndex) => {
    map.removeFeatureState({ source: 'lots-final', id: lotIndex }, 'hover');
  });

  window.hoveredId = null;

  // Use the correct index from the clicked feature
  if (idx !== -1) {
    map.setFeatureState({ source: 'lots-final', id: idx }, { hover: true });
    window.hoveredId = idx;
    currentLotIndex = idx;
    window.currentLotIndex = idx; // üî• FIX: Also set on window for getSelectedLot() in CYCLE AVAILABILITY

    // Force map to repaint to update lot outlines
    map.triggerRepaint();
  }

  // Remove any existing labels
  removeSideLengthLabels();

  if (isInDetailView) {
    // We're in detail view - update the current detail view with new lot
    const baseIndex = baseLots.findIndex(l => l.name === lot.name);
    if (baseIndex !== -1) {
      // Update the detail view with the new lot
      showDetailViewForLot(baseIndex + cloneCount, true); // true = isSwitchingLots
    }
  } else {
    // Check if we should skip list modal and go directly to detail view
    if (CONFIG.misc && CONFIG.misc.skipListModal) {
      // Open modal first to ensure proper initialization
      openModal(lot);
      // Then immediately show detail view (calculate baseIndex AFTER openModal filters baseLots)
      requestAnimationFrame(() => {
        const baseIndex = baseLots.findIndex(l => l.name === lot.name);
        if (baseIndex !== -1) {
          showDetailViewForLot(baseIndex + cloneCount, false);
        }
      });
    } else {
      // Normal case - open modal (shows lot-list by default)
      openModal(lot);
    }
  }

  // Add side length labels if zoom is high enough
  const currentZoom = map.getZoom();
  if (currentZoom >= getMinZoomForDimensions(lot)) {
    addSideLengthLabels(lot);
  }

  // Prevent the event from bubbling to avoid duplicate handling
  e.preventDefault();
  e.originalEvent.stopPropagation();
});


    // ===== END MAP INTERACTIONS =====

    // ===== REVEAL PINS VERY LAST =====
    if (window.__LL_PINS__?._revealMarkers) {
      console.log('Revealing photo pins LAST after everything else');
       
      window.__LL_PINS__._revealMarkers();
    }
  });
});
 
        // Add hover outline layer after lots-final source is ready
        map.addLayer({
          id: 'lots-hover-outline',
          type: 'line',
          source: 'lots-final',
          paint: {
            'line-color': resolveLotStyleColor(CONFIG, CONFIG.lotStyles.hover.outline.color),
            'line-width': lotStyleWidth(CONFIG.lotStyles.hover.outline.width),
            'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], CONFIG.lotStyles.hover.outline.opacity, 0]
          }
        });

        console.log('Ready to open initial modal, lotData:', lotData);
        openInitialLotModal();

        map.on('mousemove', 'lots-final-click', (e) => {
          // Don't override modal highlight
          if (document.getElementById('lotModal').classList.contains('show')) return;
          if (window.hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
          }
          if (e.features.length > 0) {
            window.hoveredId = e.features[0].id;
            map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: true });
          }
        });

        map.on('mouseleave', 'lots-final-click', () => {
          if (document.getElementById('lotModal').classList.contains('show')) return;
          if (window.hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
          }
          window.hoveredId = null;
        });
      }); // loadRoad callback ends
    }); // map load ends
  }); // fetch token ends

// === SIDE LENGTH LABELS ===
// Store merged segment groups for repositioning on map move
let mergedSegmentGroups = [];

function mergeSideSegments(coords) {
  const threshold = (CONFIG.misc && CONFIG.misc.dimensionMergeThreshold) || 0;

  // Build segments array
  const segments = [];
  for (let i = 0; i < coords.length - 1; i++) {
    const start = coords[i];
    const end = coords[i + 1];
    const distance = turf.distance(turf.point(start), turf.point(end), { units: 'meters' });
    segments.push({ start, end, distance });
  }

  const n = segments.length;

  // Helper: compute inner polygon angle at the shared vertex between segA and segB
  // Uses dot product with flipped B direction. Returns degrees (180 = straight, 90 = corner)
  function getInnerAngle(segA, segB) {
    const dAx = segA.end[0] - segA.start[0];
    const dAy = segA.end[1] - segA.start[1];
    const dBx = segB.start[0] - segB.end[0]; // flipped
    const dBy = segB.start[1] - segB.end[1];
    const magA = Math.sqrt(dAx * dAx + dAy * dAy);
    const magB = Math.sqrt(dBx * dBx + dBy * dBy);
    if (magA === 0 || magB === 0) return 180;
    let dot = (dAx / magA) * (dBx / magB) + (dAy / magA) * (dBy / magB);
    dot = Math.max(-1, Math.min(1, dot));
    return Math.acos(dot) * (180 / Math.PI);
  }

  // Helper: compute path-based midpoint for a group of segment indices
  function pathMidpoint(group) {
    let totalDist = 0;
    for (const idx of group) totalDist += segments[idx].distance;
    const halfDist = totalDist / 2;
    let walked = 0;
    for (const idx of group) {
      const seg = segments[idx];
      if (walked + seg.distance >= halfDist) {
        const t = (halfDist - walked) / seg.distance;
        return [
          seg.start[0] + t * (seg.end[0] - seg.start[0]),
          seg.start[1] + t * (seg.end[1] - seg.start[1])
        ];
      }
      walked += seg.distance;
    }
    const last = segments[group[group.length - 1]];
    return [(last.start[0] + last.end[0]) / 2, (last.start[1] + last.end[1]) / 2];
  }

  // No merging ‚Äî return each segment as its own group
  if (threshold <= 0 || n === 0) {
    return segments.map((seg, i) => ({
      totalDistance: seg.distance,
      midpoint: [(seg.start[0] + seg.end[0]) / 2, (seg.start[1] + seg.end[1]) / 2],
      startCoord: seg.start,
      endCoord: seg.end
    }));
  }

  // Walk segments in polygon order, merge short ones into most collinear neighbor
  const processed = new Array(n).fill(false);
  const mergedGroups = [];

  for (let i = 0; i < n; i++) {
    if (processed[i]) continue;

    if (segments[i].distance < threshold) {
      const prevIdx = (i - 1 + n) % n;
      const nextIdx = (i + 1) % n;

      const angleWithPrev = getInnerAngle(segments[prevIdx], segments[i]);
      const angleWithNext = getInnerAngle(segments[i], segments[nextIdx]);

      const devPrev = Math.abs(180 - angleWithPrev);
      const devNext = Math.abs(180 - angleWithNext);

      if (Math.abs(devPrev - devNext) < 1) {
        // Equal deviation ‚Äî don't merge, keep standalone
        mergedGroups.push([i]);
        processed[i] = true;
      } else if (devPrev < devNext) {
        // Merge with previous (more collinear)
        let found = false;
        for (const group of mergedGroups) {
          if (group.includes(prevIdx)) {
            group.push(i);
            processed[i] = true;
            found = true;
            break;
          }
        }
        if (!found) {
          mergedGroups.push([prevIdx, i]);
          processed[prevIdx] = true;
          processed[i] = true;
        }
      } else {
        // Merge with next (more collinear)
        let found = false;
        for (const group of mergedGroups) {
          if (group.includes(nextIdx)) {
            group.unshift(i);
            processed[i] = true;
            found = true;
            break;
          }
        }
        if (!found) {
          mergedGroups.push([i, nextIdx]);
          processed[i] = true;
          processed[nextIdx] = true;
        }
      }
    } else {
      mergedGroups.push([i]);
      processed[i] = true;
    }
  }

  // Ensure all segments are accounted for
  for (let i = 0; i < n; i++) {
    if (!processed[i]) mergedGroups.push([i]);
  }

  // Sort groups by first segment index to maintain polygon order
  mergedGroups.sort((a, b) => Math.min(...a) - Math.min(...b));

  // Build output with path-based midpoints
  return mergedGroups.map(group => {
    let totalDistance = 0;
    for (const idx of group) totalDistance += segments[idx].distance;
    return {
      totalDistance,
      midpoint: pathMidpoint(group),
      startCoord: segments[group[0]].start,
      endCoord: segments[group[group.length - 1]].end
    };
  });
}

function addSideLengthLabels(lot) {
  // Always remove any existing labels first
  removeSideLengthLabels();
  currentLabeledLot = lot;

  const coords = [...lot.coords];
  if (coords.length < 3) return;

  if (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1]) {
    coords.push(coords[0]);
  }

  const groups = mergeSideSegments(coords);
  mergedSegmentGroups = groups;

  groups.forEach((group, i) => {
    setTimeout(() => {
      const roundedDistance = Math.round(group.totalDistance * 2) / 2;

      const label = document.createElement('div');
      label.className = 'side-length-label';
      label.innerHTML = `${roundedDistance}<span translate="no">m</span>`;
      label.style.position = 'absolute';

      const pixelPos = map.project(group.midpoint);
      label.style.left = `${pixelPos.x}px`;
      label.style.top = `${pixelPos.y}px`;
      label.style.transform = 'translate(-50%, -50%) scale(0.4)';
      label.style.opacity = '0';
      label.style.transform = 'scale(0.4)';
      label.style.animation = 'pop-in 0.35s cubic-bezier(0.25, 1.25, 0.5, 1) forwards';

      document.getElementById('map').appendChild(label);
      requestAnimationFrame(() => label.style.opacity = '1');

      sideLengthLabels.push(label);
    }, i * 200);
  });
  map.on('move', updateSideLengthPositions);
}

function updateSideLengthPositions() {
  if (!currentLabeledLot || sideLengthLabels.length === 0) return;

  // Safety check - if labels and groups don't match, recreate
  if (sideLengthLabels.length !== mergedSegmentGroups.length) {
    removeSideLengthLabels();
    addSideLengthLabels(currentLabeledLot);
    return;
  }

  for (let i = 0; i < mergedSegmentGroups.length; i++) {
    const pixelPos = map.project(mergedSegmentGroups[i].midpoint);
    sideLengthLabels[i].style.left = `${pixelPos.x}px`;
    sideLengthLabels[i].style.top = `${pixelPos.y}px`;
  }
}

function removeSideLengthLabels() {
  // Remove all side length labels from the DOM
  sideLengthLabels.forEach(label => {
    if (label && label.parentNode) {
      label.parentNode.removeChild(label);
    }
  });
  
  // Clear the array
  sideLengthLabels = [];
  currentLabeledLot = null;
  
  // Remove the move event listener
  map.off('move', updateSideLengthPositions);
  
  // Also remove any potentially orphaned labels
  const allLabels = document.querySelectorAll('.side-length-label');
  allLabels.forEach(label => {
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }
  });
}
</script>

<script>
// LABELS: Add and animate labels layer
// Customizable label settings
const LABEL_CONFIG = {
  color: CONFIG.colors.white,      // Change color here (e.g., '${CONFIG.colors.white}f00' for yellow, '#00ff00' for green)
  width: 1,           // Change line width here (e.g., 1, 2, 3, etc.)
  opacity: 1          // Final opacity (0-1)
};

// Function to clean GeoJSON by removing duplicate consecutive points while preserving closed polylines
function cleanLabelsGeoJSON(geojson) {
  const cleaned = {
    type: geojson.type,
    features: geojson.features.map(feature => {
      const coords = feature.geometry.coordinates;

      // Check if polyline is already closed
      const first = coords[0];
      const last = coords[coords.length - 1];
      const isClosed = (first[0] === last[0] && first[1] === last[1]);

      // Remove duplicate consecutive points (except the closing point)
      const cleanedCoords = [];
      for (let i = 0; i < coords.length; i++) {
        const isDuplicate = i > 0 && coords[i][0] === coords[i-1][0] && coords[i][1] === coords[i-1][1];
        const isClosingPoint = isClosed && i === coords.length - 1;

        // Keep point if: it's the first point, not a duplicate, or it's the closing point
        if (i === 0 || !isDuplicate || isClosingPoint) {
          cleanedCoords.push(coords[i]);
        }
      }

      // Ensure polyline is closed if it wasn't already
      if (!isClosed) {
        const cleanedFirst = cleanedCoords[0];
        const cleanedLast = cleanedCoords[cleanedCoords.length - 1];
        if (cleanedFirst[0] !== cleanedLast[0] || cleanedFirst[1] !== cleanedLast[1]) {
          cleanedCoords.push([cleanedFirst[0], cleanedFirst[1]]);
        }
      }

      return {
        ...feature,
        geometry: {
          ...feature.geometry,
          coordinates: cleanedCoords
        }
      };
    })
  };

  console.log('Cleaned labels: removed duplicates and ensured closed polylines');
  return cleaned;
}

// Function to load and animate labels layer
function loadRoad(map, cb) {
  // Fetch labels from JSON file
  console.log('Loading labels from labels.json...');
  fetch('labels.json')
    .then(response => {
      console.log('Labels fetch response:', response.status);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(labelsGeojson => {
      console.log('Labels loaded:', labelsGeojson.features.length, 'features');

      // Clean the GeoJSON data
      const cleanedLabels = cleanLabelsGeoJSON(labelsGeojson);

      map.addSource('road', { type: 'geojson', data: cleanedLabels });
      map.addLayer({
        id: 'road',
        type: 'line',
        source: 'road',
        layout: {
          'visibility': window.isUserAuthenticated ? 'visible' : 'none'
        },
        paint: {
          'line-color': LABEL_CONFIG.color,
          'line-width': LABEL_CONFIG.width,
          'line-opacity': 0
        }
      });
      console.log('Labels layer added to map');

      // Only animate if user is authenticated and layer is visible
      if (window.isUserAuthenticated) {
        let start = null;
        function animate(ts) {
          if (!start) start = ts;
          let p = Math.min((ts - start) / 500, 1);
          map.setPaintProperty('road', 'line-opacity', p * LABEL_CONFIG.opacity);
          if (p < 1) requestAnimationFrame(animate);
          else cb();
        }
        requestAnimationFrame(animate);
      } else {
        cb(); // Skip animation if not authenticated
      }
    })
    .catch(error => {
      console.warn('Labels.json not found or failed to load:', error.message);
      console.log('Creating empty road layer as insertion point...');

      // Create empty road layer so it can still be used as a reference for other layers
      const emptyGeojson = { type: 'FeatureCollection', features: [] };
      map.addSource('road', { type: 'geojson', data: emptyGeojson });
      map.addLayer({
        id: 'road',
        type: 'line',
        source: 'road',
        layout: { 'visibility': 'none' },
        paint: {
          'line-color': '#000000',
          'line-width': 0,
          'line-opacity': 0
        }
      });
      console.log('Empty road layer created');
      cb(); // Continue with the rest of the map loading
    });
}
</script>

<script>
// LOT PARSING: Load and parse lot data
function loadLotsAsync(map) {
  const lotsUrl = CONFIG.data.lotsFile;
  return fetch(lotsUrl)
    .then(r => r.text())
    .then(txt => {
      lotData = parseLots(txt);
    });
}

function getDetailZoom(lot) {
  const group = getCommunityGroup(CURRENT_CLIENT, lot.fraccionamiento);
  const community = group && CONFIG.communityLogos[group];
  return (community && community.detailZoom) || 18.8;
}

function getMinZoomForDimensions(lot) {
  const group = getCommunityGroup(CURRENT_CLIENT, lot.fraccionamiento);
  const community = group && CONFIG.communityLogos[group];
  return (community && community.minZoomForDimensions) || CONFIG.misc.minZoomForDimensions;
}

function parseLots(text) {
  const lines = text.trim().split('\n');
  const lots = [], curr = null;
  let currentLot = null;

  lines.forEach(line => {
    line = line.trim();
    if (!line) return;

    if (!line.startsWith('{')) {
      if (currentLot) lots.push(currentLot);
      currentLot = { name: line, coords: [] };
    } else {
      const m = line.match(/lat:\s*([0-9.\-]+),\s*lng:\s*([0-9.\-]+)/);
      if (m && currentLot) currentLot.coords.push([+m[2], +m[1]]);
    }
  });

  if (currentLot) lots.push(currentLot);

  // ‚ûï Calculate center using Turf
  lots.forEach(lot => {
    try {
      const poly = turf.polygon([[...lot.coords, lot.coords[0]]]); // Close ring
      const center = turf.centroid(poly).geometry.coordinates;
      lot.center = center;
    } catch (err) {
      console.warn('Failed to calculate center for', lot.name, err);
      lot.center = [0, 0]; // Fallback
    }
  });

  return lots;
}
</script>

<script>
  // FETCH AVAILABILITY SUPABASE
  // Async function to fetch availability info from Supabase and attach it to lotData
  async function enrichLotsWithAvailability() {
    if (!lotData || lotData.length === 0) {
      console.warn('lotData is empty, cannot enrich availability');
      return;
    }

    if (!window.supabaseClient) {
      console.error('Supabase client not initialized yet.');
      return;
    }

    const names = lotData.map(lot => lot.name);

    console.log('üîÑ Fetching lot availability from Supabase for', names.length, 'lots');
    console.log('üîç First 20 lot names expected by frontend:', names.slice(0, 20));
    console.log('üîç Last 20 lot names expected by frontend:', names.slice(-20));

    try {
      // Fetch all lots using pagination to bypass Supabase's 1000-row hard limit
      // Note: Supabase has a hard limit of 1000 rows per request regardless of .limit() value
      const BATCH_SIZE = 1000;
      let allLots = [];
      let start = 0;
      let hasMore = true;

      while (hasMore) {
        const { data: batch, error } = await window.supabaseClient
          .from('lots')
          .select('lot_name, availability, rSize, millones, fraccionamiento, price_m2, nickname, subtitle, image')
          .eq('client_id', CURRENT_CLIENT)
          .range(start, start + BATCH_SIZE - 1);

        if (error) {
          console.error('‚ùå ERROR fetching lot batch from Supabase:', error);
          console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            details: error.details,
            hint: error.hint
          });

          // Check if user is authenticated
          const { data: { session } } = await window.supabaseClient.auth.getSession();
          if (!session || !session.user) {
            console.error('‚ùå User is NOT authenticated - this may be why the query failed');
          } else {
            console.log('‚úÖ User IS authenticated:', session.user.email);
            console.error('‚ùå Query failed despite authentication - check RLS policies or indexes');
          }
          return;
        }

        if (batch && batch.length > 0) {
          allLots = [...allLots, ...batch];
          start += BATCH_SIZE;
          // If we got less than a full batch, we're done
          hasMore = batch.length === BATCH_SIZE;
        } else {
          hasMore = false;
        }
      }

      const data = allLots;
      console.log('‚úÖ Successfully fetched', data?.length || 0, 'lots from Supabase');

      if (data && data.length > 0) {
        // Track which lots were found in DB
        const fetchedLotNames = new Set(data.map(row => row.lot_name));

        // DEBUG: Show what lot names are actually in the database
        const dbLotNames = data.map(row => row.lot_name).sort();
        console.log('üîç First 20 lot names in database:', dbLotNames.slice(0, 20));
        console.log('üîç Last 20 lot names in database:', dbLotNames.slice(-20));

        data.forEach(row => {
          const lot = lotData.find(l => l.name === row.lot_name);
          if (lot) {
            const raw = row.availability ?? 'Available';        // preserve title case if you want it in DB
            lot.availability = raw;                             // e.g. "Available", "Sold", "Featured"
            lot.featured = raw.toLowerCase() === 'featured';    // keep a boolean too (for legacy paths)
            lot.rSize = row.rSize;
            lot.millones = row.millones;
            lot.fraccionamiento = row.fraccionamiento;          // Add fraccionamiento data
            lot.price_m2 = row.price_m2;                        // Keep snake_case for DB
            lot.priceM2 = row.price_m2;                         // Also add camelCase for consistency
            lot.nickname = row.nickname;                        // Add modal detail fields
            lot.subtitle = row.subtitle;
            lot.image = row.image;
          }
        });

        // Find lots that weren't returned by the query
        const missingLots = lotData
          .filter(lot => !fetchedLotNames.has(lot.name))
          .map(lot => lot.name);

        if (missingLots.length > 0) {
          console.warn(`‚ö†Ô∏è ${missingLots.length} lots were NOT returned by Supabase query:`, missingLots.slice(0, 20));
          console.warn('First missing lot:', missingLots[0]);
          console.warn('Last missing lot:', missingLots[missingLots.length - 1]);

          // Analyze missing lots by type for MZ 10-17 (dynamic for all prefix types)
          const prefixes = CONFIG.lotPrefixes;

          // Analyze each prefix type (excluding 'base' which is not a lot type)
          Object.entries(prefixes).forEach(([prefixType, prefixValue]) => {
            if (prefixType === 'base') return; // Skip 'base' prefix

            const pattern = new RegExp(`^${prefixValue}(10|11|12|13|14|15|16|17)-`);
            const missingForPrefix = missingLots.filter(name => pattern.test(name));

            if (missingForPrefix.length > 0) {
              console.warn(`üî¥ Missing ${missingForPrefix.length} ${prefixValue} (${prefixType}) lots for MZ 10-17:`, missingForPrefix.slice(0, 10));
            }
          });
        }

        console.log('Lot data enriched with availability and fraccionamiento:', lotData);

        // Transform lotData ‚Üí baseLots for modal use
        transformLotDataToBaseLots();
      } else {
        console.warn('No availability data returned for lots');
      }
    } catch (error) {
      console.error('‚ùå Exception fetching lots:', error);
    }
  }

  // Transform lotData into baseLots format for modal
  function transformLotDataToBaseLots() {
    baseLots = lotData.map(lot => ({
      name: lot.name,
      number: extractLotNumber(lot.name),
      size: lot.rSize,
      price: lot.millones,
      availability: lot.availability,
      fraccionamiento: lot.fraccionamiento,
      priceM2: lot.priceM2 || lot.price_m2,
      detailData: {
        nickname: lot.nickname,
        subtitle: lot.subtitle,
        image: lot.image
      }
    }));

    // Store full list for filtering
    window.baseLotsAll = baseLots.slice();
    console.log('‚úÖ Transformed lotData ‚Üí baseLots:', baseLots.length, 'lots');
  }
</script>

<script>
// ========== DRAW X ON SOLD LOTS ==========
function addSoldXs(map, soldLots, fadeDuration = 500) {
  // Skip if xMark is disabled in config
  if (!CONFIG.lotStyles.sold.xMark.enabled) return;

  if (!map.getSource('sold-x')) {
    map.addSource('sold-x', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });

    map.addLayer({
      id: 'sold-x-layer',
      type: 'line',
      source: 'sold-x',
      layout: {},
      paint: {
        'line-color': resolveLotStyleColor(CONFIG, CONFIG.lotStyles.sold.xMark.color),
        'line-width': CONFIG.lotStyles.sold.xMark.width,
        'line-opacity': 0,
        'line-opacity-transition': { duration: fadeDuration }
      }
    });
  }

  const newFeatures = soldLots.flatMap(makeXFeatures);

  // Merge with existing features
  const source = map.getSource('sold-x');
  const current = source._data?.features || [];
  const updated = [...current, ...newFeatures];

  source.setData({ type: 'FeatureCollection', features: updated });

  // ‚è≥ Fade in after tiny delay to ensure features are added first
  setTimeout(() => {
    map.setPaintProperty('sold-x-layer', 'line-opacity', CONFIG.lotStyles.sold.xMark.opacity);
  }, 10);
}

function makeXFeatures(lot) {
  const coords = lot.coords;
  if (!coords || coords.length < 3) return [];

  // Ensure polygon is not closed twice
  if (
    coords[0][0] === coords[coords.length - 1][0] &&
    coords[0][1] === coords[coords.length - 1][1]
  ) {
    coords.pop();
  }

  const n = coords.length;
  if (n === 4) {
    return [
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[0], coords[2]] }
      },
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[1], coords[3]] }
      }
    ];
  }

  function distance(p1, p2) {
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  let maxDistance = 0;
  let farthestPair = [];
  let secondMaxDistance = 0;
  let secondFarthestPair = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      const dist = distance(coords[i], coords[j]);
      if (dist > maxDistance) {
        secondMaxDistance = maxDistance;
        secondFarthestPair = [...farthestPair];
        maxDistance = dist;
        farthestPair = [coords[i], coords[j]];
      } else if (dist > secondMaxDistance) {
        secondMaxDistance = dist;
        secondFarthestPair = [coords[i], coords[j]];
      }
    }
  }

  const threshold = 0.000038;
  function isTooClose(p, a, b) {
    return distance(p, a) < threshold || distance(p, b) < threshold;
  }

  let secondMaxDistanceCheck = 0;
  let secondFarthestPairCheck = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      if (
        coords[i] === farthestPair[0] || coords[i] === farthestPair[1] ||
        coords[j] === farthestPair[0] || coords[j] === farthestPair[1]
      ) continue;
      if (
        isTooClose(coords[i], farthestPair[0], farthestPair[1]) ||
        isTooClose(coords[j], farthestPair[0], farthestPair[1])
      ) continue;

      const dist = distance(coords[i], coords[j]);
      if (dist > secondMaxDistanceCheck) {
        secondMaxDistanceCheck = dist;
        secondFarthestPairCheck = [coords[i], coords[j]];
      }
    }
  }

  const features = [
    {
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: farthestPair }
    }
  ];

  if (secondFarthestPairCheck.length === 2) {
    features.push({
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: secondFarthestPairCheck }
    });
  }

  return features;
}
</script>

<script>
// LOT ANIMATION: Animate the appearance of lots
function animateLots(map, cb) { 
  const groups = 20,
    delay = 80,
    duration = 250,
    finalDelay = 200; 
  const fadeDuration = 500;
  const fadeDurationXs = 1500; 

  // Shuffle lots
  const shuffled = [...Array(lotData.length).keys()];
  shuffle(shuffled);

  // Divide into groups
  const groupArr = Array.from({ length: groups }, () => []);
  shuffled.forEach((i, idx) => groupArr[idx % groups].push(i));

  // Render each group with fade-in animation
  groupArr.forEach((g, i) => {
    const geojson = {
      type: "FeatureCollection",
      features: g.map((idx) => lotFeature(lotData[idx], idx)),
    };
    map.addSource(`lot-group-${i}`, { type: "geojson", data: geojson });
    
    // Add BOTH layers for this group
    map.addLayer({
      id: `lot-group-${i}-available`,
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.available.outline.color),
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
      filter: ["!=", ["get", "availability"], "Sold"]
    });

    map.addLayer({
      id: `lot-group-${i}-sold`,
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.sold.outline.color),
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
      filter: ["==", ["get", "availability"], "Sold"]
    });
    
    setTimeout(() => {
      // Fade in BOTH layers for this group
      map.setPaintProperty(`lot-group-${i}-available`, "line-opacity", 1);
      map.setPaintProperty(`lot-group-${i}-sold`, "line-opacity", 0.24); // ‚¨ÖÔ∏è 0.24 for group layer
      
      // Draw Xs for sold lots in this group
      const soldInGroup = g
        .map(idx => lotData[idx])
        .filter(lot => (lot.availability ?? '').toLowerCase() === 'sold');
      
      if (soldInGroup.length > 0) {
        addSoldXs(map, soldInGroup, fadeDurationXs);
      }
    }, i * delay);
  });

  // Add final lots layer (initially transparent but visible)
  const finalGeojson = {
    type: "FeatureCollection",
    features: lotData.map((lot, i) => lotFeature(lot, i))
  };
  map.addSource("lots-final", { type: "geojson", data: finalGeojson });

  // Create separate source for lot labels with fixed Point geometries
  const labelGeojson = {
    type: "FeatureCollection",
    features: lotData.map((lot, i) => {
      const feature = lotFeature(lot, i);
      const coords = [feature.properties.centroidLng, feature.properties.centroidLat];

      // Debug: log first 3 labels
      if (i < 3) {
        console.log(`Label ${i}: ${feature.properties.lotLabel} at [${coords[0].toFixed(6)}, ${coords[1].toFixed(6)}]`);
      }

      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: coords
        },
        properties: {
          lotLabel: feature.properties.lotLabel,
          lotName: feature.properties.name // Add for debugging
        },
        id: i
      };
    })
  };
  map.addSource("lot-labels-source", { type: "geojson", data: labelGeojson });
  console.log(`‚úÖ Created ${labelGeojson.features.length} lot label points`);

  // Create TWO separate layers instead of one
  map.addLayer({
    id: "lots-final-available",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.available.outline.color),
      "line-width": lotStyleWidth(CONFIG.lotStyles.available.outline.width),
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
    filter: ["!=", ["get", "availability"], "Sold"] // Show only available lots
  });

  map.addLayer({
    id: "lots-final-sold",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.sold.outline.color),
      "line-width": lotStyleWidth(CONFIG.lotStyles.sold.outline.width),
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
    filter: ["==", ["get", "availability"], "Sold"] // Show only sold lots
  });

  // Optional fill layer for available lots (only added when fill.color is set)
  if (CONFIG.lotStyles.available.fill.color) {
    map.addLayer({
      id: "lots-final-available-fill",
      type: "fill",
      source: "lots-final",
      layout: { visibility: "visible" },
      paint: {
        "fill-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.available.fill.color),
        "fill-opacity": 0,
        "fill-opacity-transition": { duration: fadeDuration },
      },
      filter: ["!=", ["get", "availability"], "Sold"]
    });
  }

  // Optional fill layer for sold lots (only added when fill.color is set)
  if (CONFIG.lotStyles.sold.fill.color) {
    map.addLayer({
      id: "lots-final-sold-fill",
      type: "fill",
      source: "lots-final",
      layout: { visibility: "visible" },
      paint: {
        "fill-color": resolveLotStyleColor(CONFIG, CONFIG.lotStyles.sold.fill.color),
        "fill-opacity": 0,
        "fill-opacity-transition": { duration: fadeDuration },
      },
      filter: ["==", ["get", "availability"], "Sold"]
    });
  }

  map.addLayer({ //HAD TO ADD THIS FOR CLICKABLE LOTS
    id: "lots-final-click",
    type: "fill",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "fill-color": CONFIG.colors.black,      // any color
      "fill-opacity": 0          // invisible
    }
  });

  // Add lot number labels at centroid (calculated once, no shifting on zoom)
  map.addLayer({
    id: "lot-labels",
    type: "symbol",
    source: "lot-labels-source", // Use separate Point source instead of polygon source
    minzoom: 17, // Only show labels when zoomed in enough
    layout: {
      "text-field": ["get", "lotLabel"],
      "text-font": [CONFIG.misc.mapboxFont, "Arial Unicode MS Regular"],
      // Scale text size based on zoom level for better proportions
      "text-size": [
        "interpolate",
        ["linear"],
        ["zoom"],
        17, 10,  // At zoom 17, text is 10px
        18, 12,  // At zoom 18, text is 12px
        19, 14,  // At zoom 19, text is 14px
        20, 16   // At zoom 20+, text is 16px
      ],
      "text-anchor": "center",
      "text-allow-overlap": true, // Always show all labels
      "text-ignore-placement": true, // Ignore collisions with other symbols
      "text-optional": false, // Labels are required, never hide them
      "text-pitch-alignment": "viewport", // Keep labels flat on screen
      "text-rotation-alignment": "viewport", // Keep labels oriented to screen
      "visibility": "visible"
    },
    paint: {
      "text-color": CONFIG.colors.white,
      // Fade in based on zoom level for smooth transitions
      "text-opacity": [
        "interpolate",
        ["linear"],
        ["zoom"],
        17.0, 0,   // Fully transparent at zoom 17 (matches minzoom)
        17.5, 1    // Fully visible at zoom 17.5+
      ]
    }
  });

  console.log('‚úÖ Lot labels layer created with', lotData.length, 'labels (visible at zoom 17+)');

  // After all groups have faded in & paused, fade in final lots, then fade out all groups simultaneously
  setTimeout(() => {
    // Fade in final lots - sold lots get half opacity during transition (group+final overlap)
    map.setPaintProperty("lots-final-available", "line-opacity", CONFIG.lotStyles.available.outline.opacity);
    map.setPaintProperty("lots-final-sold", "line-opacity", CONFIG.lotStyles.sold.outline.opacity * 0.51); // half during transition
    if (map.getLayer("lots-final-available-fill")) map.setPaintProperty("lots-final-available-fill", "fill-opacity", CONFIG.lotStyles.available.fill.opacity);
    if (map.getLayer("lots-final-sold-fill")) map.setPaintProperty("lots-final-sold-fill", "fill-opacity", CONFIG.lotStyles.sold.fill.opacity);
    // Labels now fade based on zoom level (see text-opacity interpolate expression)

    setTimeout(() => {
      // Fade out all lot groups simultaneously
      groupArr.forEach((_, i) => {
        const availableId = `lot-group-${i}-available`;
        const soldId = `lot-group-${i}-sold`;
        
        if (map.getLayer(availableId)) map.setPaintProperty(availableId, "line-opacity", 0);
        if (map.getLayer(soldId)) map.setPaintProperty(soldId, "line-opacity", 0);
      });

      // AFTER group layers fade out, update final sold layer to full 0.49
      setTimeout(() => {
        map.setPaintProperty("lots-final-sold", "line-opacity", CONFIG.lotStyles.sold.outline.opacity); // full opacity after groups removed
         
        // Remove all lot groups
        groupArr.forEach((_, i) => {
          const availableId = `lot-group-${i}-available`;
          const soldId = `lot-group-${i}-sold`;
          const sourceId = `lot-group-${i}`;
          
          if (map.getLayer(availableId)) map.removeLayer(availableId);
          if (map.getLayer(soldId)) map.removeLayer(soldId);
          if (map.getSource(sourceId)) map.removeSource(sourceId);
        });
        if (cb) cb();
      }, fadeDuration);
    }, finalDelay + fadeDuration);
  }, groups * delay + duration);
}

// Helpers unchanged HERE COLOR IS ADDED DEPENDING ON AVAILABILITY
function lotFeature(lot, index) {
  const c = [...lot.coords];
  if (c[0][0] !== c[c.length - 1][0] || c[0][1] !== c[c.length - 1][1]) c.push(c[0]);

  // Extract lot number (L value) from lot.name
  // Format is usually "20-10" where we want "10" (the part after the dash)
  let lotLabel = '';
  if (lot.name) {
    const parts = lot.name.split('-');
    if (parts.length >= 2) {
      // Get the last part (after the last dash) and trim any whitespace
      lotLabel = parts[parts.length - 1].trim();
    }
  }

  // Calculate label position
  // For simple polygons (4 or fewer vertices), use turf centroid
  // For complex polygons (more than 4 vertices), use bounding box center for better placement
  let labelPosition = [0, 0];
  const vertexCount = c.length - 1; // Subtract 1 because last point duplicates first

  try {
    const polygon = turf.polygon([c]);

    if (vertexCount <= 4) {
      // Simple polygon - use true centroid
      const center = turf.centroid(polygon);
      labelPosition = center.geometry.coordinates;
    } else {
      // Complex polygon - use bounding box center for better visual alignment
      const bbox = turf.bbox(polygon);
      // bbox is [minLng, minLat, maxLng, maxLat]
      labelPosition = [
        (bbox[0] + bbox[2]) / 2,  // Center longitude
        (bbox[1] + bbox[3]) / 2   // Center latitude
      ];
    }
  } catch (err) {
    console.warn('Failed to calculate label position for', lot.name, 'using simple average', err);
    // Fallback to simple average of coordinates
    let sumLng = 0, sumLat = 0;
    for (let i = 0; i < c.length - 1; i++) {
      sumLng += c[i][0];
      sumLat += c[i][1];
    }
    labelPosition = [sumLng / (c.length - 1), sumLat / (c.length - 1)];
  }

  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [c] },
    properties: {
      name: lot.name,
      availability: lot.availability || 'Available',
      lotLabel: lotLabel, // Add the extracted lot number for labeling
      centroidLng: labelPosition[0], // Store centroid coordinates
      centroidLat: labelPosition[1]
    },
    id: index
  };
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
</script>

<script>
// MANZANA LABELS - Load and display block/manzana numbers at specific coordinates
async function loadManzanaLabels(map) {
  try {
    console.log('Loading manzana labels from labels.txt...');
    const response = await fetch('labels.txt');
    if (!response.ok) {
      throw new Error(`Failed to fetch labels.txt: ${response.status}`);
    }

    const text = await response.text();
    const lines = text.split('\n').map(line => line.trim()).filter(line => line);

    const features = [];
    let currentManzana = null;

    for (const line of lines) {
      // Check if line is a number (manzana ID)
      if (/^\d+$/.test(line)) {
        currentManzana = line;
      }
      // Check if line is a coordinate object
      else if (line.includes('lat:') && line.includes('lng:')) {
        if (currentManzana) {
          // Parse coordinate: { lat: 19.047888, lng: -96.037081},
          const latMatch = line.match(/lat:\s*([-\d.]+)/);
          const lngMatch = line.match(/lng:\s*([-\d.]+)/);

          if (latMatch && lngMatch) {
            const lat = parseFloat(latMatch[1]);
            const lng = parseFloat(lngMatch[1]);

            features.push({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [lng, lat]
              },
              properties: {
                manzanaLabel: currentManzana
              }
            });
          }
        }
      }
    }

    console.log(`‚úÖ Parsed ${features.length} manzana label points`);

    // Create GeoJSON
    const manzanaGeojson = {
      type: 'FeatureCollection',
      features: features
    };

    // Add source
    map.addSource('manzana-labels-source', {
      type: 'geojson',
      data: manzanaGeojson
    });

    // Add layer
    map.addLayer({
      id: 'manzana-labels',
      type: 'symbol',
      source: 'manzana-labels-source',
      minzoom: 15, // Show earlier than lot labels since manzanas are larger areas
      layout: {
        'text-field': ['get', 'manzanaLabel'],
        'text-font': [CONFIG.misc.mapboxFont, 'Arial Unicode MS Regular'],
        'text-size': [
          'interpolate',
          ['linear'],
          ['zoom'],
          15, 14,  // At zoom 15, text is 14px
          16, 16,  // At zoom 16, text is 16px
          17, 18,  // At zoom 17, text is 18px
          18, 20   // At zoom 18+, text is 20px
        ],
        'text-anchor': 'center',
        'text-allow-overlap': true,
        'text-ignore-placement': true,
        'text-optional': false,
        'text-pitch-alignment': 'viewport',
        'text-rotation-alignment': 'viewport',
        'visibility': 'visible'
      },
      paint: {
        'text-color': CONFIG.colors.white,
        'text-halo-color': CONFIG.colors.textHalo,
        'text-halo-width': 1,
        'text-opacity': [
          'interpolate',
          ['linear'],
          ['zoom'],
          15.0, 0,   // Fully transparent at zoom 15
          15.5, 1    // Fully visible at zoom 15.5+
        ]
      }
    });

    console.log('‚úÖ Manzana labels layer created');
  } catch (error) {
    console.warn('Failed to load manzana labels:', error.message);
  }
}
</script>

<script>
// DRONE IMAGE - Add custom recent drone satellite images as raster layers
function addCustomImage(map) {
  // Use aerial images config from CONFIG
  const images = CONFIG.aerialImages || [];

  images.forEach((config, index) => {
    // Remove existing layers/sources if they exist
    if (map.getLayer(config.layerId)) {
      map.removeLayer(config.layerId);
    }
    if (map.getSource(config.sourceId)) {
      map.removeSource(config.sourceId);
    }

    map.addSource(config.sourceId, {
      type: 'image',
      url: config.url,
      coordinates: config.bounds
    });

    map.addLayer({
      id: config.layerId,
      type: 'raster',
      source: config.sourceId,
      paint: {
        'raster-opacity': 0
      }
    }, 'road'); // Insert before 'road' layer so drone images appear underneath lots

    fadeInImage(map, config.layerId);

    // Only show toaster for the first image
    if (index === 0) {
      showToaster(config.message);
    }
  });
}

//CTA
function showCta(message = "Want more info about this lot?", duration = 5000) {
  const ctaToaster = document.getElementById('ctaToaster');
  ctaToaster.classList.remove('hidden');
  ctaToaster.textContent = message;
  ctaToaster.classList.add('show');
 
  setTimeout(() => {
    ctaToaster.classList.remove('show');
    setTimeout(() => ctaToaster.classList.add('hidden'), 400); // Wait for fade out
  }, duration);
}
 
// Fade-in effect for the image (opacity increases gradually from 0 to 1)
function fadeInImage(map, layerId) {
  let opacity = 0;
  const interval = setInterval(() => {
    opacity += 0.05;  // Increase opacity gradually
    if (opacity >= 1) {
      opacity = 1;
      clearInterval(interval); // Stop once opacity reaches 1
    }
    map.setPaintProperty(layerId, 'raster-opacity', opacity);
  }, 50); // Adjust the interval for smoother or faster fade-in
}

function showToaster(message, duration = 3000) {
  const toaster = document.getElementById('toaster');
  toaster.textContent = message;
  toaster.classList.add('show');

  setTimeout(() => {
    toaster.classList.remove('show');
  }, duration);
} 
</script> 

<script>
// === FEATURED LOT POLYGON PULSE (ASYNC) ===

// Utility to create a polygon feature from a lot
function featuredPolygonFeature(lot) {
  const coords = [...lot.coords];
  if (
    coords.length < 3 ||
    coords[0][0] !== coords[coords.length - 1][0] ||
    coords[0][1] !== coords[coords.length - 1][1]
  ) {
    coords.push(coords[0]); // Ensure closed polygon
  }

  return {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [coords]
    },
    properties: {
      name: lot.name,
      phase: Math.random() * Math.PI * 2, // ‚úÖ random delay per lot
      opacity: 0.5 // initial value for fill-opacity
    }
  };
}

// Main function ‚Äî still named as requested
// In the addFeaturedLotsLayer function, update the layer insertion point:
function addFeaturedLotsLayer(map, onComplete) {
  const featuredLots = lotData.filter(lot => lot.featured);
  if (featuredLots.length === 0) {
    if (onComplete) onComplete();
    return;
  }

  const features = featuredLots.map(featuredPolygonFeature);

  map.addSource('featured-lots', {
    type: 'geojson',
    data: {
      type: 'FeatureCollection',
      features
    }
  });

  // Featured fill with pulsating opacity - insert above lots-final-available
  map.addLayer({
    id: 'featured-lots-layer',
    type: 'fill',
    source: 'featured-lots',
    paint: {
      'fill-color': resolveLotStyleColor(CONFIG, CONFIG.lotStyles.featured.fill.color),
      'fill-opacity': ['get', 'opacity']
    }
  }, 'lots-final-available'); // ‚Üê CHANGED FROM 'lots-final' to 'lots-final-available'

  // Get the list of all layers
  const layers = map.getStyle().layers;
  let insertBefore = null;

  // Find the correct layer to insert before
  for (let i = 0; i < layers.length; i++) {
    if (layers[i].id === 'sold-x-layer') {
      insertBefore = layers[i + 1]?.id || null;
      break;
    }
  }

  // Add the featured outline above lots-final-click
  map.addLayer({
    id: 'featured-lots-outline',
    type: 'line',
    source: 'featured-lots',
    paint: {
      'line-color': resolveLotStyleColor(CONFIG, CONFIG.lotStyles.featured.outline.color),
      'line-width': CONFIG.lotStyles.featured.outline.width,
      'line-opacity': CONFIG.lotStyles.featured.outline.opacity
    }
  }, 'lots-final-click');  
  
  // Start animation with completion callback 
  startPolygonPulse(map, onComplete); 
}




// Animate each polygon's opacity independently
function startPolygonPulse(map, onComplete) {
  let t = 0;
  let initialPulseCompleted = false;
  const PULSE_DURATION = 2.0; // seconds
  const _pulseOp = CONFIG.lotStyles.featured.fill.opacity;
  const _pulseBase = Array.isArray(_pulseOp) ? _pulseOp[0] : _pulseOp;
  const _pulseAmp  = Array.isArray(_pulseOp) ? _pulseOp[1] : 0;

  function frame() {
    t += 0.05; // SLOWER: was 0.05, now 0.02 for slower animation

    const source = map.getSource('featured-lots');
    if (!source || !source._data) return;

    const updated = {
      ...source._data,
      features: source._data.features.map(f => {
        const phase = f.properties?.phase ?? 0;
        const opacity = _pulseBase + Math.sin(t + phase) * _pulseAmp;
        return {
          ...f,
          properties: {
            ...f.properties,
            opacity
          }
        };
      })
    };

    source.setData(updated);
    
    // Call completion callback after initial pulse duration
    if (!initialPulseCompleted && t >= PULSE_DURATION) {
      initialPulseCompleted = true;
      if (onComplete && typeof onComplete === 'function') {
        onComplete();
      }
    }
    
    requestAnimationFrame(frame); 
  }

  requestAnimationFrame(frame);
}

// ===== SAVED LOTS LAYER (for leads) =====
function savedPolygonFeature(lot) {
  const coords = [...lot.coords];
  if (
    coords.length < 3 ||
    coords[0][0] !== coords[coords.length - 1][0] ||
    coords[0][1] !== coords[coords.length - 1][1]
  ) {
    coords.push(coords[0]); // Ensure closed polygon
  }

  return {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [coords]
    },
    properties: {
      name: lot.name,
      phase: Math.random() * Math.PI * 2,
      opacity: 0.5
    }
  };
}

function addSavedLotsLayer(map) {
  if (!window.currentLead || !window.leadSavedLots || window.leadSavedLots.size === 0) {
    return;
  }

  const savedLots = lotData.filter(lot =>
    window.leadSavedLots.has(lot.name) &&
    (lot.availability ?? '').toString().toLowerCase() !== 'sold'
  );

  if (savedLots.length === 0) return;

  const features = savedLots.map(savedPolygonFeature);

  if (map.getSource('saved-lots')) {
    map.getSource('saved-lots').setData({
      type: 'FeatureCollection',
      features
    });
    return;
  }

  map.addSource('saved-lots', {
    type: 'geojson',
    data: {
      type: 'FeatureCollection',
      features
    }
  });

  // Primary fill with pulsating opacity
  map.addLayer({
    id: 'saved-lots-layer',
    type: 'fill',
    source: 'saved-lots',
    paint: {
      'fill-color': CONFIG.colors.primary,
      'fill-opacity': ['get', 'opacity']
    }
  }, 'lots-final-available');

  // Primary color outline
  map.addLayer({
    id: 'saved-lots-outline',
    type: 'line',
    source: 'saved-lots',
    paint: {
      'line-color': CONFIG.colors.primary,
      'line-width': 2,
      'line-opacity': 1
    }
  }, 'lots-final-click');

  // Start animation
  startSavedLotsPulse(map);
}

function refreshSavedLotsLayer() {
  if (!window.map) return;

  const savedLots = lotData.filter(lot =>
    window.leadSavedLots?.has(lot.name) &&
    (lot.availability ?? '').toString().toLowerCase() !== 'sold'
  );

  const features = savedLots.map(savedPolygonFeature);

  const source = window.map.getSource('saved-lots');
  if (source) {
    source.setData({
      type: 'FeatureCollection',
      features
    });
  } else if (savedLots.length > 0) {
    addSavedLotsLayer(window.map);
  }
}

function startSavedLotsPulse(map) {
  let t = 0;

  function frame() {
    t += 0.05;

    const source = map.getSource('saved-lots');
    if (!source || !source._data) return;

    const updated = {
      ...source._data,
      features: source._data.features.map(f => {
        const phase = f.properties?.phase ?? 0;
        const opacity = 0.3 + Math.sin(t + phase) * 0.2;
        return {
          ...f,
          properties: {
            ...f.properties,
            opacity
          }
        };
      })
    };

    source.setData(updated);
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}
</script>



<script>
  // MODAL HERE
let lastOffset = [0, 0];

function adjustMapForModal() {
  if (!map) {
    console.error('Map not initialized');
    return;
  }

  // Check if we should skip panning (e.g., when coming from dashboard)
  if (window.skipNextMapPan) {
    console.log('‚è≠Ô∏è Skipping map pan (skipNextMapPan flag set)');
    window.skipNextMapPan = false;  // Reset flag
    return;
  }

  const isMobile = window.innerWidth < 768;

  const offset = isMobile
    ? [0, -window.innerHeight * 0.23] // mobile: pan upward
    : [-240, 0];                      // desktop: pan left

  lastOffset = offset;

  console.log('üîÑ map.panBy:', offset);
  map.panBy(offset, { duration: 400 });
}
 
const modal = document.getElementById('lotModal');
const modalInfo = document.getElementById('modalInfo');
const customScrollbar = document.getElementById('customScrollbar');
const customScrollthumb = document.getElementById('customScrollthumb');
const loadingSpinner = document.getElementById('loadingSpinner');
const lotDetails = document.getElementById('lotDetails');
const backButton = document.getElementById('backButton');
const detailNumber = document.getElementById('detailNumber');
const detailSize = document.getElementById('detailSize');
const detailPrice = document.getElementById('detailPrice');
const detailAvailability = document.getElementById('detailAvailability');
const headerLotNumber = document.getElementById('headerLotNumber');

//scroll thumb for info page
let infiniteScrollUpdater = null;
let infoScrollUpdater = null;

// ===== INFINITE SCROLLBAR (for lot list) =====
function enableInfiniteScrollbar() {
  console.log('Enabling INFINITE scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  const bar = document.getElementById('customScrollbar');
  const thumb = document.getElementById('customScrollthumb');

  // Clean up any existing scrollbars first
  disableInfoScrollbar();
  if (infiniteScrollUpdater) {
    disableInfiniteScrollbar();
  }

  const update = () => {
    if (!modalInfoEl || baseLots.length === 0) return;

    const containerHeight = modalInfoEl.clientHeight;
    const contentHeight = modalInfoEl.scrollHeight;
    const scrollTop = modalInfoEl.scrollTop;

    if (contentHeight === 0) {
      thumb.style.height = '0px';
      thumb.style.transform = 'translateY(0)';
      return;
    }

    const rowHeight = contentHeight / lots.length;
    const bufferHeight = rowHeight * cloneCount;
    const baseHeight = rowHeight * baseLots.length;

    const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
    thumb.style.height = `${thumbHeight}px`;

    let baseScrollTop = ((scrollTop - bufferHeight) % baseHeight);
    if (baseScrollTop < 0) baseScrollTop += baseHeight;
    baseScrollTop = Math.min(baseScrollTop, baseHeight - containerHeight);

    const scrollRatio = baseScrollTop / (baseHeight - containerHeight);
    const thumbPosition = scrollRatio * (containerHeight - thumbHeight);

    thumb.style.transform = `translateY(${thumbPosition}px)`;
  };

  infiniteScrollUpdater = update;
  
  bar.style.display = '';
  update();
  
  // Remove any existing scroll listener first
  modalInfoEl.removeEventListener('scroll', handleScroll);
  modalInfoEl.addEventListener('scroll', handleScroll);
  window.addEventListener('resize', update);
}

function disableInfiniteScrollbar() {
  console.log('Disabling INFINITE scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  if (infiniteScrollUpdater) {
    modalInfoEl.removeEventListener('scroll', handleScroll);
    window.removeEventListener('resize', infiniteScrollUpdater);
    infiniteScrollUpdater = null;
  }
}

// ===== NATURAL SCROLLBAR (for info page) =====
function enableInfoScrollbar() {
  console.log('Enabling INFO scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  const bar = document.getElementById('customScrollbar');
  const thumb = document.getElementById('customScrollthumb');

  // Clean up infinite scroll first
  disableInfiniteScrollbar();
  if (infoScrollUpdater) {
    disableInfoScrollbar();
  }

  const update = () => {
    if (!modalInfoEl) return;
    
    const H = modalInfoEl.scrollHeight;
    const h = modalInfoEl.clientHeight;
    const t = modalInfoEl.scrollTop;

    if (H <= h) {
      thumb.style.height = '0px';
      thumb.style.transform = 'translateY(0)';
      return;
    }

    const th = Math.max(20, (h / H) * h);
    const top = (t / (H - h)) * (h - th);
    thumb.style.height = `${th}px`;
    thumb.style.transform = `translateY(${top}px)`;
  };

  infoScrollUpdater = update;
  
  bar.style.display = '';
  update();
  
  // Remove any existing scroll listeners first
  modalInfoEl.removeEventListener('scroll', update);
  modalInfoEl.addEventListener('scroll', update);
  window.addEventListener('resize', update);
}

function disableInfoScrollbar() {
  console.log('Disabling INFO scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  if (infoScrollUpdater) {
    modalInfoEl.removeEventListener('scroll', infoScrollUpdater);
    window.removeEventListener('resize', infoScrollUpdater);
    infoScrollUpdater = null;
  }
}




let cloneCount = 5;
let baseLots = [];
let lots = [];
let isDataLoaded = false;
let previousMapView = null; // for "Back" button inside modal
let preModalView = null;    // for closing modal completely
let isDragging = false;
let isScrollbarDragging = false;
let dragStartY = 0;
let dragStartScroll = 0;
let scrollTimeout;
let scrollHandlerAttached = true;
let clampCooldown = false;
let infoMode = false;

function extractLotNumber(lotName) {
  // Remove client-specific lot prefixes to get clean lot number
  const prefixes = CONFIG.lotPrefixes;

  // Get all prefix values and sort by length (longest first) to handle overlapping prefixes
  // This ensures 'lotinvertasb' is matched before 'lotinverta'
  const sortedPrefixes = Object.values(prefixes).sort((a, b) => b.length - a.length);

  let cleanName = lotName;
  for (const prefix of sortedPrefixes) {
    cleanName = cleanName.replace(new RegExp(`^${prefix}`, 'i'), '');
  }

  // Also remove generic 'lot' and 'p' prefixes if still present
  return cleanName.replace(/^lot/i, '').replace(/^p/i, '');
}

async function fetchLots() {
  try {
    loadingSpinner.style.display = 'block';
    modalInfo.style.opacity = '0.5';

    // Check if baseLots already populated from map data
    if (window.baseLotsAll && window.baseLotsAll.length > 0) {
      console.log('‚úÖ Reusing existing baseLots from map data:', window.baseLotsAll.length, 'lots');
      baseLots = window.baseLotsAll.slice();
      updateLotsArray();
      isDataLoaded = true;
    } else {
      // Fallback: data not yet loaded, wait for it
      console.log('‚è≥ Waiting for map data to load...');
      await window.supabaseReady;

      // Wait a bit and check again
      let attempts = 0;
      while ((!window.baseLotsAll || window.baseLotsAll.length === 0) && attempts < 20) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }

      if (window.baseLotsAll && window.baseLotsAll.length > 0) {
        console.log('‚úÖ Map data loaded, using baseLots:', window.baseLotsAll.length, 'lots');
        baseLots = window.baseLotsAll.slice();
        updateLotsArray();
        isDataLoaded = true;
      } else {
        throw new Error('Map data not available after waiting');
      }
    }
  } catch (error) {
    console.error('Error fetching lots:', error);
    // Fallback dummy data
    baseLots = Array.from({ length: 10 }, (_, i) => ({
      number: 100 + i,
      size: '150',
      price: '1.5',
      availability: 'available',
      detailData: {
        nickname: `Lot ${100 + i}`,
        image: 'https://via.placeholder.com/800x400?text=No+Image'
      }
    }));
    updateLotsArray();
  } finally {
    loadingSpinner.style.display = 'none';
    modalInfo.style.opacity = '1';
  }
}

function updateLotsArray() {
  lots = [
    ...baseLots.slice(-cloneCount).map(l => ({ ...l, clone: true })),
    ...baseLots,
    ...baseLots.slice(0, cloneCount).map(l => ({ ...l, clone: true }))
  ];
}

function setupLotClickHandlers() {
  const allRows = document.querySelectorAll('.info-row');

  allRows.forEach(row => {
    row.addEventListener('click', async (e) => {
      // Ignore clicks on action buttons (edit, cycle)
      if (e.target.closest('.row-action-btn')) {
        return;
      }

      // Check if ANY row is being edited (not just this one)
      const editingElement = document.querySelector('[contenteditable="true"]');
      if (editingElement) {
        // Save the edit by triggering blur
        editingElement.blur();
        // Wait for save to complete
        await new Promise(resolve => setTimeout(resolve, 50));
        // Don't proceed to open detail modal after saving edit
        return;
      }

      const index = row.dataset.index;
      const lot = lots[index];
      const status = (lot.availability ?? '').toLowerCase();

      if (status === 'sold') return;

      // If a detail is already open, switch to the new lot
      if (isDetailOpen) {
        // Save the current map state before switching
        if (map && map.getCenter) {
          previousMapView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };
        }

        const lotNumber = lot.number;
        // üî• FIX: Match by BOTH number AND fraccionamiento to avoid selecting wrong lot
        const lotMapIndex = lotData.findIndex(l =>
          extractLotNumber(l.name) === lotNumber &&
          l.fraccionamiento === lot.fraccionamiento
        );

        if (lotMapIndex !== -1 && lotData[lotMapIndex].center && map) {
          const [lng, lat] = lotData[lotMapIndex].center;
          currentLotIndex = lotMapIndex;
          window.currentLotIndex = lotMapIndex;

          // Animate map to new lot
          await new Promise(resolve => {
            map.once('moveend', resolve);

            const isDesktop = window.innerWidth >= 768;
            const xOffset = isDesktop ? 310 : 0;
            const yOffset = isDesktop ? 0 : 180;

            map.easeTo({
              center: [lng, lat],
              zoom: getDetailZoom(lot),
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
          });

          // Switch to the new lot's detail view
          showDetailViewForLot(index, true);
        } else {
          // Fallback if map data isn't available
          showDetailViewForLot(index, true);
        }
        
        e.stopPropagation();
        return; // üö® CRITICAL: Exit the function here!
      }

      // Original code for when detail view is NOT open
      if (status === 'featured' || status === 'available') {
        // Save map state
        if (map && map.getCenter) {
          preModalView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };
        }

        const lotNumber = lot.number;
        // üî• FIX: Match by BOTH number AND fraccionamiento to avoid selecting wrong lot
        const lotMapIndex = lotData.findIndex(l =>
          extractLotNumber(l.name) === lotNumber &&
          l.fraccionamiento === lot.fraccionamiento
        );

        if (lotMapIndex !== -1 && lotData[lotMapIndex].center && map) {
          previousMapView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };

          const [lng, lat] = lotData[lotMapIndex].center;
          currentLotIndex = lotMapIndex;
          window.currentLotIndex = lotMapIndex;

          // 1. First start the map animation
          await new Promise(resolve => {
            map.once('moveend', resolve);

            const isDesktop = window.innerWidth >= 768;
            const xOffset = isDesktop ? 310 : 0;
            const yOffset = isDesktop ? 0 : 180;

            map.easeTo({
              center: [lng, lat],
              zoom: getDetailZoom(lot),
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
          });

          // 2. Then show detail view for the new lot
          showDetailViewForLot(index);
        } else {
          // Fallback if map data isn't available
          showDetailViewForLot(index);
        }
      }

      e.stopPropagation();
    });
  });
}



async function showDetailViewForLot(index, isSwitchingLots = false) {
  // Clear skip set when entering detail view
  if (window.skipNextRealtimeRender) window.skipNextRealtimeRender.clear();

  // Reset dashboard button state when opening a lot
  const dashboardBtn = document.getElementById('dashboard-btn');
  const eyeOpen = document.getElementById('eye-open-icon');
  const eyeClosed = document.getElementById('eye-closed-icon');
  if (dashboardBtn) {
    dashboardBtn.classList.remove('active');
    if (eyeOpen) eyeOpen.style.display = 'none';  // Hide open eye
    if (eyeClosed) eyeClosed.style.display = 'inline-block';  // Show closed eye (dashboard hidden)
  }
  window.isDashboardOpen = false;

  const modalEl        = document.getElementById('lotModal');
  const lotDetails     = document.getElementById('lotDetails');
  const calendlyEl     = document.getElementById('calendlyEmbed');
  const contentWrapper = document.querySelector('.modal-content-wrapper');
  const bottomPlusEl   = document.querySelector('.bottom-plus-button');
  const plusBtnEl      = document.querySelector('.plus-button');
  const backBtnEl      = document.getElementById('backButton');
const plusBtn = document.querySelector('.plus-button');
if (plusBtn) {
  plusBtn.style.display = 'none';
}
document.getElementById('authControls').classList.add('hide-in-detail');

  // ---- data
  const lot = lots?.[index];
  if (!lot) return;

  // Update community logo for this lot's fraccionamiento
  modalEl.dataset.fracc = lot.fraccionamiento;
  currentFraccionamiento = lot.fraccionamiento;
  if (window.updateCommunityLogo) window.updateCommunityLogo();

  const status = String(lot.availability || '').toLowerCase();
  if (status === 'sold') return;

  // üî• FIX: Match by BOTH number AND fraccionamiento to avoid selecting wrong lot
  const lotMapData = Array.isArray(lotData)
    ? lotData.find(l =>
        extractLotNumber(l.name) === lot.number &&
        l.fraccionamiento === lot.fraccionamiento
      )
    : null;



    

  const detailData = lot.detailData || {};

  // ---- prep
  window.isDetailOpen = true;
  if (calendlyEl) calendlyEl.style.display = 'none';

  // Show share button in detail mode, hide POI and GLOBAL buttons
  const shareBtn = document.getElementById('shareButton');
  if (shareBtn) shareBtn.style.display = 'block';

  const poiBtn = document.getElementById('poiButton');
  if (poiBtn) {
    poiBtn.style.display = 'none';
    // If POI mode was active, deactivate it
    if (window.poiModeActive && typeof PS !== 'undefined' && typeof PS.toggleAddMode === 'function') {
      PS.toggleAddMode();
    }
  }

  // Hide GLOBAL dashboard button in detail mode
  const globalBtn = document.getElementById('globalDashboardButton');
  if (globalBtn) globalBtn.style.display = 'none';

  // Clear only lotDetails content (but not other UI like back button)
  lotDetails.classList.remove('active');
  lotDetails.innerHTML = '';

  if (isSwitchingLots && typeof removeSideLengthLabels === 'function' && currentLabeledLot) {
    removeSideLengthLabels();
  }

  // Ensure modal is in info/detail mode
  modalEl.classList.remove('pin-mode', 'lot-mode');
  modalEl.classList.add('info-mode');

  if (bottomPlusEl) bottomPlusEl.style.display = '';
  if (plusBtnEl) plusBtnEl.style.display = '';
  if (backBtnEl) backBtnEl.style.display = 'flex';

  // ---- build
  const detailContainer = document.createElement('div');
  detailContainer.className = 'detail-container';

  // Header
  const headerSection = document.createElement('div');
  headerSection.className = 'detail-header';

  const nickname = detailData.nickname || ('');
  const subtitle = detailData.subtitle || (lotMapData?.subtitle || '');
  const isFeatured = status === 'featured';

  headerSection.innerHTML = `
    <div class="tag-row">
      ${isFeatured ? '<div class="featured-tag">SELECCI√ìN LA-LA LAND</div>' : ''}
      <div class="nickname">${nickname}</div>
    </div>
    ${subtitle ? `<div class="subtitle-row">${subtitle}</div>` : ''}
  `;
  detailContainer.appendChild(headerSection);

  // Lot name/ID row
  const detailRow = document.createElement('div');
  detailRow.className = 'detail-data-row';

  // Calculate price
  const size = cleanNumber(lot.size);
  const priceM2 = cleanNumber(lot.priceM2);
  const totalPrice = size * priceM2;

  // Format numbers with commas
  const sizeFormatted = size.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  const priceM2Formatted = priceM2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  const totalPriceFormatted = totalPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  // Get pricing config for this community
  const pricingConfig = typeof getCommunityPricing === 'function'
    ? getCommunityPricing(CURRENT_CLIENT, lot.fraccionamiento)
    : null;

  // Build plan options HTML (plan-based pricing)
  let planOptionsHtml = '';
  if (pricingConfig && pricingConfig.plans) {
    pricingConfig.plans.forEach((plan, idx) => {
      planOptionsHtml += `<option value="${idx}">${plan.name}</option>`;
    });
  }

  // Get first plan defaults for initial display
  const defaultPlan = pricingConfig && pricingConfig.plans ? pricingConfig.plans[0] : null;
  const defaultDiscountedPrice = defaultPlan ? totalPrice * (1 - defaultPlan.discount / 100) : totalPrice;
  const defaultEnganche = defaultPlan ? defaultDiscountedPrice * (defaultPlan.downPayment / 100) : 0;

  detailRow.innerHTML = `
  <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%;">
    <!-- Top row: Lot name on left, calculation centered -->
    <div style="display: flex; align-items: center; justify-content: center; width: 100%; position: relative;">
      <!-- Lot name on left (smaller, two rows) -->
      <div class="lot-left" style="position: absolute; left: 0; align-items: flex-end !important; text-align: right !important; transform: scale(0.75); transform-origin: left center;">
        <div class="lote-label">MZ-L</div>
        <div class="lote-number" style="text-align: right !important; margin-left: 0 !important;">${lot.number}</div>
      </div>

      <!-- Centered calculation -->
      <div style="font-size: 24px; color: ${CONFIG.colors.textLight};">
        ${sizeFormatted}<span style="font-size: 60%; vertical-align: super; color: ${CONFIG.colors.textTan};">M2</span>
        <span style="margin: 0 8px;">√ó</span>
        $${priceM2Formatted}<span style="font-size: 60%; vertical-align: super; color: ${CONFIG.colors.textTan};">/M2</span>
      </div>
    </div>

    <!-- Big total price with more space above -->
    <div id="bigTotalPrice" style="margin-top: 12px; font-size: 48px; font-weight: 700; color: ${CONFIG.colors.textDark};">
      $${totalPriceFormatted}<span style="font-size: 60%; vertical-align: super; font-weight: 600; color: ${CONFIG.colors.textTan};">MXN</span>
    </div>
    <div style="font-size: 13px; color: ${CONFIG.colors.textLight}; text-align: right; width: 100%; margin-top: -8px;">
      Precio del plan
    </div>
    <div style="width: 100%; height: 1px; background: ${CONFIG.colors.grayLight}; margin: 0px;"></div>

    ${pricingConfig && pricingConfig.plans ? `
    <!-- Plan-based Financing -->
    <div style="margin-top: 6px; width: 100%; display: flex; flex-direction: column; align-items: flex-start; gap: 6px; position: relative;">
      <!-- Row 1: Plan dropdown + Enganche amount -->
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="width: 110px;">
          <select id="downPaymentCalc" style="width: 110px; padding: 6px 10px; border: 2px solid ${CONFIG.colors.primary}; border-radius: 6px; font-size: 18px; font-weight: 600; color: ${CONFIG.colors.textLight}; background: white; cursor: pointer; outline: none; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif;">
            ${planOptionsHtml}
          </select>
        </div>
        <div style="font-size: 18px; color: ${CONFIG.colors.textLight};">
          Enganche: <span id="downPaymentAmount" style="color: ${CONFIG.colors.textLight};">$${defaultEnganche.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
      </div>

      <!-- Row 2: Discount display + Mensualidades -->
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="width: 110px; text-align: center; font-size: 18px; font-weight: 600; color: ${CONFIG.colors.textLight};">
          <span id="discountDisplay">${defaultPlan.discount}%</span>
        </div>
        <div style="font-size: 18px; color: ${CONFIG.colors.textLight};">
          <span id="paymentLabel">${defaultPlan.installments.count} Meses</span>: <span style="color: ${CONFIG.colors.textDark}; font-weight: 600; font-size: 22px;"><span id="monthlyPayment" style="text-decoration: underline;">$0.00</span><span id="paymentSuffix" style="font-size: 60%; vertical-align: super; font-weight: 600; color: ${CONFIG.colors.textTan};">/MES</span></span>
        </div>
      </div>

      <!-- Row 3: Descuento label + Escrituraci√≥n (conditional) -->
      <div style="width: 100%; display: flex; justify-content: space-between; margin-top: -4px; font-size: 13px; color: ${CONFIG.colors.textLight};">
        <div style="width: 110px; text-align: center;" class="descuento-label">
          <span>Descuento</span>
        </div>
        <div style="text-align: right;" id="financingInfo">
          <span>Escrituraci√≥n: <span id="financingTotalPrice">$0.00</span></span>
        </div>
      </div>
    </div>
    ` : `
    <!-- No pricing available - Contact for pricing -->
    <div style="margin-top: 12px; width: 100%; text-align: center; padding: 16px; background: ${CONFIG.colors.grayVeryLight}; border-radius: 8px;">
      <div style="font-size: 16px; color: ${CONFIG.colors.textLight};">
        Cont√°ctanos para conocer opciones de financiamiento
      </div>
    </div>
    `}
  </div>
`;

  detailContainer.appendChild(detailRow);

  // Initialize plan-based calculator (only if pricing config with plans exists)
  if (pricingConfig && pricingConfig.plans) {
    const totalPriceNum = totalPrice;
    const plans = pricingConfig.plans;

    function updatePlanCalculations() {
      const planIndex = parseInt(document.getElementById('downPaymentCalc').value);
      const plan = plans[planIndex];
      if (!plan) return;

      const discountedPrice = totalPriceNum * (1 - plan.discount / 100);
      const enganche = discountedPrice * (plan.downPayment / 100);
      const installmentTotal = discountedPrice * (plan.installments.pct / 100);
      const mensualidad = installmentTotal / plan.installments.count;
      const escrituracion = discountedPrice * (plan.escrituracion / 100);

      // Update enganche
      document.getElementById('downPaymentAmount').textContent = '$' + enganche.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

      // Update discount display ‚Äî hide when 0%
      const discountEl = document.getElementById('discountDisplay');
      discountEl.textContent = plan.discount + '%';
      discountEl.parentElement.style.visibility = plan.discount > 0 ? 'visible' : 'hidden';

      // Update mensualidades
      document.getElementById('paymentLabel').textContent = plan.installments.count + ' Meses';
      document.getElementById('monthlyPayment').textContent = '$' + mensualidad.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      document.getElementById('paymentSuffix').textContent = '/MES';

      // Update escrituraci√≥n row
      const financingInfo = document.getElementById('financingInfo');
      if (plan.escrituracion > 0) {
        financingInfo.style.visibility = 'visible';
        financingInfo.innerHTML = '<span>Escrituraci√≥n: <span id="financingTotalPrice">$' + escrituracion.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '</span></span>';
      } else {
        financingInfo.style.visibility = 'hidden';
      }

      // Update descuento label visibility
      const descuentoLabel = document.querySelector('.descuento-label');
      if (descuentoLabel) {
        descuentoLabel.style.visibility = plan.discount > 0 ? 'visible' : 'hidden';
      }

      // Update big total price to show discounted price when discount > 0
      const bigTotalPrice = document.getElementById('bigTotalPrice');
      if (bigTotalPrice) {
        bigTotalPrice.innerHTML = '$' + discountedPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + `<span style="font-size: 60%; vertical-align: super; font-weight: 600; color: ${CONFIG.colors.textTan};">MXN</span>`;
      }

    }

    // Add event listener
    setTimeout(() => {
      const urlParams = new URLSearchParams(window.location.search);
      const planParam = urlParams.get('plan');

      const planSelect = document.getElementById('downPaymentCalc');
      if (planParam !== null && planSelect) {
        planSelect.value = planParam;
      }

      planSelect?.addEventListener('change', updatePlanCalculations);
      updatePlanCalculations(); // Initial calculation
    }, 100);
  }

  // CTA Buttons Section
  const ctaSection = document.createElement('div');
  ctaSection.className = 'detail-cta-section';

  // Header labels
  const ctaHeader = document.createElement('div');
  ctaHeader.className = 'cta-header';
  ctaHeader.innerHTML = `
    <div class="cta-header-label" translate="no"></div>
    <div class="cta-header-label" translate="no"></div>
    <div class="cta-header-label" translate="no"></div>
  `;

  // Buttons row (with relative positioning for absolute child)
  const buttonsRow = document.createElement('div');
  buttonsRow.className = 'cta-buttons-row';
  buttonsRow.style.position = 'relative';
  // Show COTIZAR when authenticated OR agent, C√ìMO LLEGAR otherwise
  const isAuthenticated = window.isUserAuthenticated === true;
  const isAgent = window.isAgent === true;
  const apartarEnabled = getCommunityByFracc(CURRENT_CLIENT, lot.fraccionamiento)?.apartarEnabled === true;
  buttonsRow.innerHTML = `
    <button class="cta-button first" id="separarBtn" translate="no"${!apartarEnabled ? ' disabled style="opacity: 0.4; cursor: not-allowed;"' : ''}>APARTAR</button>
    ${(isAuthenticated || isAgent)
      ? `<button class="cta-button first" id="descargarPdfBtn" translate="no">COTIZAR</button>`
      : `<button class="cta-button first" id="visitarBtn" translate="no">C√ìMO LLEGAR</button>`
    }
    <button class="cta-button second" id="chatearBtn" translate="no">CHATEAR</button>
  `;

  // Watch availability text (absolutely positioned, centered to CHATEAR button)
  const watchAvailability = document.createElement('div');
  watchAvailability.className = 'cta-watch-availability';
  watchAvailability.innerHTML = `
    <div class="cta-header-label" translate="no" style="color:${CONFIG.colors.primary}; display:flex; align-items:center; justify-content:center; position: absolute; left: calc(100% / 6 * 5 - 8px); transform: translateX(-50%); white-space: nowrap; font-size: 11px;">
      <!-- This will be dynamically filled by updateChatHeaderVisibility() -->
      DISPONIBLE AHORA
    </div>
  `;

  ctaSection.appendChild(ctaHeader);
  ctaSection.appendChild(buttonsRow);
  ctaSection.appendChild(watchAvailability);
  detailContainer.appendChild(ctaSection);

  // Use event delegation instead of direct event listeners
  detailContainer.addEventListener('click', function(e) {
    if (e.target.id === 'separarBtn') {
      // Check if button is disabled
      if (e.target.disabled) {
        e.stopPropagation();
        return;
      }
      // Show payment view in the same modal
      e.stopPropagation();
      if (window.showPaymentViewInModal && lot) {
        window.showPaymentViewInModal(lot);
      } else {
        console.error('Payment view not available or lot data missing');
      }
    } else if (e.target.id === 'descargarPdfBtn') {
      // Generate PDF quote
      e.stopPropagation();

      // Prompt user for dynamic text
      const dynamicText = prompt('Ingrese el texto para el PDF:', 'Estimada Familia');
      if (!dynamicText) return; // User cancelled

      // Track agent quote if this is an agent
      if (window.isAgent && window.currentLead?.phone) {
        window.supabaseClient
          .from('agent_quotes')
          .insert({
            agent_phone: window.currentLead.phone,
            client_id: CURRENT_CLIENT,
            lot_name: lot?.name || null,
            lead_name: dynamicText
          })
          .then(({ error }) => {
            if (error) console.error('Error tracking agent quote:', error);
            else console.log('‚úÖ Agent quote tracked:', dynamicText);
          });
      }

      // Generate PDF if function is available
      if (lot && window.generateMultiPagePDF) {
        window.generateMultiPagePDF(lot, dynamicText, {});
      } else {
        console.error('PDF generation not available or lot data missing');
        window.showToaster?.('PDF generation not available');
      }
    } else if (e.target.id === 'visitarBtn') {
      // Open driving directions to this lot
      e.stopPropagation();

      // Use the lotMapData already calculated in showDetailViewForLot
      if (lotMapData && lotMapData.center) {
        const [lng, lat] = lotMapData.center;

        // Open in Google Maps or Apple Maps depending on device
        const isApple = /iPad|iPhone|Macintosh/.test(navigator.userAgent);
        const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving&dir_action=navigate`;
        const appleMapsUrl = `https://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
        const url = isApple ? appleMapsUrl : googleMapsUrl;
        window.open(url, '_blank');
      } else {
        window.showToaster?.('No se pudo obtener la ubicaci√≥n del lote');
        console.error('lotMapData:', lotMapData);
      }
    } else if (e.target.id === 'chatearBtn') {
      // Add your "Chatear" functionality here
      console.log('Chatear button clicked');
      // Example: open WhatsApp
      // window.open('https://wa.me/5218185261819', '_blank');
      e.stopPropagation();
    }
  });

// In showDetailViewForLot function, after creating ctaSection:
detailContainer.appendChild(ctaSection);

// Initialize chat availability features
setTimeout(() => {
  initChatAvailability();
}, 100);

  // Mount and activate
  lotDetails.appendChild(detailContainer);
  contentWrapper?.classList.add('show-details');
  lotDetails.classList.add('active');

// üîπ Show lot dimensions like before
if (lotMapData) {
  const currentZoom = map.getZoom();
  if (currentZoom >= getMinZoomForDimensions(lotMapData)) {
    if (currentLabeledLot && currentLabeledLot.name !== lotMapData.name) {
      removeSideLengthLabels();
    }
    addSideLengthLabels(lotMapData);
    currentLabeledLot = lotMapData;
  }
}

//index to scroll
  const baseIndex = baseLots.findIndex(l => l.name === lot.name);
lastOpenedBaseIndex = baseIndex;

  // Calendly hook (only if scheduleButton exists)
  const scheduleButton = document.getElementById('scheduleButton');
  if (scheduleButton) {
    scheduleButton.addEventListener('click', function () {
      lotDetails.style.display = 'none';
      if (calendlyEl) calendlyEl.style.display = 'block';
      try { loadCalendlyWidget?.({ lot, detailData: { nickname, subtitle } }); } catch (e) {}
    }, { once: true });
  }
}



backButton.addEventListener('click', () => {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  const calendly = document.getElementById('calendlyEmbed');

  // üü¢ FIX: Handle 360 viewer back navigation FIRST
  if (modal.classList.contains('viewer-mode')) {
    close360ViewerInModal();
    return;
  }

  window.isDetailOpen = false;
  removeSideLengthLabels(); // keep it

  // Hide share button when exiting detail mode
  const shareBtn = document.getElementById('shareButton');
  if (shareBtn) shareBtn.style.display = 'none';

  // Hide lock button when exiting pin mode
  const lockBtn = document.getElementById('pinLockButton');
  if (lockBtn) lockBtn.style.display = 'none';

  // If we were in Calendly, just go back to details
  if (calendly && calendly.style.display === 'block') {
    calendly.style.display = 'none';
    document.getElementById('lotDetails').style.display = 'block';
    return;
  }

  // Collapse if expanded
  if (modal.classList.contains('expanded')) {
    modal.classList.remove('expanded');
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }

  // === Return to LIST mode UI ===
  headerLotNumber.style.display = 'none';
  document.querySelector('.modal-content-wrapper').classList.remove('show-details');
  lotDetails.classList.remove('active');
  backButton.style.display = 'none';
  document.querySelector('.plus-button').style.display = 'none';
  modal.classList.add('lot-mode');
  modal.classList.remove('info-mode');

  // Recenter the list on the last opened lot (your current behavior)
  if (typeof lastOpenedBaseIndex === 'number') {
    requestAnimationFrame(() => {
      scrollToBaseIndex(lastOpenedBaseIndex, false);
    });
  }

  // === Re-arm scrolling + hover ===
  // 1) Ensure the custom (infinite) scrollbar is active again
  try {
    enableInfiniteScrollbar();   // reattach scroll -> handleScroll
  } catch {}

  // 2) Force one pass of highlight + thumb sync
  try {
    highlightCenter();           // computes centered row/lot
    updateScrollbar();
  } catch {}

// 3) Normalize map hover feature-state to match current selection
try {
  // When switching lots, the map click handler already set the correct window.hoveredId
  // so DON'T clear it! Only clear when opening fresh detail view
  if (!isSwitchingLots) {
    // Clear window.hoveredId only when NOT switching lots
    if (window.hoveredId !== null && map?.getSource('lots-final')) {
      map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
      window.hoveredId = null;
    }

    // üî• ONLY re-highlight if modal is still open (not fully closing)
    const modal = document.getElementById('lotModal');
    if (modal && modal.classList.contains('show')) {
      // Use your existing selection helpers (added later in the file)
      const sel = (typeof getSelectedLot === 'function') ? getSelectedLot() : null;
      const lotName = sel?.lotName || window.selectedLotName;
      if (lotName && map?.getSource('lots-final')) {
        const mapIndex = lotData.findIndex(l => l.name === lotName);
        if (mapIndex !== -1) {
          map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
          window.hoveredId = mapIndex;
        }
      }
    }
  }
  // When isSwitchingLots = true, window.hoveredId was already set correctly by map click handler
} catch {}

// Finally allow scroll handler to run
scrollHandlerAttached = true;

// Restore previous map view if you stored one for details
if (previousMapView && map) {
  map.flyTo({
    center: previousMapView.center,
    zoom: previousMapView.zoom,
    bearing: previousMapView.bearing,
    pitch: previousMapView.pitch,
    speed: 1.2,
    curve: 1.5
  });
  previousMapView = null;
}
});


function cleanNumber(value) {
  if (value === null || value === undefined) return 0;

  return parseFloat(
    value
      .toString()
      .replace(/,/g, '')        // remove thousand separators
      .replace(/[^0-9.]/g, '') // remove $, spaces, etc
  ) || 0;
}

function render() {
  modalInfo.innerHTML = '';
  lots.forEach((lot, i) => {
    const row = document.createElement('div');
    row.classList.add('info-row');
    row.dataset.index = i;
    row.dataset.baseIndex = lot.clone ? -1 : baseLots.findIndex(l => l.name === lot.name);

const state = (lot.availability ?? '').toString().toLowerCase();
const isFeatured  = state === 'featured';
const isAvailable = state === 'available';
const isSold      = state === 'sold';

// Calculate price: (price_m2 √ó size)
// Round to nearest thousand first, then decide unit
let calculatedPrice = lot.price;
let priceUnit = 'MIL';
if (!isSold && lot.priceM2 && lot.size) {
  const totalPrice = cleanNumber(lot.priceM2) * cleanNumber(lot.size);
  const roundedPrice = Math.round(totalPrice / 1000) * 1000;

  if (roundedPrice >= 1000000) {
    // 1 million or more: show as MDP with 2 decimals
    calculatedPrice = (roundedPrice / 1000000).toFixed(2);
    priceUnit = 'MDP';
  } else {
    // Under 1 million: show as MIL (in thousands)
    calculatedPrice = (roundedPrice / 1000).toString();
    priceUnit = 'MIL';
  }
}

// Format calculated price with commas
const calculatedPriceFormatted = calculatedPrice.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

// Format price per m2 from Supabase
const pricePerM2Formatted = isSold ? '' : (lot.priceM2 ? `$${lot.priceM2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}` : '');

    const isSaved = window.currentLead && window.leadSavedLots?.has(lot.name);
    if (isFeatured) row.classList.add('info-row--featured');
    if (isSaved && !isSold) row.classList.add('info-row--saved');

row.innerHTML = `
  <div class="lot-left">
    <div class="lote-label">MZ-L</div>
    <div class="lote-number">${lot.number}</div>
  </div>

      <div class="lot-middle ${isSold ? 'lot-middle--sold' : ''}">
        ${
          isSold
            ? `<div style="font-size:48px; font-weight:700; color:${CONFIG.colors.primary};">VENDIDO</div>`
            : `${lot.size}<span class="sup">M2</span>`
        }
      </div>

      <div class="lot-price ${isSold ? 'lot-price--hidden' : ''}">
        <div class="price-wrapper">
          <span class="price">$${calculatedPriceFormatted}</span>
          <span class="mdp">${priceUnit}</span>
        </div>
      </div>

      <div class="price-per-m2-column ${isSold ? 'lot-price--hidden' : ''}"
           contenteditable="false"
           data-price-m2="${lot.priceM2 || ''}"
           data-lot-name="${lot.name}">
        ${pricePerM2Formatted}<span class="sup">/M2</span>
      </div>

      <div class="row-actions">
        ${window.isUserAuthenticated ? `
          ${!isSold ? `
          <button class="row-action-btn edit-btn" title="Edit Price" data-lot-name="${lot.name}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
              <path d="M3 17.25V21H6.75L17.81 9.94L14.06 6.19L3 17.25ZM20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C17.98 2.9 17.35 2.9 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04Z" fill="currentColor"/>
            </svg>
          </button>
          ` : ''}
          <button class="row-action-btn cycle-btn" title="Cycle Availability" data-lot-name="${lot.name}">
            <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2">
              <path d="M23 4L23 10 17 10M1 20L1 14 7 14M3.51 9a9 9 0 0114.85-3.36L23 10M20.49 15a9 9 0 01-14.85 3.36L1 14"/>
            </svg>
          </button>
        ` : (window.currentLead && !isSold) ? `
          <button class="row-action-btn heart-btn ${window.leadSavedLots?.has(lot.name) ? 'saved' : ''}" title="Guardar" data-lot-name="${lot.name}">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="${window.leadSavedLots?.has(lot.name) ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
              <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
            </svg>
          </button>
        ` : ''}
      </div>

<div class="arrow ${isSold ? 'arrow-hidden' : ''}">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12"
       class="${(isFeatured || isAvailable) ? 'wiggle-arrow' : ''}">
    <path d="M4 3 L7 6 L4 9" stroke="${CONFIG.colors.grayMedium}" stroke-width="1" fill="none"
          stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
</div>
    `;

    if (isFeatured) {
      const left = document.createElement('div');
      left.classList.add('border-left');
      row.appendChild(left);

      const top = document.createElement('div');
      top.classList.add('border-top');
      row.appendChild(top);

      const label = document.createElement('div');
      label.classList.add('featured-label');
      label.textContent = 'SELECCI√ìN LA-LA LAND';
      row.appendChild(label);
    }

    // Add saved lot styling (similar to featured but with heart)
    if (isSaved && !isSold && !isFeatured) {
      const left = document.createElement('div');
      left.classList.add('border-left', 'border-left--saved');
      row.appendChild(left);

      const top = document.createElement('div');
      top.classList.add('border-top', 'border-top--saved');
      row.appendChild(top);

      const label = document.createElement('div');
      label.classList.add('saved-label');
      label.innerHTML = 'FAVORITO';
      row.appendChild(label);
    }

    modalInfo.appendChild(row);
  });

  setupLotClickHandlers();
  setupRowActionButtons();
  // Don't call updateScrollbar here - let the scroll handler do it after positioning
}

// Setup event listeners for row action buttons using event delegation to prevent duplicates
function setupRowActionButtons() {
  // Remove any existing delegated listeners first
  const modalInfo = document.getElementById('modalInfo');
  if (!modalInfo) return;

  // Remove old listeners by cloning and replacing (this removes ALL listeners)
  if (!window.__rowActionListenersSetup) {
    // Only set up once per page load using event delegation
    window.__rowActionListenersSetup = true;

    // Use event delegation on the parent container
    modalInfo.addEventListener('click', async (e) => {
      // Handle edit button clicks
      const editBtn = e.target.closest('.row-action-btn.edit-btn');
      if (editBtn) {
        e.stopPropagation();
        const lotName = editBtn.dataset.lotName;

        // Find the price_m2 column for this row
        const row = editBtn.closest('.info-row');
        const priceM2Column = row.querySelector('.price-per-m2-column');

        if (!priceM2Column) return;

        // If already editing, cancel
        if (priceM2Column.contentEditable === 'true') {
          priceM2Column.contentEditable = 'false';
          priceM2Column.classList.remove('editing');
          render(); // Reset display
          return;
        }

        const oldPriceM2 = priceM2Column.dataset.priceM2;
        if (!oldPriceM2) {
          showToaster('No price/m¬≤ to edit');
          return;
        }

        // Make it editable and focus
        priceM2Column.contentEditable = 'true';
        priceM2Column.classList.add('editing');
        priceM2Column.focus();

        // Select just the number part (before /M2)
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(priceM2Column.childNodes[0]);
        selection.removeAllRanges();
        selection.addRange(range);

        // Handle save on Enter or blur
        const savePriceM2 = async () => {
          // Get text and strip /M2 suffix first, then strip commas and other chars
          let newText = priceM2Column.textContent.trim();
          newText = newText.replace(/\/M2$/i, ''); // Remove /M2 suffix
          newText = newText.replace(/[^0-9.]/g, ''); // Strip all non-numeric except decimal
          const newPriceM2 = parseFloat(newText);
          const oldValue = cleanNumber(oldPriceM2);

          priceM2Column.contentEditable = 'false';
          priceM2Column.classList.remove('editing');

          if (isNaN(newPriceM2) || newPriceM2 <= 0) {
            showToaster('Invalid price');
            render(); // Reset display
            return;
          }

          if (newPriceM2 === oldValue) {
            render(); // Reset display, no change
            return;
          }

          // Show immediate feedback
          showToaster('Saving...');

          // Update all lots with this price_m2
          await updateBulkPriceM2(oldPriceM2, newPriceM2);
        };

        priceM2Column.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            savePriceM2();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            priceM2Column.contentEditable = 'false';
            priceM2Column.classList.remove('editing');
            render(); // Reset display
          }
        }, { once: true });

        priceM2Column.addEventListener('blur', savePriceM2, { once: true });
        return;
      }

      // Handle cycle availability button clicks
      const cycleBtn = e.target.closest('.row-action-btn.cycle-btn');
      if (cycleBtn) {
        e.stopPropagation();
        const lotName = cycleBtn.dataset.lotName;
        console.log('Cycle availability clicked for:', lotName);
        // Call the cycle availability function directly
        if (typeof window.cycleSelectedLotAvailability === 'function') {
          window.cycleSelectedLotAvailability();
        }
        return;
      }

      // Handle heart button clicks (save lot for leads)
      const heartBtn = e.target.closest('.row-action-btn.heart-btn');
      if (heartBtn) {
        e.stopPropagation();
        const lotName = heartBtn.dataset.lotName;

        if (!window.currentLead || !window.supabaseClient) {
          console.error('Lead not authenticated');
          return;
        }

        const isSaved = window.leadSavedLots?.has(lotName);

        try {
          if (isSaved) {
            // Remove from saved
            await window.supabaseClient
              .from('lead_saved_lots')
              .delete()
              .eq('lead_id', window.currentLead.id)
              .eq('lot_name', lotName)
              .eq('client', CURRENT_CLIENT);

            window.leadSavedLots.delete(lotName);
            heartBtn.classList.remove('saved');
            heartBtn.querySelector('svg').setAttribute('fill', 'none');
            showToaster('Removed from favorites');
          } else {
            // Add to saved
            await window.supabaseClient
              .from('lead_saved_lots')
              .insert({
                lead_id: window.currentLead.id,
                lot_name: lotName,
                client: CURRENT_CLIENT
              });

            window.leadSavedLots.add(lotName);
            heartBtn.classList.add('saved');
            heartBtn.querySelector('svg').setAttribute('fill', 'currentColor');
            showToaster('Saved to favorites');
          }

          // Refresh map layer and list
          if (typeof refreshSavedLotsLayer === 'function') refreshSavedLotsLayer();
          if (typeof render === 'function') render();
        } catch (err) {
          console.error('Error saving lot:', err);
          showToaster('Error saving');
        }
        return;
      }
    });
  }
}

// Update all lots with matching price_m2 in Supabase and locally
async function updateBulkPriceM2(oldPriceM2, newPriceM2) {
  if (!window.supabaseClient) {
    showToaster('Database not ready');
    return;
  }

  // Authentication check - trigger login if not authenticated
  const session = (await window.supabaseClient?.auth.getSession())?.data?.session;
  const isLoggedIn = !!(session && session.user);
  if (!isLoggedIn) {
    showToaster('Please login to edit prices');
    document.getElementById('globe-login-btn')?.click();
    return;
  }

  // Strip commas and parse values
  const oldValue = cleanNumber(oldPriceM2);
  const newValue = parseFloat(newPriceM2);

  console.log('updateBulkPriceM2 - oldPriceM2:', oldPriceM2, 'oldValue:', oldValue, 'newValue:', newValue);

  // Prevent bracket collision: block if new price matches another existing bracket
  const otherBracketPrices = [...new Set(
    lotData
      .filter(lot => lot.priceM2 || lot.priceM2 === 0)
      .map(lot => cleanNumber(lot.priceM2))
      .filter(p => p > 0 && Math.abs(p - oldValue) >= 0.01)
  )];
  if (otherBracketPrices.some(p => Math.abs(p - newValue) < 0.01)) {
    showToaster('Ese precio ya pertenece a otro bracket. Elige un precio diferente.');
    render();
    return;
  }

  // Find all affected lots in local data
  const affectedLots = lotData.filter(lot => {
    if (!lot.priceM2 && lot.priceM2 !== 0) return false;
    const lotPrice = cleanNumber(lot.priceM2);
    return lotPrice === oldValue;
  });

  console.log('Found', affectedLots.length, 'affected lots');

  if (affectedLots.length === 0) {
    showToaster('No lots found with this price/m¬≤');
    return;
  }

  console.log(`Updating ${affectedLots.length} lots from ${oldValue} to ${newValue}`);

  try {
    // Update all matching lots in Supabase using bulk .in() operation
    const lotNames = affectedLots.map(l => l.name);
    console.log('Lot names to update:', lotNames);
    console.log('Update query:', { price_m2: newValue, lot_names: lotNames, client_id: CURRENT_CLIENT });

    const { data, error, count } = await window.supabaseClient
      .from('lots')
      .update({ price_m2: newValue })
      .in('lot_name', lotNames)
      .eq('client_id', CURRENT_CLIENT)
      .select();

    console.log('Supabase response:', { data, error, count, rowsAffected: data?.length });

    if (error) {
      console.error('Supabase error details:', error);
      showToaster(`DB Error: ${error.message || error.code || 'Unknown'}`);
      throw error;
    }

    if (!data || data.length === 0) {
      showToaster(`‚ö†Ô∏è No rows updated. Check RLS policies?`);
      console.warn('Update returned 0 rows - possible RLS issue');
      return;
    }

    // Get authenticated user for audit
    const { data: { user } } = await window.supabaseClient.auth.getUser();
    const updatedBy = user?.email || user?.id || 'unknown';

    // Log price changes to audit table
    try {
      // For each updated lot, calculate days since last change and insert audit record
      const auditPromises = data.map(async (lot) => {
        // Get the last price change for this lot
        const { data: lastChange } = await window.supabaseClient
          .from('lot_prices_audit')
          .select('updated_at')
          .eq('lot_name', lot.lot_name)
          .order('updated_at', { ascending: false })
          .limit(1)
          .single();

        // Calculate days since last change
        let daysSinceChange = null;
        if (lastChange?.updated_at) {
          const lastDate = new Date(lastChange.updated_at);
          const now = new Date();
          daysSinceChange = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
        }

        // Insert audit record
        return window.supabaseClient
          .from('lot_prices_audit')
          .insert({
            lot_name: lot.lot_name,
            old_price: oldValue,
            new_price: newValue,
            days_since_change: daysSinceChange,
            updated_by: updatedBy
          });
      });

      await Promise.all(auditPromises);
      console.log(`‚úì Logged ${data.length} price changes to audit table`);
    } catch (auditError) {
      console.warn('Failed to log price audit:', auditError);
      // Don't fail the main operation if audit logging fails
    }

    // Show success
    showToaster(`‚úì Updated ${data.length} lot${data.length > 1 ? 's' : ''} in DB`);

    // Update local data arrays
    lotData.forEach(lot => {
      const lotPrice = cleanNumber(lot.priceM2);
      if (lotPrice === oldValue) {
        lot.priceM2 = newValue.toString();
        lot.price_m2 = newValue; // Also update snake_case version
      }
    });

    baseLots.forEach(lot => {
      const lotPrice = cleanNumber(lot.priceM2);
      if (lotPrice === oldValue) {
        lot.priceM2 = newValue.toString();
      }
    });

    lots.forEach(lot => {
      const lotPrice = cleanNumber(lot.priceM2);
      if (lotPrice === oldValue) {
        lot.priceM2 = newValue.toString();
      }
    });

    // Re-render to show updated prices
    render();
    highlightCenter();
    updateScrollbar();
  } catch (e) {
    console.error('Error updating price_m2:', e);
    showToaster(`Failed: ${e.message || 'Unknown error'}`);
    render(); // Reset display
  }
}

// ===== SIMPLIFIED updateScrollbar =====
function updateScrollbar() {
  const modal = document.getElementById('lotModal');
  
  if (modal.classList.contains('info-mode')) {
    // Info page - use natural scrollbar
    if (infoScrollUpdater) {
      infoScrollUpdater();
    } else {
      enableInfoScrollbar();
    }
  } else {
    // Lot list - use infinite scrollbar
    if (infiniteScrollUpdater) {
      infiniteScrollUpdater();
    } else {
      enableInfiniteScrollbar();
    }
  }
}

function scrollToBaseIndex(baseIndex, smooth = true) {
  if (baseLots.length === 0) return;
  
  const actualIndex = baseIndex + cloneCount;
  const target = modalInfo.querySelector(`.info-row[data-index="${actualIndex}"]`);

  if (target) {
    target.offsetWidth;
    target.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'center' });

    if (!smooth) {
      setTimeout(() => {
        highlightCenter();
        updateScrollbar();
      }, 0);
    }
  }
}

const animatedFeaturedLots = new Set();




function highlightCenter(isClamping = false) {
    // üü¢ PREVENT RE-ADDING OUTLINE WHEN MODAL IS CLOSED
  if (!document.getElementById('lotModal').classList.contains('show')) return;

  // üî• FIX: Don't run highlightCenter when in DETAIL view
  // Check if the modal-content-wrapper has 'show-details' class (indicating detail view is active)
  const wrapper = document.querySelector('.modal-content-wrapper');
  if (wrapper && wrapper.classList.contains('show-details')) {
    return;  // We're in detail view, don't auto-highlight from scroll
  }

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  
  // Get current scroll position to find which row is at the center
  const scrollTop = modalInfo.scrollTop;
  const rowHeight = modalInfo.scrollHeight / rows.length;
  
  // Find the index of the row at the center of the viewport
  const centerScrollPos = scrollTop + (modalInfo.clientHeight / 2);
  const targetCenterIndex = Math.floor(centerScrollPos / rowHeight);
  
  // Track if we're changing to a different lot
  let changingLot = false;
  let newLotMapIndex = -1;
  
  // Update classes
  rows.forEach((row, index) => {
    row.classList.remove('active', 'center');
    
    if (index === targetCenterIndex) {
      row.classList.add('active', 'center');

      if (row.classList.contains('info-row--featured')) {
        const featureIndex = row.dataset.index;
        if (!animatedFeaturedLots.has(featureIndex)) {
          void row.offsetWidth;
          row.classList.add('animate-featured');
          animatedFeaturedLots.add(featureIndex);
        } else {
          row.classList.add('animate-featured');
        }
      }

      // Animate saved lots (same as featured)
      if (row.classList.contains('info-row--saved')) {
        const savedIndex = row.dataset.index;
        if (!animatedFeaturedLots.has('saved-' + savedIndex)) {
          void row.offsetWidth;
          row.classList.add('animate-featured');
          animatedFeaturedLots.add('saved-' + savedIndex);
        } else {
          row.classList.add('animate-featured');
        }
      }

      // === Map sync logic ===
      const baseIndex = parseInt(row.dataset.baseIndex, 10);
      if (!isNaN(baseIndex)) {
        const lot = baseLots[baseIndex];
        if (lot && window.map && lotData) {
          // üî• FIX: Match by BOTH number AND fraccionamiento to avoid selecting wrong lot
          newLotMapIndex = lotData.findIndex(l =>
            extractLotNumber(l.name) === lot.number &&
            l.fraccionamiento === lot.fraccionamiento
          );
          if (newLotMapIndex !== -1) {
            if (window.hoveredId !== null && window.hoveredId !== newLotMapIndex) {
              map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
              changingLot = true; // We're changing to a different lot
            }
            map.setFeatureState({ source: 'lots-final', id: newLotMapIndex }, { hover: true });
            window.hoveredId = newLotMapIndex;
             
            // Always remove labels when changing to a different lot, regardless of detail view
            if (changingLot && currentLabeledLot) {
              // Check if we're actually switching to a different lot, not just re-highlighting the same one
              const newLot = lotData[newLotMapIndex];
              if (newLot && currentLabeledLot.name !== newLot.name) {
                removeSideLengthLabels();
              }
            }
          }
        }
      }
      // === END Map sync ===
    }
  });
}
  



// ===== FIXED clampScroll FUNCTION =====
function clampScroll() {
  const modal = document.getElementById('lotModal');
  
  // DON'T clamp if we're in info mode
  if (modal.classList.contains('info-mode')) {
    return;
  }
  
  if (baseLots.length === 0 || lots.length === 0 || clampCooldown) return;

  const { scrollTop, scrollHeight, clientHeight } = modalInfo;
  const lotHeight = scrollHeight / lots.length;
  const bufferHeight = lotHeight * cloneCount;
  const baseHeight = lotHeight * baseLots.length;

  let virtualScroll = scrollTop;
  
  if (scrollTop < bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop + baseHeight;
  } 
  else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop - baseHeight;
  }

  if (clampCooldown) {
    modalInfo.removeEventListener('scroll', handleScroll);
    modalInfo.scrollTop = virtualScroll;

    requestAnimationFrame(() => {
      highlightCenter(true);
      updateScrollbar();

      // üü¢ Call highlightCenter again after a brief delay to catch settled position
      setTimeout(() => {
        highlightCenter(true);
      }, 10);

      setTimeout(() => {
        modalInfo.addEventListener('scroll', handleScroll);
        clampCooldown = false;
      }, 50);
    });
  }
}

function stopDragging() {
  const modal = document.getElementById('lotModal');
  
  // Only apply infinite scroll snapping in LOT mode
  if (modal.classList.contains('info-mode')) {
    isDragging = false;
    isScrollbarDragging = false;
    customScrollthumb.classList.remove('active');
    modalInfo.classList.remove('dragging');
    return; // No snapping in info mode
  }
  
  if (!isDragging && !isScrollbarDragging) return;
  
  isDragging = false;
  isScrollbarDragging = false;
  customScrollthumb.classList.remove('active');
  modalInfo.classList.remove('dragging');

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;

  let closestBaseIndex = 0;
  let closestDistance = Infinity;

  rows.forEach(row => {
    if(row.dataset.baseIndex === "-1") return;
    const rect = row.getBoundingClientRect();
    const rowCenter = (rect.top + rect.bottom) / 2;
    const dist = Math.abs(rowCenter - centerY);
    if (dist < closestDistance) {
      closestDistance = dist;
      closestBaseIndex = parseInt(row.dataset.baseIndex, 10);
    }
  });

  scrollToBaseIndex(closestBaseIndex, true);
}

customScrollthumb.addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  isScrollbarDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  customScrollthumb.classList.add('active');
  
  document.addEventListener('pointermove', handleScrollDrag);
  document.addEventListener('pointerup', stopScrollDrag);
  e.preventDefault();
});

function handleScrollDrag(e) {
  if (isScrollbarDragging) {
    const deltaY = e.clientY - dragStartY;
    const scrollRatio = deltaY / modalInfo.clientHeight;
    modalInfo.scrollTop = dragStartScroll + (scrollRatio * modalInfo.scrollHeight);
  }
  e.preventDefault();
}

function stopScrollDrag() {
  if (isScrollbarDragging) {
    isScrollbarDragging = false;
    customScrollthumb.classList.remove('active');
    document.removeEventListener('pointermove', handleScrollDrag);
    document.removeEventListener('pointerup', stopScrollDrag);
    stopDragging();
  }
}

modalInfo.addEventListener('pointerdown', (e) => {
  if (e.target.closest('.custom-scrollbar')) return;
  isDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  modalInfo.classList.add('dragging');
  document.addEventListener('pointermove', handleContentDrag);
  document.addEventListener('pointerup', stopContentDrag);
  e.preventDefault();
});

function handleContentDrag(e) {

const modal = document.getElementById('lotModal');

  // Don't apply infinite scroll drag behavior in info mode
  if (modal.classList.contains('info-mode')) {
    return; // Let the browser handle natural scrolling
  }

  if (isDragging) {
    const deltaY = dragStartY - e.clientY;
    modalInfo.scrollTop = dragStartScroll + deltaY;

    const scrollTop = modalInfo.scrollTop;
    const scrollHeight = modalInfo.scrollHeight;
    const clientHeight = modalInfo.clientHeight;
    const lotHeight = scrollHeight / lots.length;
    const bufferHeight = lotHeight * cloneCount;
    const baseHeight = lotHeight * baseLots.length;

    if (scrollTop < bufferHeight) {
      modalInfo.scrollTop = scrollTop + baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    } else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
      modalInfo.scrollTop = scrollTop - baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    }
  }
  e.preventDefault();
}

function stopContentDrag() {
  if (isDragging) {
    isDragging = false;
    modalInfo.classList.remove('dragging');
    document.removeEventListener('pointermove', handleContentDrag);
    document.removeEventListener('pointerup', stopContentDrag);
    stopDragging();
  }
}

// ===== FIXED handleScroll FUNCTION =====
function handleScroll() {
  const modal = document.getElementById('lotModal');
  
  // Always update the scrollbar visual position
  updateScrollbar();
  
  // Only run infinite scroll logic for LOT mode (not info mode)
  if (modal.classList.contains('lot-mode') && scrollHandlerAttached) {
    requestAnimationFrame(() => {
      highlightCenter();
      
      if (!isDragging && !isScrollbarDragging) {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          clampScroll();
        }, 100);
      }
    });
  }
}

modalInfo.addEventListener('scroll', handleScroll);

modalInfo.addEventListener('wheel', (e) => {
  const modal = document.getElementById('lotModal');
  // Allow natural scrolling in INFO mode
  if (modal.classList.contains('info-mode')) {
    return; // Let the browser handle scrolling naturally
  }

  // Only apply infinite scroll behavior in LOT mode
  e.preventDefault();
  if(isDragging || isScrollbarDragging) return;

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;
  
  let closestRow = null;
  let minDistance = Infinity;
  
  rows.forEach(row => {
    const rect = row.getBoundingClientRect();
    const distance = Math.abs((rect.top + rect.bottom)/2 - centerY);
    if (distance < minDistance) {
      minDistance = distance;
      closestRow = row;
    }
  });

  if (!closestRow) return;
  
  const currentIndex = parseInt(closestRow.dataset.index);
  const direction = Math.sign(e.deltaY);
  let nextIndex = currentIndex + direction;

  if (nextIndex < 0) {
      nextIndex = lots.length - 1;
  } else if (nextIndex >= lots.length) {
      nextIndex = 0;
  }
  
  modalInfo.querySelector(`.info-row[data-index="${nextIndex}"]`)?.scrollIntoView({
    behavior: 'auto',
    block: 'center'
  });
});




function openModal(lot = null, baseIndex = 0, skipPan = false) {
  const modal = document.getElementById('lotModal');
  const wasHidden = !modal.classList.contains('show');

  // üü¢ FIX: Reset ALL modal modes and content areas when opening fresh
  if (wasHidden || !lot) {
    // Reset modal classes
    modal.classList.remove('pin-mode', 'info-mode', 'lot-mode', 'expanded');
    
    // Reset content areas
    const lotDetails = document.getElementById('lotDetails');
    const modalInfo = document.getElementById('modalInfo');
    const calendly = document.getElementById('calendlyEmbed');
    const viewerContainer = document.getElementById('viewer-container');
    const customScrollbar = document.getElementById('customScrollbar');
    const loadingSpinner = document.getElementById('loadingSpinner');
    
    if (lotDetails) {
      lotDetails.classList.remove('active');
      lotDetails.style.display = 'block';
      lotDetails.innerHTML = '';
    }
    
    if (modalInfo) {
      modalInfo.style.display = '';
      modalInfo.style.opacity = '1';
      modalInfo.innerHTML = ''; // Clear any existing content
    }
    
    if (calendly) calendly.style.display = 'none';
    if (viewerContainer) viewerContainer.style.display = 'none';
    if (customScrollbar) {
    customScrollbar.style.display = '';
    customScrollbar.style.visibility = '';
  }
  const customScrollthumb = document.getElementById('customScrollthumb');
  if (customScrollthumb) {
    customScrollthumb.style.display = '';
    customScrollthumb.style.visibility = '';
  }
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    
    // Reset UI controls
    const backButton = document.getElementById('backButton');
    const plusButton = document.querySelector('.plus-button');
    const bottomPlusButton = document.querySelector('.bottom-plus-button');
    const headerLotNumber = document.getElementById('headerLotNumber');
    
    if (backButton) backButton.style.display = 'none';
    if (plusButton) plusButton.style.display = 'none';
    if (bottomPlusButton) bottomPlusButton.style.display = 'none';
    if (headerLotNumber) headerLotNumber.style.display = 'none';

    // Hide lock and global buttons when opening modal (lock for pin mode only, global for dashboard only)
    const lockButton = document.getElementById('pinLockButton');
    if (lockButton) lockButton.style.display = 'none';

    const globalButton = document.getElementById('globalDashboardButton');
    if (globalButton) globalButton.style.display = 'none';

    // Reset content wrapper
    const contentWrapper = document.querySelector('.modal-content-wrapper');
    if (contentWrapper) contentWrapper.classList.remove('show-details');

    // Reset internal states
    window.isDetailOpen = false;
    scrollHandlerAttached = true;
    
    // Reset auth controls
    document.getElementById('authControls')?.classList.remove('hide-in-detail');
  }

  // Check if we're just switching lots in an already-open modal
  const isJustSwitchingLots = wasHidden === false && lot && !infoMode && !modal.classList.contains('pin-mode');
  
  // If we're in PIN mode, block only when NOT switching to Info
  const isPinMode = modal.classList.contains('pin-mode');
  if (isPinMode && !infoMode) return;
  if (isPinMode && infoMode) {
    // we are explicitly switching from pin to info
    modal.classList.remove('pin-mode');
  }

  // üî• CONSOLIDATED: Apply fraccionamiento filter function
  function applyFraccFilter(shouldRender = true) {
    try {
      // Get fracc directly from the lot data - this should work if your Supabase data is correct
      const fracc = (lot && (lot.fraccionamiento || '').toString().trim()) || CONFIG.defaultCommunity;
      
      const modalEl = document.getElementById('lotModal');
      const currentFracc = modalEl?.dataset.fracc || '';
      
      // Only re-filter if the fraccionamiento has changed
      if (fracc !== currentFracc) {
        if (modalEl) modalEl.dataset.fracc = fracc;

        // Update community logo when fracc changes
        if (typeof window.updateCommunityLogo === 'function') {
          window.updateCommunityLogo();
        }

        const headerFraccEl = document.getElementById('headerFracc');
        if (headerFraccEl) headerFraccEl.textContent = fracc ? fracc.toUpperCase() : CONFIG.name;
        if (Array.isArray(window.baseLotsAll) && window.baseLotsAll.length) {
          // Filter baseLots by fraccionamiento
          baseLots = window.baseLotsAll.filter(l => (l.fraccionamiento || '').toString().trim() === fracc);
          updateLotsArray();
          // Only re-render when requested
          if (shouldRender) {
            render();
          }
        }
      }
      if (window.resetUnitButtons) window.resetUnitButtons();
    } catch (e) {
      console.warn('Fraccionamiento filter failed:', e);
    }
  }

  // If just switching lots, handle it efficiently without resetting everything
  if (isJustSwitchingLots) {
    // ‚§µÔ∏è Apply filter FIRST when switching between different fraccionamientos
    // Use shouldRender: true to force re-render when switching communities
    applyFraccFilter(true);

    // Just scroll to the new lot after filtering
    const scrollToIndex = baseLots.findIndex(l => l.name === lot.name);
    if (scrollToIndex !== -1) {
      scrollToBaseIndex(scrollToIndex, true);
      
      // Update map highlight
      const mapIndex = lotData.findIndex(l => l.name === lot.name);
      if (mapIndex !== -1 && map) {
        if (window.hoveredId !== null) {
          map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
        }
        map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
        window.hoveredId = mapIndex;
        currentLotIndex = mapIndex;
        window.currentLotIndex = mapIndex;
      }

      // Add side length labels if zoom is high enough
      const currentZoom = map.getZoom();
      if (currentZoom >= getMinZoomForDimensions(lot)) {
        removeSideLengthLabels();
        addSideLengthLabels(lot);
      }
    }
    return; // Exit early - no need to reset the modal
  }

  document.getElementById('searchBtnStage')?.classList.add('hide');
  document.getElementById('lalalandInfoBtn')?.classList.add('hide');

  // Now show the modal
  modal.classList.add('show');
  modal.style.display = 'block';

  // Prevent button animations on initial modal open
  if (wasHidden) {
    modal.classList.add('initial-load');
    if (!skipPan) {
      adjustMapForModal();
    } else {
      console.log('‚è≠Ô∏è Skipping map pan (already positioned from dashboard)');
    }

    // Enable animations only on actual user interaction (not programmatic scrolls)
    const enableAnimations = () => {
      modal.classList.remove('initial-load');
      modal.classList.add('animations-ready');
      // Remove all listeners
      modalInfo.removeEventListener('wheel', enableAnimations);
      modalInfo.removeEventListener('touchstart', enableAnimations);
      modalInfo.removeEventListener('mousedown', enableAnimations);
    };

    // Listen for actual user interaction events
    modalInfo.addEventListener('wheel', enableAnimations, { once: true });
    modalInfo.addEventListener('touchstart', enableAnimations, { once: true });
    modalInfo.addEventListener('mousedown', enableAnimations, { once: true });
  }

  // üî∏ INFO MODE short-circuit (your existing block)
  if (infoMode) {
    modal.classList.add('expanded', 'info-mode');
    
    const modalInfoEl = document.getElementById('modalInfo');
    const customScrollbarEl = document.getElementById('customScrollbar');
    const spinnerEl = document.getElementById('loadingSpinner');
    
    modalInfoEl.innerHTML = `
      <div style="padding:20px; color:${CONFIG.colors.textLight}; height:2000px;">
        <h2 style="color:${CONFIG.colors.textBrown}; margin-bottom:10px;">Sobre Barcelona</h2>
        <p>Bienvenido a Barcelona. Aqu√≠ puedes poner descripci√≥n, ubicaci√≥n, beneficios, etc.</p>
        <p>Para m√°s informaci√≥n cont√°ctanos por WhatsApp o visita nuestras oficinas.</p>
        <div style="height:1000px; background:linear-gradient(${CONFIG.colors.grayVeryLight}, ${CONFIG.colors.grayLight});"></div>
      </div>
    `;
    customScrollbarEl.style.display = '';
    spinnerEl.style.display = 'none';
    scrollHandlerAttached = false;
    infoMode = false;

    document.getElementById('authControls').classList.remove('hide-in-detail');

    // ‚úÖ Use natural scrollbar for info page
    setTimeout(() => {
      enableInfoScrollbar();
      // Reset scroll position to top
      modalInfoEl.scrollTop = 0;
    }, 100);
    
    return;
  }

  // üëá Normal list flow
  modal.classList.add('lot-mode');
  modal.classList.remove('info-mode');

  // Reset header to current fraccionamiento (in case it was showing "PIN" or something else)
  const headerFraccEl = document.getElementById('headerFracc');
  const currentFracc = modal?.dataset?.fracc || (lot && (lot.fraccionamiento || '').toString().trim()) || CONFIG.defaultCommunity;
  if (headerFraccEl) {
    headerFraccEl.textContent = currentFracc ? currentFracc.toUpperCase() : CONFIG.name;
    // Reset header editability (in case we were viewing a pin)
    headerFraccEl.contentEditable = 'false';
    headerFraccEl.style.cursor = 'default';
    headerFraccEl.style.outline = '';
    headerFraccEl.style.borderRadius = '';
    headerFraccEl.style.padding = '';
    headerFraccEl.onblur = null;
    headerFraccEl.onkeydown = null;
  }

  const modalInfoEl = document.getElementById('modalInfo');
  const customScrollbarEl = document.getElementById('customScrollbar');
  const spinnerEl = document.getElementById('loadingSpinner');

  const doScrollAndHighlight = () => {
    const scrollToIndex = lot
      ? baseLots.findIndex(l => l.name === lot.name)
      : baseIndex;

    scrollToBaseIndex(scrollToIndex, false);
    // scrollToBaseIndex already calls highlightCenter() and updateScrollbar() when smooth=false

    // Just clean up UI
    spinnerEl.style.display = 'none';
    modalInfoEl.style.opacity = '1';
  };

  // Only fetch and render if needed
  if (!isDataLoaded) {
    fetchLots().then(() => {
      // üî• Apply filter when data is first loaded
      applyFraccFilter(false); // Don't render yet, we'll call render() below
      render();
      // ‚ö° Scroll immediately to prevent flash of wrong lot
      doScrollAndHighlight();

      // ‚ö° Wait for modal animation to complete before populating list
      setTimeout(() => {
        render();
        requestAnimationFrame(() => {
          requestAnimationFrame(doScrollAndHighlight);
        });
      }, 400); // Match modal transition duration
    });
  } else {
    // Only re-render if content was cleared (modal was hidden)
    if (wasHidden || !lot) {
      // üî• Apply filter when opening modal fresh or with new lot
      applyFraccFilter(false); // Don't render yet, we'll call render() below
      render();
      // ‚ö° Scroll immediately to prevent flash of wrong lot
      doScrollAndHighlight();

      // ‚ö° Wait for modal animation to complete before populating list
      setTimeout(() => {
        render();
        requestAnimationFrame(() => {
          requestAnimationFrame(doScrollAndHighlight);
        });
      }, 400); // Match modal transition duration
    } else {
      // Modal is already open with content - just scroll to the lot
      // üî• Apply filter but don't re-render (content is already there)
      applyFraccFilter(false);
      
      const scrollToIndex = baseLots.findIndex(l => l.name === lot.name);
      if (scrollToIndex !== -1) {
        scrollToBaseIndex(scrollToIndex, true);
        
        // Update map highlight
        const mapIndex = lotData.findIndex(l => l.name === lot.name);
        if (mapIndex !== -1 && map) {
          if (window.hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
          }
          map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
          window.hoveredId = mapIndex;
          currentLotIndex = mapIndex;
          window.currentLotIndex = mapIndex;
        }

        // Ensure UI is ready
        spinnerEl.style.display = 'none';
        modalInfoEl.style.opacity = '1';
        highlightCenter();
        updateScrollbar();
      }
    }
  }
}



function closeModal() {
  console.log('üöÄ closeModal CALLED - isDashboardOpen:', window.isDashboardOpen);

  // Don't close modal if POI mode is active
  if (window.poiModeActive) {
    console.log('‚ùå closeModal BLOCKED - POI mode is active');
    return;
  }

  const modal = document.getElementById('lotModal');
  if (!modal) return;

  // üü¢ CHECK if it's pin-mode BEFORE removing the class
  const wasPinMode = modal.classList.contains('pin-mode');

  // Clear skip set when closing modal
  if (window.skipNextRealtimeRender) window.skipNextRealtimeRender.clear();

  document.getElementById('authControls').classList.remove('hide-in-detail');
  document.getElementById('searchBtnStage')?.classList.remove('hide');
  document.getElementById('lalalandInfoBtn')?.classList.remove('hide');

  if (window.resetUnitButtons) window.resetUnitButtons();
  
  const wrapper = document.querySelector('.modal-content-wrapper');
  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');
  const lotDetails = document.getElementById('lotDetails');
  const backButton = document.getElementById('backButton');
  const headerLotNumber = document.getElementById('headerLotNumber');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  const plusBtn = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');
  
  // --- 1) Kill special modes / embeds
  modal.classList.remove('info-mode', 'pin-mode', 'expanded', 'lot-mode');
  hideCalendlyEmbed();
  window.isDetailOpen = false;

  // Hide share button when exiting detail mode
  const shareBtn = document.getElementById('shareButton');
  if (shareBtn) shareBtn.style.display = 'none';

  // Hide lock button when exiting pin mode
  const lockBtn = document.getElementById('pinLockButton');
  if (lockBtn) lockBtn.style.display = 'none';

  // Hide global dashboard button when closing modal and remove active state
  const globalBtn = document.getElementById('globalDashboardButton');
  if (globalBtn) {
    globalBtn.classList.remove('active');  // Remove underline
    globalBtn.style.display = 'none';
  }

  // Reset dashboard button state when closing modal
  const dashboardBtn = document.getElementById('dashboard-btn');
  const eyeOpen = document.getElementById('eye-open-icon');
  const eyeClosed = document.getElementById('eye-closed-icon');
  if (dashboardBtn) {
    console.log('closeModal: Resetting dashboard button state');
    dashboardBtn.classList.remove('active');
    if (eyeOpen) {
      eyeOpen.style.display = 'none';  // Hide open eye
      console.log('closeModal: Set eye-open to none');
    }
    if (eyeClosed) {
      eyeClosed.style.display = 'inline-block';  // Show closed eye (dashboard hidden)
      console.log('closeModal: Set eye-closed to inline-block');
    }
  }
  window.isDashboardOpen = false;
  console.log('closeModal: Set isDashboardOpen to false');

  // üü¢ Exit compare mode if active - SAME LOGIC AS UNSORT
  if (window.compareMode) {
    const compareBtn = document.getElementById('compareBtn');
    if (compareBtn) {
      compareBtn.classList.remove('active');
    }
    window.compareMode = false;
    window.selectedLots.clear();
    if (typeof removeEditOutlines === 'function') {
      removeEditOutlines();
    }
    console.log('Compare mode OFF (modal closed)');

    // üü¢ RESTORE from backup BEFORE clearing it
    if (window.originalBaseLots) {
      baseLots = [...window.originalBaseLots];
      window.originalBaseLots = null;
    }
  }
  
  // --- 2) Clear lot side labels
  removeSideLengthLabels();
  
  // --- 3) Reset panes (detail vs list) & content
  if (wrapper) wrapper.classList.remove('show-details');
  if (lotDetails) {
    lotDetails.classList.remove('active');
    lotDetails.style.display = 'block';
    lotDetails.innerHTML = '';
  }
  if (modalInfo) {
    modalInfo.style.display = '';
    modalInfo.style.opacity = '1';
  }
  if (customScrollbar) {
    customScrollbar.style.display = '';
    customScrollbar.style.visibility = '';
  }
  const customScrollthumb = document.getElementById('customScrollthumb');
  if (customScrollthumb) {
    customScrollthumb.style.display = '';
    customScrollthumb.style.visibility = '';
  }
  
  // --- 4) Reset controls visibility & header
  if (backButton) backButton.style.display = 'none';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  if (plusBtn) plusBtn.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';
  if (plusIcon) plusIcon.style.display = 'block';
  if (minusIcon) minusIcon.style.display = 'none';

  // Reset header text and editability (in case we were viewing a pin)
  const headerFracc = document.getElementById('headerFracc');
  if (headerFracc) {
    headerFracc.contentEditable = 'false';
    headerFracc.style.cursor = 'default';
    headerFracc.style.outline = '';
    headerFracc.style.borderRadius = '';
    headerFracc.style.padding = '';
    headerFracc.onblur = null;
    headerFracc.onkeydown = null;
  }
  
  // --- 5) Reset internal scroll/animation flags
  try { scrollHandlerAttached = true; } catch {}
  try { clampCooldown = false; } catch {}
  try { animatedFeaturedLots?.clear?.(); } catch {}
  
  // --- 6) Restore map view (undo panBy offset + preModalView fly)

  // üü¢ When closing pin modal, DON'T clear fracc - keep it set to pin location
  // üü¢ When closing lot modal, CLEAR fracc to prevent stale selection
  if (!wasPinMode && modal) {
    // Only clear fracc when closing lot modal (not pin modal)
    modal.dataset.fracc = '';

    // Hide community logo when modal closes
    if (typeof window.updateCommunityLogo === 'function') {
      window.updateCommunityLogo();
    }
  }
  // For pin mode, fracc stays set to the pin's location

  // üü¢ For pin modal, DON'T fly back to preModalView - stay at pin location
  if (wasPinMode) {
    // Just clear preModalView without flying
    preModalView = null;
    if (map && lastOffset) {
      map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 400 });
      lastOffset = [0, 0];
    }
  } else if (preModalView && map) {
    // For lot modal, fly back to previous view
    map.flyTo({
      center: preModalView.center,
      zoom: preModalView.zoom,
      bearing: preModalView.bearing,
      pitch: preModalView.pitch,
      speed: 1.2,
      curve: 1.5
    });

    map.once('moveend', () => {
      if (lastOffset) {
        map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 400 });
        lastOffset = [0, 0];
      }
    });

    preModalView = null;
  } else if (map && lastOffset) {
    map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 400 });
    lastOffset = [0, 0];
  }
  
// --- 7) Close modal (let CSS transition run)
modal.classList.remove('show');

// üü¢ Clear hover state immediately when modal closes
if (map && map.getSource('lots-final') && window.hoveredId !== null) {
  try {
    map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
    console.log('‚úÖ closeModal: Cleared hover state for lot', window.hoveredId);
  } catch (e) {
    console.log('‚ö†Ô∏è closeModal: Error clearing hover state:', e);
  }
  window.hoveredId = null;
}

setTimeout(() => {
  modal.style.display = 'none';
}, 50);
  
  disableInfiniteScrollbar();
  disableInfoScrollbar();
}


function handlePlusButton() {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  
  // Toggle expanded state
  modal.classList.toggle('expanded');
  
  // Toggle between plus and minus icon
  if (modal.classList.contains('expanded')) {
    plusIcon.style.display = 'none';
    minusIcon.style.display = 'block';
  } else {
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }
 }

function loadCalendlyWidget({ lot, detailData }) {
  const container = document.getElementById('calendlyEmbed');
  const iframe = document.getElementById('calendly-iframe');
  
  // Build the Calendly URL with all hiding parameters
  const calendlyUrl = new URL('https://calendly.com/lalaland_/santte2');
  calendlyUrl.searchParams.set('hide_gdpr_banner', '1');
  calendlyUrl.searchParams.set('background_color', 'fcfaf3');
  calendlyUrl.searchParams.set('text_color', '1a1a1a');
  calendlyUrl.searchParams.set('primary_color', 'ff8400');
  
  // Load the iframe
  iframe.src = calendlyUrl.toString();
  container.style.display = 'block';
  
}

// POI Button Management
(() => {
  // Wait for DOM and PS to be ready
  const initPOIButton = () => {
    const poiButton = document.getElementById('poiButton');
    if (!poiButton) return;

    // POI button click handler
    poiButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const PS = window.__LL_PINS__;
      if (PS && typeof PS.toggleAddMode === 'function') {
        PS.toggleAddMode();
      }
    });

    // Show POI button when modal opens in list mode (and user is authenticated)
    // Hide POI button when in detail mode
    const updatePOIVisibility = () => {
      const modal = document.getElementById('lotModal');
      if (!modal) return;

      const isModalVisible = modal.classList.contains('show');
      const isDetailMode = window.isDetailOpen === true;
      const isAuthenticated = window.isUserAuthenticated === true;

      if (isModalVisible && !isDetailMode && isAuthenticated) {
        // List mode + authenticated - show POI button
        poiButton.style.display = 'block';
      } else {
        // Detail mode or modal closed or not authenticated - hide POI button
        poiButton.style.display = 'none';

        // If POI mode was active, deactivate it
        const PS = window.__LL_PINS__;
        if (window.poiModeActive && PS && typeof PS.toggleAddMode === 'function') {
          PS.toggleAddMode();
        }
      }
    };

    const observer = new MutationObserver(updatePOIVisibility);
    const modal = document.getElementById('lotModal');
    if (modal) {
      observer.observe(modal, { attributes: true, attributeFilter: ['class'] });
    }

    // Call on page load to set initial state
    updatePOIVisibility();
  };

  // Wait for PS to be available or timeout after 5 seconds
  let attempts = 0;
  const waitForPS = setInterval(() => {
    if (window.__LL_PINS__ || attempts++ > 50) {
      clearInterval(waitForPS);
      initPOIButton();
    }
  }, 100);
})();

</script>
 
 
<script>
// RESET GPS + INFO (reusing #lotModal)
document.addEventListener('DOMContentLoaded', () => {
  const modal    = document.getElementById('lotModal');
  const resetBtn = document.getElementById('resetViewBtn');
  const lalalandBtn = document.getElementById('lalalandInfoBtn');
  const infoBtn  = document.getElementById('infoBtn'); // left orange button
  const gpsBtn   = document.getElementById('gpsButton'); 

// Open lot modal in "info mode" - attach to Lalaland button
document.getElementById('lalalandInfoBtn')?.addEventListener('click', () => {
  infoMode = true;
  document.getElementById('lotModal')?.classList.remove('pin-mode');
  openModal();

  const modal = document.getElementById('lotModal');
  modal.classList.add('info-mode');
  modal.classList.remove('lot-mode');
  modal.classList.add('expanded');

  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');
  document.getElementById('headerFracc').textContent = 'LA-LA LAND';

  modalInfo.innerHTML = `
  
<div class="faq-section">

  <h3><span class="emoji">üí®</span> ¬øQu√© tan r√°pido puedo vender con La-La Land?</h3>

 <ul>
  <li><span class="emoji">üöÄ</span> Vende <strong>hasta 30‚Äì50% m√°s r√°pido</strong> al reemplazar PDFs por experiencias interactivas.<sup>1</sup></li>
  <li><span class="emoji">üè°</span> Los desarrollos con <strong>recorridos 360¬∞</strong> y <strong>disponibilidad en tiempo real</strong> generan <strong>2√ó m√°s inter√©s</strong> de compradores.<sup>2</sup></li>
  <li><span class="emoji">üí¨</span> El <strong>77% de los compradores</strong> afirma que un tour virtual los ayud√≥ a decidirse a visitar ‚Äî decisiones m√°s r√°pidas, menos visitas desperdiciadas.<sup>3</sup></li>
  <li><span class="emoji">üìà</span> Los proyectos que usan <strong>herramientas digitales</strong> reportan <strong>cierres 4‚Äì9% m√°s altos</strong> en precio.<sup>4</sup></li>
  <li><span class="emoji">‚è±Ô∏è</span> Los asesores ahorran <strong>40‚Äì60% de tiempo</strong> por cliente, ya que los compradores se informan por s√≠ mismos.<sup>5</sup></li>
  <li><span class="emoji">‚ùå</span> Adi√≥s a los <strong>PDFs anticuados</strong> ‚Äî la disponibilidad se actualiza <strong>en tiempo real</strong>, manteniendo alineadas las ventas con los clientes.</li>
</ul>


  <div class="faq-sources" style="font-size: 0.85em; color: ${CONFIG.colors.gray777}; margin-top: 10px;">
    <p><strong>Fuentes:</strong></p>
    <ol>
      <li>REACH PropTech Report (2022): ‚ÄúDigital Sales Tools Reduce Time on Market by 30‚Äì50%.‚Äù</li>
      <li>Zillow & NAR Research (2023): ‚ÄúVirtual Tours Double Buyer Engagement.‚Äù</li>
      <li>National Association of Realtors (2024): ‚Äú77% of Buyers Say Virtual Tours Influence Visit Decisions.‚Äù</li>
      <li>Matterport + Redfin Study (2023): ‚Äú3D Listings Sell 31% Faster and for 4‚Äì9% Higher Prices.‚Äù</li>
      <li>HubSpot / DemandGen Report (2023): ‚ÄúInteractive Content Yields 65% Higher Lead-to-Sale Conversion.‚Äù</li>
    </ol>
  </div>


<div class="cta-section">
  <a href="https://arquidromo.com/colmena" class="cta-link" target="_blank">
    <span class="emoji">üêù</span> Ver proyecto ‚Üí <strong>Colmena</strong><br>
  </a>
</div>

<div class="cta-section">
  <a href="https://arquidromo.com/vivecolmena/departamentos" class="cta-link" target="_blank">
    <span class="emoji">üåø</span> Explorar ‚Üí <strong>Vive Colmena</strong><br>
  </a>
</div>

</div>


  `;
  customScrollbar.style.display = '';
  enableInfoScrollbar();
});




 
  // Hide/show floating buttons while modal is expanded (mobile)
const observer = new MutationObserver(() => {
  // Add Pin button may be created later by PS.addAddPinButton()
  const addPinBtn = document.getElementById('addPinBtn');

  const hideAll = () => {
searchBtnStage?.classList.add('hide');
    lalalandBtn?.classList.add('hide');


    // If user was in "add pin" mode, turn it off so no crosshair while hidden
    if (window.__LL_PINS__?.addMode) {
      try { window.__LL_PINS__.toggleAddMode(); } catch {}
    }
  };

  const showAll = () => {
    searchBtnStage?.classList.remove('hide');
    lalalandBtn?.classList.remove('hide');

  };
 
  if (window.innerWidth < 768) {
    if (modal.classList.contains('expanded')) {
      hideAll();
    } else {
      showAll();
    }
  } else {
    // Desktop: keep them visible
    showAll();
  }
});

  observer.observe(modal, { attributes: true, attributeFilter: ['class'] });

  // Reset map view (existing behavior)
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (!window.map) return;
      const initialZoom = getCurrentFraccZoom();
      map.flyTo({
        center: [-100.15994, 25.461823],
        zoom: initialZoom,
        bearing: 0,
        pitch: 0,
        speed: 1.2,
        curve: 1.5
      });
    });
  }
});


function hideCalendlyEmbed() {
  // Hide the embedded Calendly pane
  const wrap = document.getElementById('calendlyEmbed');
  if (wrap) wrap.style.display = 'none';

  // Blank the iframe so it fully resets next time
  const iframe = document.getElementById('calendly-iframe');
  if (iframe) iframe.src = 'about:blank';

  // Close Calendly popup widget if it's open
  if (window.Calendly && typeof window.Calendly.closePopupWidget === 'function') {
    try { window.Calendly.closePopupWidget(); } catch {}
  }
}

</script>




<script>
(() => {
  'use strict';

  const PS = (window.__LL_PINS__ = window.__LL_PINS__ || {});
  PS.markers = new Map();      // id -> { pin, marker }
  PS.addMode = false;
  PS._mapClickHandler = null;
  PS._isVisible = false;       // markers start hidden (button is now always visible)
  PS.pinLocks = new Map();     // id -> boolean (track lock state per pin)

  // Cone visualization removed

  // Cone visualization removed

  // Track pins awaiting cone appearance order
  PS._pinsAwaitingCone = new Set();  // ids awaiting reveal animation

  const toast = (m, t=2500) => { try{ window.showToaster?.(m, t);}catch{} };
  const debounce = (fn, wait=400) => { let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; };

  async function compressImageToJPEG(fileOrBlob, maxSize = 1000) {
    const dataURL = await new Promise((res) => {
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.readAsDataURL(fileOrBlob);
    });
    const img = await new Promise((res) => {
      const i = new Image();
      i.onload = () => res(i);
      i.src = dataURL;
    });
    let { width, height } = img;
    if (width > height && width > maxSize) {
      height = Math.round(height * (maxSize / width));
      width = maxSize;
    } else if (height > width && height > maxSize) {
      width = Math.round(width * (maxSize / height));
      height = maxSize;
    }
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    return await new Promise((res) => canvas.toBlob(b => res(b), 'image/jpeg', 0.85));
  }

  // ======== GEO UTILS: destination point (lng,lat + meters + bearing¬∞) ========
  function destination(lng, lat, distMeters, bearingDeg) {
    const R = 6371000; // meters
    const Œ¥ = distMeters / R;
    const Œ∏ = (bearingDeg * Math.PI) / 180;
    const œÜ1 = (lat * Math.PI) / 180;
    const Œª1 = (lng * Math.PI) / 180;

    const sinœÜ1 = Math.sin(œÜ1), cosœÜ1 = Math.cos(œÜ1);
    const sinŒ¥ = Math.sin(Œ¥),   cosŒ¥ = Math.cos(Œ¥);
    const sinœÜ2 = sinœÜ1 * cosŒ¥ + cosœÜ1 * sinŒ¥ * Math.cos(Œ∏);
    const œÜ2 = Math.asin(sinœÜ2);
    const y = Math.sin(Œ∏) * sinŒ¥ * cosœÜ1;
    const x = cosŒ¥ - sinœÜ1 * sinœÜ2;
    const Œª2 = Œª1 + Math.atan2(y, x);

    return [ ((Œª2 * 180) / Math.PI + 540) % 360 - 180, (œÜ2 * 180) / Math.PI ];
  }







  // ---- Add Pin button (REMOVED - using POI button in modal header instead)
  PS.addAddPinButton = function () {
    // No longer creating floating button - POI button is in modal header
    return;
  };

  // ---- Toggle add mode (no gating on _isVisible)
  PS.toggleAddMode = function () {
    if (!window.map) { toast('Map is still loading‚Ä¶'); return; }
    PS.addMode = !PS.addMode;
    const btn = document.getElementById('poiButton');
    if (btn) {
      btn.style.textDecoration = PS.addMode ? 'underline' : 'none';
    }

    // Disable/enable modal close when POI mode is active
    window.poiModeActive = PS.addMode;

    map.getCanvas().style.cursor = PS.addMode ? 'crosshair' : '';
    if (PS.addMode && !PS._mapClickHandler) {
      PS._mapClickHandler = (e) => {
        const t = e.originalEvent?.target;
        if (t && (t.closest('#lotModal') || t.closest('.mapboxgl-ctrl') || t.closest('button') || t.closest('a'))) return;
        PS.createPinAt(e.lngLat).finally(() => {
          // Deactivate POI mode after adding pin
          PS.addMode = false;
          window.poiModeActive = false;
          const btn = document.getElementById('poiButton');
          if (btn) btn.style.textDecoration = 'none';
          map.getCanvas().style.cursor = '';
          map.off('click', PS._mapClickHandler);
          PS._mapClickHandler = null;
        });
      };
      map.on('click', PS._mapClickHandler);
      toast('POI mode: Click map to add point');
    } else if (!PS.addMode && PS._mapClickHandler) {
      map.off('click', PS._mapClickHandler);
      PS._mapClickHandler = null;
      toast('POI mode deactivated');
    }
  };

  // ---- DB create
  PS.createPinAt = async function (lngLat) {
    await window.supabaseReady;

    // Get authenticated user for RLS policy
    const { data: { user } } = await window.supabaseClient.auth.getUser();
    if (!user) {
      console.error('User not authenticated');
      toast('Please log in to add pins');
      return;
    }

    const { data, error } = await window.supabaseClient
      .from('pins').insert({
        lng: lngLat.lng,
        lat: lngLat.lat,
        heading: 0,
        title: 'PIN',
        client_id: CURRENT_CLIENT,
        user_id: user.id
      }).select().single();

    if (error) {
      console.error('Pin creation failed:', error);
      toast(`Could not create pin: ${error.message}`);
      return;
    }

    PS.addMarker(data);
    toast('Pin added');
  };

  // ---- Delete pin (DB + local cleanup)
  PS.deletePin = async function (pinId) {
    try {
      await window.supabaseReady;
      const { error } = await window.supabaseClient
        .from('pins').delete().eq('id', pinId);
      if (error) { console.error(error); toast('Failed to delete pin'); return false; }

      // Optimistic local cleanup (RT delete will also do this)
      const rec = PS.markers.get(pinId);
      if (rec) { rec.marker.remove(); PS.markers.delete(pinId); }


      toast('Pin deleted');
      return true;
    } catch (e) {
      console.error(e);
      toast('Delete failed');
      return false;
    }
  };

  // ---- HTML marker (12px dot)
  PS.markerElement = function () {
    const el = document.createElement('div');
    el.style.width = '10px';
    el.style.height = '10px';
    el.style.borderRadius = '50%';
    el.style.background = 'transparent';
    el.style.border = 'none';
    el.style.boxShadow = 'none';
    el.style.cursor = 'pointer';
    el.style.border = `2px solid ${CONFIG.colors.primary}`; // Orange outline
    return el;
  };

  // ---- Add marker with reveal animation
  PS.addMarker = function (pin) {
    const updating = PS.markers.has(pin.id);
    if (updating) {
      PS.markers.get(pin.id).marker.setLngLat([pin.lng, pin.lat]);
      PS.markers.get(pin.id).pin = pin;
      return;
    }

    const el = PS.markerElement();
    const marker = new mapboxgl.Marker({ element: el, draggable: false })
      .setLngLat([pin.lng, pin.lat]);

    PS.markers.set(pin.id, { pin, marker });

    // Add marker to map immediately if pins are already visible
    if (PS._isVisible && window.map) {
      marker.addTo(map);
    } else {
      // Initial load path: marker is not yet on map; _revealMarkers will add + fade-in.
      PS._pinsAwaitingCone.add(pin.id);
    }

    marker.on('dragend', async () => {
      const ll = marker.getLngLat();
      const { error } = await window.supabaseClient
        .from('pins').update({ lng: ll.lng, lat: ll.lat }).eq('id', pin.id);
      if (error) toast('Failed to save position'); else toast('Position saved');
      const rec = PS.markers.get(pin.id);
      if (rec) {
        rec.pin.lng = ll.lng; rec.pin.lat = ll.lat;

      }
    });

    el.addEventListener('click', (ev) => {
      ev.stopPropagation();
      PS.openPinInModal(pin);
    });



    
  };

  // programmatic setter (update heading + persist + refresh cone)
  PS.setPinHeading = async function (pinId, newHeading, { persist = true } = {}) {
    const rec = PS.markers.get(pinId);
    if (!rec) return;
    const h = (Math.round(newHeading) % 360 + 360) % 360;
    rec.pin.heading = h;
    if (persist) {
      await window.supabaseReady;
      const { error } = await window.supabaseClient
        .from('pins').update({ heading: h }).eq('id', pinId);
      if (error) console.warn('Failed to save heading', error);
    }
  };

  // ---- Toggle pin lock state (enable/disable dragging)
  PS.togglePinLock = function (pinId) {
    const rec = PS.markers.get(pinId);
    if (!rec) return;

    // Default to locked (true) if not explicitly set
    const isLocked = PS.pinLocks.has(pinId) ? PS.pinLocks.get(pinId) : true;
    const newLockState = !isLocked;

    // Update lock state
    PS.pinLocks.set(pinId, newLockState);

    // Update marker draggable state
    rec.marker.setDraggable(!newLockState);

    // Update UI icons
    const unlockIcon = document.getElementById('unlockIcon');
    const lockIcon = document.getElementById('lockIcon');
    if (unlockIcon && lockIcon) {
      if (newLockState) {
        // Locked state - show lock icon
        unlockIcon.style.display = 'none';
        lockIcon.style.display = 'block';
      } else {
        // Unlocked state - show unlock icon
        unlockIcon.style.display = 'block';
        lockIcon.style.display = 'none';
      }
    }

    toast(newLockState ? 'Pin locked' : 'Pin unlocked');
    return newLockState;
  };

  // ---- Reveal markers (fade-in animation)
  PS._revealMarkers = function () {
    if (PS._isVisible) return;
    PS._isVisible = true;

    // Count how many awaiting pins we will handle
    const awaitingIds = new Set(PS._pinsAwaitingCone);
    let revealedCount = 0;
    const totalToReveal = awaitingIds.size;

    PS.markers.forEach(({ marker, pin }) => {
      const el = marker.getElement();
      if (!el.parentNode) marker.addTo(map); // put it on the map
      el.style.display = 'block';
      el.style.opacity = '0';
      el.style.transition = 'opacity 600ms ease';

      const onDone = () => {
        el.removeEventListener('transitionend', onDone);
        if (awaitingIds.has(pin.id)) {
          awaitingIds.delete(pin.id);
        }
        revealedCount++;
        if (revealedCount === totalToReveal) {
          PS._pinsAwaitingCone.clear();
        }
      };

      el.addEventListener('transitionend', onDone, { once: true });

      // Safety: if transitionend never fires (browser quirk), force after 1s
      setTimeout(() => {
        if (awaitingIds.has(pin.id)) onDone();
      }, 1000);

      // start fade-in
      requestAnimationFrame(() => { el.style.opacity = '1'; });
    });
  };

  // ---- Open in your lot modal (with heading controls + DELETE button)
  // ---- Open in modal (full-width photo, no thumbnails)
// ---- Open in modal (full-width photo, controls overlayed above photo)
PS.openPinInModal = async function (pin) {
  await window.supabaseReady;
  
  // Check if user is authenticated
  const { data: { session } } = await window.supabaseClient.auth.getSession();
  const isAuthenticated = !!(session && session.user);
  
  document.getElementById('lotModal').classList.add('pin-mode');

  const modal = document.getElementById('lotModal');
  const wrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const backButton = document.getElementById('backButton');

  if (!modal.classList.contains('show')) {
    try {
      if (window.map) {
        // Set placeholder fracc for POI (not matching to any real fracc)
        // This tells closeModal to stay at current location instead of flying to a fracc center
        modal.dataset.fracc = 'poi';

        // Update community logo (won't match 'poi', so logo stays as-is)
        if (typeof window.updateCommunityLogo === 'function') {
          window.updateCommunityLogo();
        }

        // Save current view but we won't fly back to it - closeModal will clear preModalView for pins
        window.preModalView = {
          center: map.getCenter().toArray(),
          zoom: map.getZoom(),
          bearing: map.getBearing(),
          pitch: map.getPitch()
        };
      }
      modal.classList.add('show');
      modal.style.display = 'block';
      if (typeof window.adjustMapForModal === 'function') adjustMapForModal();
    } catch (e) {
      console.warn('Could not open modal:', e);
    }
  }

  modal.classList.add('pin-mode');
  modal.classList.remove('lot-mode');

  // Set header title for pin
  const headerFracc = document.getElementById('headerFracc');
  const headerLotNumber = document.getElementById('headerLotNumber');
  
  if (headerFracc) {
    headerFracc.textContent = pin.title || 'PIN';
    headerLotNumber.style.display = 'none';
    
    // Make header editable if authenticated
    if (isAuthenticated) {
      headerFracc.contentEditable = 'true';
      headerFracc.style.cursor = 'text';
      headerFracc.style.outline = `2px solid ${CONFIG.colors.primary}`;
      headerFracc.style.borderRadius = '4px';
      headerFracc.style.padding = '4px 8px';

      // Save on blur
      headerFracc.onblur = async function() {
        const newTitle = this.textContent.trim() || 'PIN';
        if (newTitle !== pin.title) {
          pin.title = newTitle;
          
          // Save to database
          const { error } = await window.supabaseClient
            .from('pins')
            .update({ title: newTitle })
            .eq('id', pin.id);
          
          if (error) {
            console.warn('Failed to save pin title', error);
          } else {
            console.log('Pin title saved:', newTitle);
          }
        }
      };
      
      // Allow Enter key to blur/save
      headerFracc.onkeydown = function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.blur();
        }
      };
    } else {
      headerFracc.contentEditable = 'false';
      headerFracc.style.cursor = 'default';
    }
  }

  // Show lock button if authenticated
  const lockButton = document.getElementById('pinLockButton');
  if (lockButton) {
    if (isAuthenticated) {
      lockButton.style.display = 'block';

      // Set initial icon state based on current lock state (default to locked)
      const isLocked = PS.pinLocks.has(pin.id) ? PS.pinLocks.get(pin.id) : true;
      const unlockIcon = document.getElementById('unlockIcon');
      const lockIcon = document.getElementById('lockIcon');
      if (unlockIcon && lockIcon) {
        if (isLocked) {
          unlockIcon.style.display = 'none';
          lockIcon.style.display = 'block';
        } else {
          unlockIcon.style.display = 'block';
          lockIcon.style.display = 'none';
        }
      }

      // Set up click handler
      lockButton.onclick = () => PS.togglePinLock(pin.id);
    } else {
      lockButton.style.display = 'none';
    }
  }

  // Hide GLOBAL dashboard button in pin mode
  const globalBtn = document.getElementById('globalDashboardButton');
  if (globalBtn) globalBtn.style.display = 'none';

  if (backButton) backButton.style.display = 'none';
  document.querySelector('.plus-button')?.style && (document.querySelector('.plus-button').style.display = 'none');
  document.querySelector('.bottom-plus-button')?.style && (document.querySelector('.bottom-plus-button').style.display = 'none');

  // Optional: make the content truly edge-to-edge
  lotDetails.style.padding = '0';
  wrapper.style.padding = '0';

  lotDetails.innerHTML = '';
  wrapper.classList.add('show-details');
  lotDetails.classList.add('active');
  try { window.isDetailOpen = true; } catch {}

  // fetch photos (latest shown)
  console.log('üîÑ Fetching photos for pin', pin.id);

  const { data: photos, error: photosError } = await window.supabaseClient
    .from('pin_photos')
    .select('id,url,created_at')
    .eq('pin_id', pin.id)
    .eq('client_id', CURRENT_CLIENT)
    .order('created_at', { ascending: true });

  if (photosError) {
    console.error('‚ùå ERROR fetching pin photos:', photosError);
    console.error('‚ùå This may be an RLS (Row Level Security) policy issue.');
    console.error('‚ùå Error details:', {
      message: photosError.message,
      code: photosError.code,
      details: photosError.details,
      hint: photosError.hint
    });

    // Check if user is authenticated
    const { data: { session } } = await window.supabaseClient.auth.getSession();
    if (!session || !session.user) {
      console.error('‚ùå User is NOT authenticated - this may be why the query failed');
    } else {
      console.log('‚úÖ User IS authenticated:', session.user.email);
      console.error('‚ùå Query failed despite authentication - check RLS policies on pin_photos table');
    }
  } else {
    console.log('‚úÖ Successfully fetched', photos?.length || 0, 'photos for pin', pin.id);
  }

  const latest = (photos && photos.length) ? photos[photos.length - 1] : null;
  const currentHeading = (typeof pin.heading === 'number') ? pin.heading : 0;

  // Build UI: Only show photo when not authenticated, show controls when authenticated
  const container = document.createElement('div');
  container.style.padding = '0';
  
  // Only show controls if authenticated
  const authControlsHtml = isAuthenticated ? `
    <!-- Actions (Upload / Delete) -->
    <div style="display:flex; gap:10px; align-items:center;">
      <label style="display:inline-block; background:${CONFIG.colors.primary}; color:${CONFIG.colors.white}; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif;">
        Upload photo
        <input type="file" accept="image/*" style="display:none" id="ps-upload-${pin.id}">
      </label>
      <button id="ps-delete-${pin.id}" type="button"
        style="background:${CONFIG.colors.error};color:${CONFIG.colors.white};padding:8px 12px;border:none;border-radius:6px;cursor:pointer;font-weight:700;font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif;">
        Delete pin
      </button>
    </div>
  ` : '';

  container.innerHTML = `
    <div id="ps-photo-wrap-${pin.id}" style="
      position:relative;
      width:100%;
      margin:0;
      border-radius:0 !important;
      overflow:hidden;
      background:none;">
      ${
        latest
          ? `<img id="ps-photo-${pin.id}" src="${latest.url}" alt=""
                 style="display:block;width:100%;height:auto;border-radius:0;cursor:pointer;">`
          : isAuthenticated 
            ? `<div id="ps-photo-empty-${pin.id}" style="padding:48px 0;text-align:center;color:${CONFIG.colors.textLight};">No photo yet.</div>`
            : `<div id="ps-photo-empty-${pin.id}" style="padding:48px 0;text-align:center;color:${CONFIG.colors.textLight};">No photo available.</div>`
      }

      <!-- Only show overlay with controls if authenticated -->
      ${isAuthenticated ? `
      <div class="ps-overlay" style="
        position:absolute;
        left:0; right:0; top:0;
        z-index:2;                 
        padding:12px;
        pointer-events:none;       
        background: linear-gradient(180deg, ${CONFIG.colors.transparent} 0%, ${CONFIG.colors.overlayLight} 40%, ${CONFIG.colors.overlayMedium} 100%);
      ">
        <div class="ps-overlay-card" style="
          display:flex; flex-direction:column; gap:10px;
          pointer-events:auto;     
          background: ${CONFIG.colors.overlaySubtle};
          backdrop-filter: blur(4px);
          -webkit-backdrop-filter: blur(4px);
          border-radius:10px;
          padding:10px;
        ">
          ${authControlsHtml}
        </div>
      </div>
      ` : ''}
    </div>
  `;
  lotDetails.appendChild(container);




  // photo click => fullscreen viewer (available for all users)
  const imgEl = container.querySelector(`#ps-photo-${pin.id}`);
  imgEl?.addEventListener('click', () => PS.showViewer(imgEl.src));

  // Only set up event handlers if authenticated
  if (isAuthenticated) {
    // delete pin
    const delBtn = container.querySelector(`#ps-delete-${pin.id}`);
    delBtn.addEventListener('click', async () => {
      if (!confirm('Delete this pin?')) return;
      const ok = await PS.deletePin(pin.id);
      if (ok) { try { closeModal(); } catch {} }
    });

    // upload: replace full-width image (no thumbnails)
    const input = container.querySelector(`#ps-upload-${pin.id}`);
    input.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files[0]) return;
      try {
        const blob = await compressImageToJPEG(e.target.files[0], 1200);
        const path = `${pin.id}/${Date.now()}.jpg`;

        const up = await window.supabaseClient.storage.from('pin-photos')
          .upload(path, blob, { contentType: 'image/jpeg', upsert: false });
        if (up.error) throw up.error;

        const pub = window.supabaseClient.storage.from('pin-photos').getPublicUrl(path);
        const url = pub?.data?.publicUrl;
        if (!url) throw new Error('No public URL');

        // Get authenticated user for RLS policy
        const { data: { user } } = await window.supabaseClient.auth.getUser();
        if (!user) throw new Error('User not authenticated');

        const { error: insErr } = await window.supabaseClient
          .from('pin_photos').insert({
            pin_id: pin.id,
            url,
            client_id: CURRENT_CLIENT,
            user_id: user.id
          });
        if (insErr) throw insErr;

        const wrap = container.querySelector(`#ps-photo-wrap-${pin.id}`);
        let img = container.querySelector(`#ps-photo-${pin.id}`);
        if (!img) {
          wrap.insertAdjacentHTML('afterbegin',
            `<img id="ps-photo-${pin.id}" src="${url}" alt="" style="display:block;width:100%;height:auto;border-radius:0;cursor:pointer;">`);
          img = container.querySelector(`#ps-photo-${pin.id}`);
          img.addEventListener('click', () => PS.showViewer(img.src));
          document.getElementById(`ps-photo-empty-${pin.id}`)?.remove();
        } else {
          img.src = url;
        }

        try { window.showToaster?.('Photo uploaded'); } catch {}
      } catch (err) {
        console.error(err);
        try { window.showToaster?.('Upload failed'); } catch {}
      } finally {
        e.target.value = '';
      }
    });
  }
};




  // ---- Simple full-screen viewer
  PS.ensureViewer = function () {
    if (document.getElementById('pinViewer')) return;
    document.body.insertAdjacentHTML('beforeend', `
      <div id="pinViewer" style="display:none;position:fixed;inset:0;background:${CONFIG.colors.overlayDark};z-index:10000;">
        <img id="pinViewerImg" style="max-width:90%;max-height:90%;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);" />
        <button id="pinViewerClose" style="position:absolute;top:20px;right:20px;background:${CONFIG.colors.error};color:${CONFIG.colors.white};border:none;border-radius:50%;width:40px;height:40px;font-size:20px;cursor:pointer;">√ó</button>
      </div>`);
    document.getElementById('pinViewerClose').addEventListener('click', () => {
      document.getElementById('pinViewer').style.display = 'none';
    });
  };
  PS.showViewer = function (url) {
    PS.ensureViewer();
    document.getElementById('pinViewerImg').src = url;
    document.getElementById('pinViewer').style.display = 'block';
  };

  // ---- Load + realtime
  PS.loadPins = async function () {
    await window.supabaseReady;

    console.log('üîÑ Loading pins from Supabase...');

    const { data, error } = await window.supabaseClient
      .from('pins').select('id,lng,lat,heading,title').eq('client_id', CURRENT_CLIENT).order('created_at', { ascending: true });

    if (error) {
      console.error('‚ùå ERROR loading pins:', error);
      console.error('‚ùå This may be an RLS (Row Level Security) policy issue.');
      console.error('‚ùå Error details:', {
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint
      });

      // Check if user is authenticated
      const { data: { session } } = await window.supabaseClient.auth.getSession();
      if (!session || !session.user) {
        console.error('‚ùå User is NOT authenticated - this may be why the query failed');
        console.error('‚ùå If pins table has RLS enabled, you need to be logged in to view pins');
      } else {
        console.log('‚úÖ User IS authenticated:', session.user.email);
        console.error('‚ùå Query failed despite authentication - check RLS policies on pins table');
      }
      return;
    }

    console.log('‚úÖ Successfully loaded', data?.length || 0, 'pins');

    (data || []).forEach(p => {
      PS.addMarker(p); // reveal animation deferred
    });
  };

  PS.subscribe = function () {
    window.supabaseClient
      .channel('pins-rt')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'pins', filter: `client_id=eq.${CURRENT_CLIENT}` }, (payload) => {
        PS.addMarker(payload.new); // for live inserts
      })
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'pins', filter: `client_id=eq.${CURRENT_CLIENT}` }, (payload) => {
        const rec = PS.markers.get(payload.new.id);
        if (!rec) return;
        const { lng, lat, heading } = payload.new;
        if (typeof lng === 'number' && typeof lat === 'number') {
          rec.marker.setLngLat([lng, lat]);
          rec.pin.lng = lng; rec.pin.lat = lat;
        }
        if (typeof heading === 'number') {
          rec.pin.heading = ((heading % 360) + 360) % 360;
        }

      })
      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'pins', filter: `client_id=eq.${CURRENT_CLIENT}` }, (payload) => {
        const rec = PS.markers.get(payload.old.id);
        if (rec) { rec.marker.remove(); PS.markers.delete(payload.old.id); }

      })
      .subscribe();
  };

  // ---- Boot
  const boot = async () => {
    await window.supabaseReady;
    if (!window.map) {
      const i = setInterval(() => {
        if (window.map) { clearInterval(i); PS.addAddPinButton(); PS.loadPins(); PS.subscribe(); }
      }, 200);
    } else {
      PS.addAddPinButton();
      PS.loadPins();
      PS.subscribe();
    }

  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})(); 
</script>

 

<script>
// CYCLE AVAILABILITY ‚Äî standalone + persistent selection
(() => {
  const btn = document.getElementById('cycleAvailabilityBtn');
  if (!btn) return;

  const ORDER = ['Available', 'Sold', 'Featured'];
  let selectedLotName = null; // persists selection inside this block

  const $modalInfo = document.getElementById('modalInfo');
  const $lotModal  = document.getElementById('lotModal');

  // --- utils ---
  const normalize = v => (v || '').toString().trim().toLowerCase();
const nextState = cur => {
  const i = ORDER.findIndex(v => v.toLowerCase() === normalize(cur));
  return ORDER[(i + 1) % ORDER.length];
};
 
  // Which lot is currently "selected" (detail view or centered row)
  function getSelectedLot() {
    // detail view path
    if (window.isDetailOpen && typeof window.currentLotIndex === 'number' && window.currentLotIndex >= 0) {
      const mapLot = lotData[window.currentLotIndex];
      if (!mapLot) return null;
      const n = extractLotNumber(mapLot.name);
      const baseIdx = baseLots.findIndex(b => b.name === mapLot.name);
      return { lotName: mapLot.name, number: n, baseIndex: baseIdx };
    }
    // list-centered path
    const centered = document.querySelector('.info-row.center');
    if (!centered) return null;
    const baseIndex = parseInt(centered.dataset.baseIndex, 10);
    if (isNaN(baseIndex) || baseIndex < 0) return null;
    const base = baseLots[baseIndex];
    if (!base) return null;

    // üî• FIX: Search for lot matching BOTH number AND fraccionamiento
    // This prevents selecting the wrong lot when duplicate numbers exist (e.g., lot 17-05 in both marsella and sierraalta)
    const mapIdx = lotData.findIndex(l =>
      extractLotNumber(l.name) === base.number &&
      l.fraccionamiento === base.fraccionamiento
    );
    if (mapIdx === -1) return null;
    return { lotName: lotData[mapIdx].name, number: base.number, baseIndex };
  } 

  // Visual re-apply: map hover + list active row + button color
  function setSelectedLotByName(lotName, { scroll = false } = {}) {
    if (!lotName) return;
    selectedLotName = lotName;

    // Map hover
    const mapIndex = lotData.findIndex(l => l.name === lotName);
    if (mapIndex !== -1 && map?.getSource('lots-final')) {
      if (window.hoveredId !== null && window.hoveredId !== mapIndex) {
        try { map.setFeatureState({ source:'lots-final', id: window.hoveredId }, { hover:false }); } catch {}
      }
      try { map.setFeatureState({ source:'lots-final', id: mapIndex }, { hover:true }); } catch {}
      window.hoveredId = mapIndex;
    }

    // List center/highlight
    const baseIndex = baseLots.findIndex(b => b.name === lotName);
    if (baseIndex !== -1) {
      if (scroll) {
        // use your existing helper if present
        if (typeof scrollToBaseIndex === 'function') scrollToBaseIndex(baseIndex, true);
      } else {
        const actualIndex = baseIndex + (window.cloneCount ?? 5);
        const row = document.querySelector(`.info-row[data-index="${actualIndex}"]`);
        if (row) {
          document.querySelectorAll('.info-row').forEach(r => r.classList.remove('active','center'));
          row.classList.add('active','center');
        }
      }
    }

    // Button color reflects current state
    const lot = lotData[mapIndex];
    const state = normalize(lot?.availability || 'available');
    btn.classList.remove('sold','featured');
    if (state === 'sold') btn.classList.add('sold');
    if (state === 'featured') btn.classList.add('featured');
  }

  // Keep button color synced when UI changes
  function syncButtonToCurrentSelection() {
    const sel = getSelectedLot();
    const name = sel?.lotName ?? selectedLotName;
    if (!name) { btn.classList.remove('sold','featured'); return; }
    setSelectedLotByName(name, { scroll:false });
  }

  // --- local data updates (optimistic) ---
function applyAvailabilityLocal(lotName, state) {
  const norm = (state ?? '').toString().toLowerCase();

  const idx = lotData.findIndex(l => l.name === lotName);
  if (idx !== -1) {
    lotData[idx].availability = state;            // keep whatever casing you want to store
    lotData[idx].featured = (norm === 'featured'); // boolean stays correct
  }

  const bi = baseLots.findIndex(b => b.name === lotName);
  if (bi !== -1) baseLots[bi].availability = state;

  lots.forEach(l => { if (l.name === lotName) l.availability = state; });
}

  // --- layers refresh ---
function refreshFeaturedLayer() {
  const src = map.getSource('featured-lots');
  const feats = lotData
    .filter(l => (l.featured === true) || ((l.availability ?? '').toString().toLowerCase() === 'featured'))
    .map(featuredPolygonFeature);

  if (src) {
    src.setData({ type: 'FeatureCollection', features: feats });
  } else {
    addFeaturedLotsLayer(map);
  }
}

  function refreshSoldLayer() {
    const srcId = 'sold-x';
    const layerId = 'sold-x-layer';
    const soldLots = lotData.filter(l => normalize(l.availability) === 'sold');
    const features = soldLots.flatMap(makeXFeatures);

    if (!map.getSource(srcId)) {
      map.addSource(srcId, { type: 'geojson', data: { type:'FeatureCollection', features }});
      map.addLayer({
        id: layerId, type:'line', source: srcId,
        paint: { 'line-color':'white', 'line-width':1, 'line-opacity':1 }
      });
    } else {
      map.getSource(srcId).setData({ type:'FeatureCollection', features });
    }
  }

  function refreshVisuals() {
    refreshFeaturedLayer();
    refreshSoldLayer();
    if (typeof render === 'function') render();
  }

  // --- auth guard ---
  async function ensureLoggedIn() {
    const session = (await window.supabaseClient?.auth.getSession())?.data?.session;
    return !!(session && session.user);
  }

  // --- main action ---
  async function cycleSelectedLotAvailability() {
    if (!window.supabaseClient) { window.showToaster?.('Supabase no est√° listo.'); return; }
    // Authentication check - trigger login if not authenticated
    if (!(await ensureLoggedIn())) { document.getElementById('globe-login-btn')?.click(); return; }

    const sel = getSelectedLot();
    if (!sel) { window.showToaster?.('Selecciona un lote primero.'); return; }

    const i = lotData.findIndex(l => l.name === sel.lotName);
    if (i === -1) return;

    const current = normalize(lotData[i].availability || 'available');
    const next = nextState(current);

    // remember selection and do optimistic update
    selectedLotName = sel.lotName;
    applyAvailabilityLocal(sel.lotName, next);
    // button feedback
    btn.classList.remove('sold','featured');
    if (next === 'sold') btn.classList.add('sold');
    if (next === 'featured') btn.classList.add('featured');

    // Show immediate feedback
    const LABELS = { available:'disponible', sold:'vendido', featured:'destacado' };
    window.showToaster?.(`Estado actualizado a "${LABELS[next] || next}".`);

    refreshVisuals();
    // ‚úÖ keep same lot selected after DOM/layers refresh
    setSelectedLotByName(selectedLotName, { scroll:false });

    // Save to database in background (don't await - fire and forget with error handling)
    (async () => {
      try {
        // Mark this lot to skip next realtime re-render
        if (!window.skipNextRealtimeRender) window.skipNextRealtimeRender = new Set();
        window.skipNextRealtimeRender.add(sel.lotName);

        // Get authenticated user for audit
        const { data: { user } } = await window.supabaseClient.auth.getUser();
        const updatedBy = user?.email || user?.id || 'unknown';

        // Get fraccionamiento from lot data BEFORE the update
        const lotFracc = lotData[i]?.fraccionamiento || null;

        const { error } = await window.supabaseClient
          .from('lots')
          .update({ availability: next })
          .eq('lot_name', sel.lotName)
          .eq('fraccionamiento', lotFracc)
          .eq('client_id', CURRENT_CLIENT);
        if (error) throw error;

// Log to audit table
try {
  // Count total and sold lots from the in-memory lotData array
  const totalLots = lotData.length;
  const soldLots = lotData.filter(l => normalize(l.availability) === 'sold').length;
  const availableCount = totalLots - soldLots;

  await window.supabaseClient
    .from('lot_updates_audit')
    .insert({
      lot_name: sel.lotName,
      fraccionamiento: lotFracc,
      old_availability: current,
      new_availability: next,
      updated_by: updatedBy,
      available_lots: availableCount,
      client_id: CURRENT_CLIENT  // üü¢ ADD THIS LINE
    });
} catch (auditError) {
  console.warn('Failed to log audit:', auditError);
}
      } catch (e) {
        console.error('Background save failed:', e);
        window.showToaster?.('No se pudo guardar. Revirtiendo‚Ä¶');

        // revert
        applyAvailabilityLocal(sel.lotName, current);
        btn.classList.remove('sold','featured');
        if (current === 'sold') btn.classList.add('sold');
        if (current === 'featured') btn.classList.add('featured');

        refreshVisuals();
        setSelectedLotByName(selectedLotName, { scroll:false });
      }
    })();
  }

  // --- wiring ---
  btn.addEventListener('click', cycleSelectedLotAvailability);

  // Make globally accessible for row action buttons
  window.cycleSelectedLotAvailability = cycleSelectedLotAvailability;

  // Keep button/selection in sync on modal changes & scroll
  const obs = new MutationObserver(() => syncButtonToCurrentSelection());
  if ($lotModal) obs.observe($lotModal, { attributes:true, attributeFilter:['class','style'] });

  $modalInfo?.addEventListener('scroll', () => {
    clearTimeout(window.__syncBtnTO);
    window.__syncBtnTO = setTimeout(syncButtonToCurrentSelection, 120);
  });

  // Patch highlightCenter to remember selection automatically
  const origHighlightCenter = window.highlightCenter;
  if (typeof origHighlightCenter === 'function') {
    window.highlightCenter = function(...args) {
      const r = origHighlightCenter.apply(this, args);
      const sel = getSelectedLot();
      if (sel?.lotName) selectedLotName = sel.lotName;
      syncButtonToCurrentSelection();
      return r;
    };
  }

  // Patch showDetailViewForLot to capture selection when opening detail
  const origShowDetail = window.showDetailViewForLot;
  if (typeof origShowDetail === 'function') {
    window.showDetailViewForLot = async function(index, ...rest) {
      const isSwitchingLots = rest[0]; // First parameter after index

      // üî• FIX: Save the correct hoveredId BEFORE calling origShowDetail
      // During the async execution, MutationObserver/scroll listeners may change it
      const savedHoveredId = isSwitchingLots ? window.hoveredId : null;

      const res = await origShowDetail.apply(this, [index, ...rest]);

      try {
        const lot = lots[index];
        // üî• FIX: Match by BOTH number AND fraccionamiento to avoid selecting wrong lot
        const mapData = lotData.find(l =>
          extractLotNumber(l.name) === lot.number &&
          l.fraccionamiento === lot.fraccionamiento
        );
        if (mapData?.name) selectedLotName = mapData.name;

        // üî• FIX: When switching lots, restore the hover state that was set by map click handler
        if (!isSwitchingLots) {
          syncButtonToCurrentSelection();
        } else {
          // Restore the correct hover state
          if (savedHoveredId !== null && savedHoveredId !== window.hoveredId) {
            // Clear the wrong hover state
            if (window.hoveredId !== null && map?.getSource('lots-final')) {
              map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
            }
            // Set the correct hover state
            if (map?.getSource('lots-final')) {
              map.setFeatureState({ source: 'lots-final', id: savedHoveredId }, { hover: true });
            }
            window.hoveredId = savedHoveredId;
          }

          // Just update button color without touching hover state
          const state = normalize(mapData?.availability || 'available');
          btn.classList.remove('sold','featured');
          if (state === 'sold') btn.classList.add('sold');
          if (state === 'featured') btn.classList.add('featured');
        }
      } catch {}
      return res;
    };
  }
 
  // Patch render so selection is restored after list re-render
  const origRender = window.render;
  if (typeof origRender === 'function') {
    window.render = function(...args) {
      const res = origRender.apply(this, args);
      if (selectedLotName) setSelectedLotByName(selectedLotName, { scroll:false });
      return res;
    };
  }
})();


</script>


  

  <script>
(() => {
  'use strict';

  // ===== Namespace GPS FEATURE=====
  const NS = (window.__LL_GPS__ = window.__LL_GPS__ || {});

  // ---- simple event bus
  NS._listeners = {};
  NS.on = function (evt, cb) { (NS._listeners[evt] ||= []).push(cb); };
  NS.emit = function (evt, payload) { (NS._listeners[evt] || []).forEach(fn => { try { fn(payload); } catch {} }); };

  // Config
  NS.lotCenter = NS.lotCenter || [-100.15994, 25.461823];
  NS.maxDistanceMeters = NS.maxDistanceMeters || 1000;

  // State
  NS.gpsWatchId = null;
  NS.lastUserLngLat = null;
  NS.hasInitialFly = false;
  NS.userHeading = null;
  NS.headingListenerAttached = false;
  NS.farAwayTimer = null;
  NS.farWarned = false;
  NS.headingMarker = null;
  NS._onOrientation = null;
  
  // Smoothing (for Android)
  NS.headingSmoothingFactor = 0.15;
  NS.lastSmoothedHeading = null;

  // Utils
  const safeToaster = (msg, duration = 3000) => {
    try { if (typeof window.showToaster === 'function') window.showToaster(msg, duration); } catch {}
  };

  // Log location to Supabase
  const logLocationToSupabase = async (lng, lat) => {
    if (!window.supabaseClient) return;
    try {
      const { error } = await window.supabaseClient
        .from('location_logs')
        .insert({
          lat: lat,
          lng: lng,
          browser: navigator.userAgent,
          timestamp: new Date().toISOString(),
          client_id: CURRENT_CLIENT
        });
      if (error) console.error('Failed to log location:', error);
    } catch (err) {
      console.error('Location logging error:', err);
    }
  };

  // Distance calculation
  const distanceMeters = (a, b) => {
    const [lng1, lat1] = a, [lng2, lat2] = b;
    const R = 6371000, œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lng2 - lng1) * Math.PI / 180;
    const a_ = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
  };

  // Smooth heading
  const smoothHeading = (newHeading) => {
    if (NS.lastSmoothedHeading === null) {
      NS.lastSmoothedHeading = newHeading;
    } else {
      const diff = ((newHeading - NS.lastSmoothedHeading + 540) % 360) - 180;
      NS.lastSmoothedHeading = (NS.lastSmoothedHeading + diff * NS.headingSmoothingFactor) % 360;
    }
    return NS.lastSmoothedHeading;
  };

  // ===== Core Functions =====
  function ensureUserLocationLayers() {
    if (!window.map) return;

    if (!map.getSource('ll-user-location')) {
      map.addSource('ll-user-location', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
    }

    if (!map.getLayer('ll-user-accuracy')) {
      map.addLayer({
        id: 'll-user-accuracy',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'],
            15, ['coalesce', ['get', 'accRadiusZ15'], 2],
            22, ['coalesce', ['get', 'accRadiusZ22'], 500]
          ],
          'circle-color': CONFIG.colors.gpsMarkerBg,
          'circle-stroke-color': CONFIG.colors.gpsMarker,
          'circle-stroke-width': 1
        },
        filter: ['==', ['get', 'role'], 'accuracy']
      });
    }

    if (!map.getLayer('ll-user-dot')) {
      map.addLayer({
        id: 'll-user-dot',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': 6,
          'circle-color': CONFIG.colors.primary,
          'circle-stroke-width': 0
        },
        filter: ['==', ['get', 'role'], 'point']
      });
    }

    ensureGPSConeLayer();
  }

  // GPS heading cone as Mapbox polygon layer (matching 360 viewer)
  function ensureGPSConeLayer() {
    if (map.getSource('gps-heading-cone')) return;

    map.addSource('gps-heading-cone', {
      type: 'geojson',
      data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] } }
    });

    map.addLayer({
      id: 'gps-heading-cone-fill',
      type: 'fill',
      source: 'gps-heading-cone',
      paint: { 'fill-color': CONFIG.colors.primary, 'fill-opacity': 0.5 }
    });
  }

  function updateGPSCone(lng, lat, heading) {
    if (!map || !map.getSource('gps-heading-cone')) return;
    if (!heading && heading !== 0) {
      // Hide cone if no heading
      map.getSource('gps-heading-cone').setData({
        type: 'Feature',
        geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] }
      });
      return;
    }

    // Create fan-shaped cone (90¬∞ FOV, 15m radius)
    const fovDeg = 90;
    const radiusMeters = 15;
    const steps = 24;

    const half = fovDeg / 2;
    const start = heading - half;
    const end = heading + half;
    const ring = [[lng, lat]];

    for (let s = 0; s <= steps; s++) {
      const t = s / steps;
      const brg = start + (end - start) * t;
      ring.push(destFromBearingDistance(lat, lng, brg, radiusMeters));
    }
    ring.push([lng, lat]);

    map.getSource('gps-heading-cone').setData({
      type: 'Feature',
      geometry: { type: 'Polygon', coordinates: [ring] }
    });
  }

  function destFromBearingDistance(lat, lng, bearing, distanceMeters) {
    const R = 6371000;
    const brng = bearing * Math.PI / 180;
    const lat1 = lat * Math.PI / 180;
    const lng1 = lng * Math.PI / 180;
    const d = distanceMeters / R;

    const lat2 = Math.asin(
      Math.sin(lat1) * Math.cos(d) +
      Math.cos(lat1) * Math.sin(d) * Math.cos(brng)
    );

    const lng2 = lng1 + Math.atan2(
      Math.sin(brng) * Math.sin(d) * Math.cos(lat1),
      Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
    );

    return [lng2 * 180 / Math.PI, lat2 * 180 / Math.PI];
  }

  // Handle compass data (with iOS permission)
  async function ensureHeadingListener() {
    if (NS.headingListenerAttached) return;

    NS._onOrientation = (e) => {
      let rawHeading;
      if (typeof e?.webkitCompassHeading === 'number') {
        rawHeading = e.webkitCompassHeading; // iOS (true north)
      } else if (typeof e?.alpha === 'number') {
        rawHeading = (360 - e.alpha) % 360;   // Android
      } else {
        return;
      }

      NS.userHeading = smoothHeading(rawHeading);
      if (NS.lastUserLngLat) updateUserLocation(NS.lastUserLngLat[0], NS.lastUserLngLat[1]);
    };

    try {
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        safeToaster('Tip: enable HTTPS to access compass on iOS', 3500);
      }

      if (window.DeviceOrientationEvent &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const response = await DeviceOrientationEvent.requestPermission();
        if (response === 'granted') {
          window.addEventListener('deviceorientation', NS._onOrientation, true);
        } else {
          safeToaster('Compass permission denied', 4000);
          return;
        }
      } else if ('ondeviceorientationabsolute' in window) {
        window.addEventListener('deviceorientationabsolute', NS._onOrientation, true);
      } else {
        window.addEventListener('deviceorientation', NS._onOrientation, true);
      }

      NS.headingListenerAttached = true;
    } catch (err) {
      console.warn('Heading listener setup failed:', err);
      safeToaster('Unable to access compass data', 4000);
    }
  }

  function removeHeadingListener() {
    if (!NS.headingListenerAttached) return;
    try {
      window.removeEventListener('deviceorientation', NS._onOrientation, true);
      window.removeEventListener('deviceorientationabsolute', NS._onOrientation, true);
    } catch {}
    NS._onOrientation = null;
    NS.headingListenerAttached = false;
  }

  // Update user location and heading cone
  function updateUserLocation(lng, lat, accuracyMeters = 10) {
    const src = map?.getSource('ll-user-location');
    if (!src) return;

    src.setData({
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { role: 'point' }, geometry: { type: 'Point', coordinates: [lng, lat] } },
        {
          type: 'Feature',
          properties: {
            role: 'accuracy',
            accRadiusZ15: Math.min(12, Math.max(2, accuracyMeters / 6)),
            accRadiusZ22: Math.min(600, Math.max(50, accuracyMeters * 6))
          },
          geometry: { type: 'Point', coordinates: [lng, lat] }
        }
      ]
    });

    // Always update cone - it will hide itself if device has no compass (userHeading is null)
    updateGPSCone(lng, lat, NS.userHeading);
  }

  // ===== UI Controls =====
  document.addEventListener('DOMContentLoaded', () => {
    const gpsBtn = document.getElementById('gpsButton');
    if (gpsBtn && !gpsBtn.__llBound) {
      gpsBtn.__llBound = true;
      gpsBtn.addEventListener('click', () => {
        if (NS.gpsWatchId == null) {
          startGPS();
        } else {
          stopGPS();
        }
      });
    }
  });

  function startGPS() {
    safeToaster('Activating GPS...', 2000);

    if (!navigator.geolocation) {
      safeToaster('Geolocation not supported on this device', 5000);
      return;
    }
    if (!window.map) {
      safeToaster('Please wait - map is still loading', 5000);
      return;
    }

    ensureUserLocationLayers();
    ensureHeadingListener();

    document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'block');

    if (NS.gpsWatchId !== null) {
      navigator.geolocation.clearWatch(NS.gpsWatchId);
    }

    NS.gpsWatchId = navigator.geolocation.watchPosition(
      (pos) => {
        const { latitude, longitude, accuracy, heading } = pos.coords;
        const newLngLat = [longitude, latitude];

        // Store previous position for delta panning
        const prevLngLat = NS.lastUserLngLat;
        NS.lastUserLngLat = newLngLat;

        if (!NS._notifiedStart) {
          NS._notifiedStart = true;
          NS.emit('gps-start');
          // Log location to Supabase once when GPS starts
          logLocationToSupabase(longitude, latitude);
        }

        if (heading && !NS.userHeading) {
          NS.userHeading = smoothHeading(heading);
        }

        updateUserLocation(longitude, latitude, accuracy);

        if (!NS.hasInitialFly) {
          // First position - center on user
          NS.hasInitialFly = true;
          map.flyTo({
            center: newLngLat,
            zoom: 17,
            speed: 1.2,
            curve: 1.5
          });
          safeToaster('GPS active - tracking your location', 3000);
        } else if (prevLngLat) {
          // Subsequent positions - delta pan if moved enough
          const distance = turf.distance(
            turf.point(prevLngLat),
            turf.point(newLngLat),
            { units: 'meters' }
          );

          // Only pan if moved more than 3 meters (avoid jitter)
          if (distance > 3) {
            const center = map.getCenter();
            const deltaLng = newLngLat[0] - prevLngLat[0];
            const deltaLat = newLngLat[1] - prevLngLat[1];
            map.easeTo({
              center: [center.lng + deltaLng, center.lat + deltaLat],
              duration: 500,
              easing: t => 1 - Math.pow(1 - t, 3)
            });
          }
        }
      },
      (err) => {
        let errorMsg = 'GPS error';
        switch(err.code) {
          case err.PERMISSION_DENIED: errorMsg = 'Please enable location permissions'; break;
          case err.POSITION_UNAVAILABLE: errorMsg = 'Location signal lost'; break;
          case err.TIMEOUT: errorMsg = 'GPS timeout - try moving outdoors'; break;
        }
        stopGPS(errorMsg);
      },
      { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
    );

    NS.gpsWatchId !== null && safeToaster('GPS activated successfully', 2000);

    // Mark GPS button as active (orange)
    document.getElementById('gpsButton')?.classList.add('active');
  }

  function stopGPS(reason) {
    if (NS.gpsWatchId) {
      navigator.geolocation.clearWatch(NS.gpsWatchId);
      NS.gpsWatchId = null;
    }

    removeHeadingListener();

    if (map?.getSource('ll-user-location')) {
      map.getSource('ll-user-location').setData({ type:'FeatureCollection', features:[] });
    }

    // Hide GPS heading cone
    if (map?.getSource('gps-heading-cone')) {
      map.getSource('gps-heading-cone').setData({
        type: 'Feature',
        geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] }
      });
    }

    document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'none');

    NS.lastUserLngLat = null;
    NS.userHeading = null;
    NS.lastSmoothedHeading = null;
    NS.hasInitialFly = false; // Reset so next GPS start re-centers

    safeToaster(reason || 'GPS stopped');
    NS._notifiedStart = false;
    NS.emit('gps-stop');

    // Remove active state from GPS button
    document.getElementById('gpsButton')?.classList.remove('active');
  }

})();
</script>
 


<script>
// TEMPORARY FOR YC DEMO: All buttons visible regardless of auth status
// Function to check authentication status and toggle buttons visibility hide buttons
function toggleAuthButtons(isAuthenticated) {
  const cycleAvailabilityBtn = document.getElementById('cycleAvailabilityBtn');
  const addPinBtn = document.getElementById('addPinBtn');
  const gpsButton = document.getElementById('gpsButton');
  const driveBtn = document.getElementById('driveBtn');
  const compareBtn = document.getElementById('compareBtn'); // Added compareBtn
  const editBtn = document.getElementById('editBtn'); // Added editBtn

  console.log('Toggle buttons - Authenticated:', isAuthenticated);
  
  // COMMENTED OUT FOR YC DEMO - Show all buttons always
  // if (cycleAvailabilityBtn) {
  //   cycleAvailabilityBtn.classList.toggle('hide-button', !isAuthenticated);
  // }
  // if (addPinBtn) {
  //   addPinBtn.classList.toggle('hide-button', !isAuthenticated);
  // }
  // if (gpsButton) {
  //   gpsButton.classList.toggle('hide-button', !isAuthenticated);
  // }
  // if (driveBtn) {
  //   driveBtn.classList.toggle('hide-button', !isAuthenticated);
  // }
  // if (compareBtn) { // Added compareBtn condition
  //   compareBtn.classList.toggle('hide-button', !isAuthenticated);
  // }
  // if (editBtn) { // Added editBtn condition
  //   editBtn.classList.toggle('hide-button', !isAuthenticated);
  // }
}

// COMMENTED OUT FOR YC DEMO - Don't hide buttons on page load
// Hide buttons immediately on page load
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded - showing all buttons for YC demo');
  // toggleAuthButtons(false); // COMMENTED OUT FOR YC DEMO
  
  // Check auth status once Supabase is likely ready
  const checkAuth = setInterval(function() {
    if (window.supabaseClient && typeof window.supabaseClient.auth.getSession === 'function') {
      clearInterval(checkAuth);
      window.supabaseClient.auth.getSession().then(({ data: { session } }) => {
        const isAuthenticated = !!(session && session.user);
        console.log('Initial auth check - Authenticated:', isAuthenticated);
        // toggleAuthButtons(isAuthenticated); // COMMENTED OUT FOR YC DEMO
      });
    }
  }, 100);
});
  
// COMMENTED OUT FOR YC DEMO - Don't toggle buttons on auth change
// Listen for auth changes once Supabase is ready
const setupAuthListener = setInterval(function() {
  if (window.supabaseClient && typeof window.supabaseClient.auth.onAuthStateChange === 'function') {
    clearInterval(setupAuthListener);
    window.supabaseClient.auth.onAuthStateChange((_event, session) => {
      const isAuthenticated = !!(session && session.user);
      console.log('Auth state changed - Authenticated:', isAuthenticated);
      // toggleAuthButtons(isAuthenticated); // COMMENTED OUT FOR YC DEMO
    });
  }
}, 100);
</script>
 
  

<script>
  //DRIVE NAVIGATION HERE
(() => {
  const DEST_LNG_LAT = [-100.15994, 25.461823]; // [lng, lat] ‚Äî change to your destination

  function openInNativeMaps([lng, lat]) {
    const isApple = /iPad|iPhone|Macintosh/.test(navigator.userAgent);
    // URLs for Google Maps and Apple Maps navigation
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving&dir_action=navigate`;
    const appleMapsUrl  = `https://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
    const url = isApple ? appleMapsUrl : googleMapsUrl;
    window.open(url, '_blank');
  }

  function onDriveClick(e) {
    if (e && e.preventDefault) e.preventDefault();
    openInNativeMaps(DEST_LNG_LAT);
  }

  // Attach event listener to the button
  function bindDriveBtn() {
    const btn = document.getElementById('driveBtn');
    if (!btn || btn.dataset.bound) return;
    btn.addEventListener('click', onDriveClick);
    btn.dataset.bound = '1';
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindDriveBtn);
  } else {
    bindDriveBtn();
  }
})();
</script>

 
 



<script>
// LOT UNIT CONTROLS SORTING (hide sold in all modes)
(() => {
  const modal = document.getElementById('lotModal');
  const unitControls = document.getElementById('unitControls');
  if (!modal || !unitControls) return;

  // Config toggles (set to false if you ever want to show sold in a mode)
  const HIDE_SOLD_IN_NUM   = true;
  const HIDE_SOLD_IN_NAME  = true;
  const HIDE_SOLD_IN_AREA  = true;
  const HIDE_SOLD_IN_PRICE = true;

  let currentMode = null; // Start with no active mode
  const btns = Array.from(unitControls.querySelectorAll('.unit-btn'));

  // Robust sold detector
  function isSold(lot) {
    if (lot.sold === true) return true;
    const fields = [
      lot.availability, lot.status, lot.state,
      lot.availability_status, lot.sale_status, lot.disponibilidad
    ];
    for (const v of fields) {
      if (typeof v === 'string') {
        const s = v.normalize('NFKD').replace(/\p{Diacritic}/gu, '').trim().toLowerCase();
        if (/(^|[^a-z])(sold|vendido|ocupado)([^a-z]|$)/.test(s)) return true;
      }
    }
    return false;
  }

  function sortLots(mode) {
  // Use the current baseLots array (already filtered by fracc)
  if (!Array.isArray(baseLots) || baseLots.length === 0) return;

  // Create a copy to avoid mutating the original
  let set = [...baseLots];

  // Apply sold filtering based on mode (only if needed)
  if (mode === 'num'   && HIDE_SOLD_IN_NUM)   set = set.filter(l => !isSold(l));
  if ((mode === 'name' || mode === 'alpha' || mode === 'alphabet') && HIDE_SOLD_IN_NAME) set = set.filter(l => !isSold(l));
  if (mode === 'area'  && HIDE_SOLD_IN_AREA)  set = set.filter(l => !isSold(l));
  if (mode === 'price' && HIDE_SOLD_IN_PRICE) set = set.filter(l => !isSold(l));

  // Sort
  switch (mode) {
    case 'num':
      set.sort((a, b) => (a.number || 0) - (b.number || 0));
      break;
    case 'name':
    case 'alpha':
    case 'alphabet':
      set.sort((a, b) =>
        String(a.name || '').localeCompare(
          String(b.name || ''),
          undefined,
          { numeric: true, sensitivity: 'base' }
        )
      );
      break;
    case 'area':
      set.sort((a, b) => (cleanNumber(b.size)) - (cleanNumber(a.size)));
      break;
    case 'price':
      set.sort((a, b) => {
        // Calculate total price in pesos for sorting
        const calcPrice = (lot) => {
          if (!lot.priceM2 || !lot.size) return cleanNumber(lot.price);
          return cleanNumber(lot.priceM2) * cleanNumber(lot.size);
        };
        return calcPrice(b) - calcPrice(a); // Highest to lowest
      });
      break;
    default:
      return;
  }

  // Update baseLots with the sorted and filtered set
  baseLots = set;
  if (typeof updateLotsArray === 'function') updateLotsArray();
  if (typeof render === 'function') render();

  try {
    if (typeof highlightCenter === 'function') highlightCenter();
    if (typeof updateScrollbar === 'function') updateScrollbar();
  } catch {}

  // ‚úÖ Always scroll to first item after sorting
  if (typeof scrollToBaseIndex === 'function' && baseLots.length) {
    scrollToBaseIndex(0, true);
  }
}


  function setMode(mode) {
    // Remove active class from all buttons
    btns.forEach(b => b.classList.remove('active'));
    
    // If clicking the same mode, toggle it off (back to default order)
    if (currentMode === mode) {
      currentMode = null;
      modal.dataset.mode = '';
      
      // Reset to original order (re-apply fracc filter but no sorting)
      resetToDefaultOrder();
    } else {
      // Set new active mode
      currentMode = mode;
      modal.dataset.mode = mode;
      
      // Add active class to clicked button
      const activeBtn = btns.find(b => b.dataset.mode === mode);
      if (activeBtn) activeBtn.classList.add('active');
      
      sortLots(mode);
    }
  }

  // Function to reset to default order (when fracc changes or mode is toggled off)
  function resetToDefaultOrder() {
    // üü¢ If in compare mode, exit it and restore from backup
    if (window.compareMode) {
      const compareBtn = document.getElementById('compareBtn');
      if (compareBtn) {
        compareBtn.classList.remove('active');
      }
      window.compareMode = false;
      window.selectedLots.clear();
      if (typeof removeEditOutlines === 'function') {
        removeEditOutlines();
      }
      showToaster('Compare mode OFF');
      console.log('Compare mode OFF (auto-exited from unsort)');

      // üü¢ RESTORE from backup BEFORE clearing it
      if (window.originalBaseLots) {
        baseLots = [...window.originalBaseLots];
        window.originalBaseLots = null;
        updateLotsArray();
        if (typeof render === 'function') render();
        if (typeof highlightCenter === 'function') highlightCenter();
        if (typeof updateScrollbar === 'function') updateScrollbar();
        return; // Exit early - don't run normal reset
      }
    }

    // Normal reset behavior - restore full list
    const fracc = (modal.dataset.fracc || '').toString().trim();
    if (Array.isArray(window.baseLotsAll)) {
      baseLots = window.baseLotsAll.filter(l =>
        !fracc || (l.fraccionamiento || '').toString().trim() === fracc
      );
      updateLotsArray();
      if (typeof render === 'function') render();
      if (typeof highlightCenter === 'function') highlightCenter();
      if (typeof updateScrollbar === 'function') updateScrollbar();
    }
  }

  // Public function to reset buttons (call this when fracc changes)
  window.resetUnitButtons = function() {
    currentMode = null;
    modal.dataset.mode = '';
    btns.forEach(btn => btn.classList.remove('active'));
    resetToDefaultOrder();
  };

  btns.forEach(btn => btn.addEventListener('click', () => setMode(btn.dataset.mode)));
})();


</script>
  

  <!-- Temporary Coordinates Button - REMOVE AFTER USE  
<script>
// Add coordinates button after page loads
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(() => {
    const coordBtn = document.createElement('button');
    coordBtn.innerHTML = 'üìå Get Coordinates';
    coordBtn.id = 'coordHelperBtn';
    coordBtn.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10000;
      background: ${CONFIG.colors.primary};
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 15px;
      font-family: '${CONFIG.misc.fontFamily}', sans-serif;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 10px ${CONFIG.colors.overlaySoft};
    `;

    coordBtn.addEventListener('click', function() {
      if (window.map && typeof window.map.getCenter === 'function') {
        const center = window.map.getCenter();
        const zoom = window.map.getZoom();
        
        console.log('üéØ CURRENT COORDINATES:', center);
        console.log('üìä CURRENT ZOOM:', zoom);
        
        // Show alert with copy-able coordinates
        alert(`üìç Current Location Coordinates:
Longitude: ${center.lng}
Latitude: ${center.lat}
Zoom: ${zoom}

üìã These coordinates have been copied to clipboard and logged to console.`);

        // Copy to clipboard
        const coordsText = `center: [${center.lng}, ${center.lat}],\nzoom: ${zoom}`;
        navigator.clipboard.writeText(coordsText).then(() => {
          console.log('‚úÖ Coordinates copied to clipboard:', coordsText);
        });
      } else {
        alert('‚ùå Map not ready yet. Wait a few seconds and try again.');
      }
    });

    document.body.appendChild(coordBtn);
  }, 3000); // Wait 3 seconds for map to load
});
</script>
<!-- END Temporary Coordinates Button -->

<script>
(() => {
  const modal = document.getElementById('lotModal');
  if (!modal) return;

  const sync = () => {
    const open =
      modal.classList.contains('show') ||
      modal.classList.contains('expanded') ||
      modal.classList.contains('pin-mode') ||
      modal.classList.contains('info-mode') ||
      modal.classList.contains('lot-mode');
    document.body.classList.toggle('modal-open', open);
  };

  // initial + on any class change
  sync();
  new MutationObserver(sync).observe(modal, { attributes: true, attributeFilter: ['class'] });

  // also catch hard style/display toggles if you ever use them
  const ro = new ResizeObserver(sync);
  ro.observe(modal);
})();
</script>

<script>
(function(){
function setupCommunitySearchMenu() {
    const searchBtn  = document.getElementById('searchBtnStage');
    const circleMenu = document.getElementById('communityCircleMenu');
    if (!searchBtn || !circleMenu) return;

    // 1) Config - Build communities from CONFIG
    const communities = getAllCommunities(CURRENT_CLIENT);
    const N = 8;                 // Keep 8 positions in the circle
    const baseDeg = 0;           // 0¬∞ rotation
    const zeroAtTop = true;      // 0¬∞ at top 
    const rootStyles = getComputedStyle(document.documentElement);
    const btnPx  = parseFloat(rootStyles.getPropertyValue('--btn')) || 56;
    const diamPx = parseFloat(rootStyles.getPropertyValue('--orbit-diam')) || 160;
    const radius = (diamPx / 2) - (btnPx / 2);

    // 2) Build buttons - create all 8 positions but only make 4 visible
    circleMenu.innerHTML = '';
    
    for (let i = 0; i < N; i++) {
      const b = document.createElement('button');
      b.className = 'community-option';
      b.type = 'button';
      
      // Find if this position should have a visible button
      const community = communities.find(c => c.position === i);
      
      if (community) {
        // This position gets a visible button
        b.dataset.community = community.id;
        b.textContent = community.label;
        b.style.display = 'flex'; // Make visible
      } else {
        // Empty position - hidden
        b.style.display = 'none'; // Hide this position
      }
      
      circleMenu.appendChild(b);

      // Position all buttons (visible and hidden) in the circle
      const step = 360 / N;
      const theta = baseDeg + i*step + (zeroAtTop ? -90 : 0);
      const rad = theta * Math.PI / 180;
      const cx = circleMenu.clientWidth / 2;
      const cy = circleMenu.clientHeight / 2;
      b.style.left = (cx + radius * Math.cos(rad)) + 'px';
      b.style.top  = (cy + radius * Math.sin(rad)) + 'px';

      // Only add click handler to visible buttons
      if (community) {
        b.addEventListener('click', (e) => {
          e.stopPropagation();
          const c = community;
          if (c.center && window.map) {
            map.flyTo({ center: c.center, zoom: c.zoom || 16.2, speed: 1.2, curve: 1.5 });
            const modal = document.getElementById('lotModal');
            if (modal) {
              // ALWAYS set fracc (not just when modal is open)
              modal.dataset.fracc = c.fracc || '';

              // Update community logo
              if (typeof window.updateCommunityLogo === 'function') {
                window.updateCommunityLogo();
              }

              if (modal.classList.contains('show')) {
                if (typeof window.resetUnitButtons === 'function') window.resetUnitButtons();
              }
            }
            if (typeof window.showToaster === 'function') showToaster(`Navegando a ${c.label}`);
          }
          circleMenu.classList.remove('active');
          menuActive = false;
        });
      }
    }

    // 3) Toggle open/close
    let menuActive = false;
    searchBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menuActive = !menuActive;
      circleMenu.classList.toggle('active', menuActive);
    });

    document.addEventListener('click', () => {
      if (!menuActive) return;
      menuActive = false;
      circleMenu.classList.remove('active');
    });

    circleMenu.addEventListener('click', (e) => e.stopPropagation());
  }

  // call after map/layers are ready
  setupCommunitySearchMenu();

  // üü¢ UPDATE COMMUNITY LOGO BASED ON FRACC
  window.updateCommunityLogo = function() {
    const modal = document.getElementById('lotModal');
    const communityLogoImg = document.getElementById('communityLogoImg');

    if (!modal || !communityLogoImg) return;

    const currentFracc = (modal.dataset.fracc || '').trim().toLowerCase();
    console.log('üîµ updateCommunityLogo - currentFracc:', currentFracc);

    // Update logo based on current fracc using config helper function
    const logoUrl = getCommunityLogo(CURRENT_CLIENT, currentFracc);
    if (logoUrl) {
      console.log('üü¢ Setting logo from config:', logoUrl);
      communityLogoImg.src = logoUrl;
      const communityLogo = document.getElementById('communityLogo');
      if (communityLogo) communityLogo.style.display = 'block';
    } else {
      console.log('‚ö†Ô∏è No logo found in config for fracc:', currentFracc);
    }
  };

  // Call on page load to set initial state
  updateCommunityLogo();
})();

</script>
  

<script>
// DEEP LINKING FOR SPECIFIC LOTS - PROPER FRACC-AWARE CLOSE BEHAVIOR
(function() {
  // Wait for everything to be ready
  setTimeout(() => {
    
    function getLotFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('lot');
    }

    // üü¢ GET CURRENT FRACC CENTER BASED ON ACTIVE FILTER
function getCurrentFraccCenter() {
  // Build communities object from CONFIG
  let communities = window.communities;

  if (!communities) {
    communities = {};
    Object.keys(CONFIG.communities).forEach(key => {
      const comm = CONFIG.communities[key];
      communities[comm.fracc] = {
        center: comm.center,
        zoom: comm.zoom
      };
    });
  }
  
  const modal = document.getElementById('lotModal');
  let currentFracc = (modal?.dataset.fracc || '').trim().toLowerCase();
  
  // 1. Try current modal fracc
  if (communities[currentFracc]) {
    return communities[currentFracc].center;
  }
  
  // 2. Try most recent selected lot
  if (window.selectedLots.size > 0) {
    const lastSelected = Array.from(window.selectedLots).pop();
    const lot = lotData.find(l => l.name === lastSelected);
    if (lot && lot.fraccionamiento) {
      const fracc = lot.fraccionamiento.toLowerCase();
      if (communities[fracc]) {
        return communities[fracc].center;
      }
    }
  }
  
  // 3. Dynamic: Find closest community to current map view
  if (map) {
    const currentCenter = map.getCenter();
    return findClosestCommunityCenter(currentCenter, communities);
  }
  
  // 4. Fallback to first community
  return communities[Object.keys(communities)[0]].center;
}

// üü¢ REUSABLE: Find closest community to any point
function findClosestCommunityCenter(point, communities) {
  let closestFracc = null;
  let closestDistance = Infinity;
  
  Object.keys(communities).forEach(fracc => {
    const communityCenter = communities[fracc].center;
    const distance = turf.distance(
      turf.point([point.lng, point.lat]),
      turf.point(communityCenter),
      { units: 'kilometers' }
    );
    
    if (distance < closestDistance) {
      closestDistance = distance;
      closestFracc = fracc;
    }
  }); 
  
  return communities[closestFracc].center;
}

// üü¢ ADD THIS FUNCTION FOR DYNAMIC ZOOM
function getCurrentFraccZoom() {
  const modal = document.getElementById('lotModal');
  let currentFracc = (modal?.dataset.fracc || '').trim().toLowerCase();

  // Build zoom levels from CONFIG
  const zooms = {};
  Object.keys(CONFIG.communities).forEach(key => {
    const comm = CONFIG.communities[key];
    zooms[comm.fracc] = comm.zoom;
  });

  // If fracc is 'poi' (placeholder for POI/pin), use current map zoom
  if (currentFracc === 'poi' && window.map) {
    return map.getZoom();
  }

  // If no fracc is set, detect it from current map position
  if (!currentFracc && window.map) {
    const center = map.getCenter();

    // Build communities object from CONFIG
    const communities = {};
    Object.keys(CONFIG.communities).forEach(key => {
      const comm = CONFIG.communities[key];
      communities[comm.fracc] = { center: comm.center };
    });

    // Find closest community to current map center
    const defaultComm = CONFIG.defaultCommunity;
    let closestFracc = defaultComm;
    let closestDistance = Infinity;

    Object.keys(communities).forEach(fracc => {
      const communityCenter = communities[fracc].center;
      const distance = Math.sqrt(
        Math.pow(center.lng - communityCenter[0], 2) +
        Math.pow(center.lat - communityCenter[1], 2)
      );

      if (distance < closestDistance) {
        closestDistance = distance;
        closestFracc = fracc;
      }
    });

    currentFracc = closestFracc;
  }

  return zooms[currentFracc] || (window.innerWidth >= 768 ? 17 : 16.45);
}

    // Open lot from URL on page load
    function openInitialLotModal() {
      const lotName = getLotFromURL();
      if (lotName) {
        console.log('üîó Opening lot from URL:', lotName);
        
        // Try to find the lot - handle different naming formats
        let lot = lotData.find(l => l.name === lotName);
        if (!lot) {
          // Try without "Lot" prefix
          const cleanName = lotName.replace(/^lot/i, '');
          lot = lotData.find(l => extractLotNumber(l.name) === cleanName);
        }
        
        if (lot) {
          console.log('üîó Found lot:', lot.name, 'Center:', lot.center);
          
          // üü¢ WAIT FOR LOT ANIMATION TO COMPLETE BEFORE OPENING MODAL
          const lotAnimationDuration = 20 * 80 + 500 + 200; // groups * delay + fadeDuration + finalDelay
          console.log('üîó Waiting for lot animation to complete:', lotAnimationDuration + 'ms');
          
          setTimeout(() => {
            console.log('üîó Lot animation complete, opening modal...');
            
            // üü¢ COMBINE ZOOM AND MODAL OPENING
            if (lot.center && map) {
              const [lng, lat] = lot.center;
              const isDesktop = window.innerWidth >= 768;
              const xOffset = isDesktop ? 310 : 0;
              const yOffset = isDesktop ? 0 : 180;
              
              // üü¢ OPEN MODAL FIRST (this will trigger the panBy)
              openModal(lot);
              
              // üü¢ THEN ZOOM TO THE LOT (accounting for modal offset)
              setTimeout(() => {
                map.flyTo({
                  center: [lng, lat],
                  zoom: getDetailZoom(lot),
                  speed: 1.2,
                  curve: 1.5,
                  offset: [xOffset, yOffset]
                });
                
                // Wait for zoom to complete, then show detail
                map.once('moveend', () => {
                  console.log('üîó Map zoom completed with modal open');
                  
                  // Show detail view FIRST
                  setTimeout(() => {
                    const baseIndex = baseLots.findIndex(l => l.name === lot.name);
                    if (baseIndex !== -1) {
                      // üü¢ HIDE THE PLUS BUTTON
                      const plusButton = document.querySelector('.plus-button');
                      if (plusButton) plusButton.style.display = 'none';
                      
                      // üü¢ SHOW DETAIL VIEW (this will handle dimensions internally)
                      showDetailViewForLot(baseIndex + cloneCount);
                      
                      // üü¢ UPDATE CURRENT LOT INDEX
                      const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                      if (lotMapIndex !== -1) {
                        currentLotIndex = lotMapIndex;
                        window.currentLotIndex = lotMapIndex;
                        if (window.hoveredId !== null) {
                          map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
                        }
                        map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                        window.hoveredId = lotMapIndex;
                      }
                    }
                  }, 400);
                });
              }, 100); // Small delay to ensure modal pan starts first
            }
          }, lotAnimationDuration); // Wait for lot animation to finish
        } else {
          console.warn('Lot not found:', lotName);
        }
      }
    }

    // Update URL when selecting lots (use query parameter)
    function updateLotURL(lotName) {
      const url = new URL(window.location);
      url.searchParams.set('lot', lotName);
      window.history.replaceState(null, '', url);
    }

    // Clear lot from URL when closing modal
    function clearLotURL() {
      const url = new URL(window.location);
      url.searchParams.delete('lot');
      window.history.replaceState(null, '', url);
    }

    // üü¢ FIX: PROPER FRACC-AWARE CLOSE BEHAVIOR
function closeModalWithZoomReset() {
  // Don't close modal if POI mode is active
  if (window.poiModeActive) return;

  const modal = document.getElementById('lotModal');
  if (!modal) return;

  // üü¢ CHECK if it's pin-mode BEFORE removing the class
  const wasPinMode = modal.classList.contains('pin-mode');

  // üü¢ Exit compare mode if active - SAME LOGIC AS closeModal()
  if (window.compareMode) {
    const compareBtn = document.getElementById('compareBtn');
    if (compareBtn) {
      compareBtn.classList.remove('active');
    }
    window.compareMode = false;
    window.selectedLots.clear();
    if (typeof removeEditOutlines === 'function') {
      removeEditOutlines();
    }
    console.log('Compare mode OFF (modal closed with zoom reset)');

    // üü¢ RESTORE from backup BEFORE clearing it
    if (window.originalBaseLots) {
      baseLots = [...window.originalBaseLots];
      window.originalBaseLots = null;
    }
  }

  // üî• Hide 360 viewer when closing modal
  const viewerContainer = document.getElementById('viewer-container');
  if (viewerContainer) {
    viewerContainer.style.display = 'none';
  }

  // Clear URL first
  clearLotURL();

  // Remove side length labels
  removeSideLengthLabels();

  // üü¢ FOR POI: Don't fly to fracc center, just stay at current location
  // üü¢ FOR LOT: Fly to fracc center as before
  if (!wasPinMode) {
    // Only fly to fracc center for lot modals (not POI)
    const fraccCenter = getCurrentFraccCenter();
    const initialZoom = getCurrentFraccZoom();

    if (map) {
      map.flyTo({
        center: fraccCenter,
        zoom: initialZoom,
        bearing: 0,
        pitch: 0,
        speed: 1.2,
        curve: 1.5
      });
    }

    // Clear fracc for lot modal
    modal.dataset.fracc = '';
  } else {
    // For pin mode, just undo the panBy offset (don't fly anywhere)
    if (map && lastOffset) {
      map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 400 });
      lastOffset = [0, 0];
    }
  }
  
  // Reset modal state
  const wrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const backButton = document.getElementById('backButton');
  const headerLotNumber = document.getElementById('headerLotNumber');
  const plusBtn = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');
  
  if (wrapper) wrapper.classList.remove('show-details');
  if (lotDetails) {
    lotDetails.classList.remove('active');
    lotDetails.style.display = 'block';
    lotDetails.innerHTML = '';
  }
  if (backButton) backButton.style.display = 'none';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  if (plusBtn) plusBtn.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';
  
  // Hide calendly if open
  const calendlyEl = document.getElementById('calendlyEmbed');
  if (calendlyEl) calendlyEl.style.display = 'none';

  // Hide share button when closing modal
  const shareBtn = document.getElementById('shareButton');
  if (shareBtn) shareBtn.style.display = 'none';

  // Hide global dashboard button when closing modal and remove active state
  const globalBtn = document.getElementById('globalDashboardButton');
  if (globalBtn) {
    globalBtn.classList.remove('active');  // Remove underline
    globalBtn.style.display = 'none';
  }

  // Reset dashboard button state when closing modal
  const dashboardBtn = document.getElementById('dashboard-btn');
  const eyeOpen = document.getElementById('eye-open-icon');
  const eyeClosed = document.getElementById('eye-closed-icon');
  if (dashboardBtn) {
    console.log('closeModalWithZoomReset: Resetting dashboard button state');
    dashboardBtn.classList.remove('active');
    if (eyeOpen) eyeOpen.style.display = 'none';  // Hide open eye
    if (eyeClosed) eyeClosed.style.display = 'inline-block';  // Show closed eye (dashboard hidden)
  }
  window.isDashboardOpen = false;

// Close modal with animation
modal.classList.remove('show', 'info-mode', 'pin-mode', 'expanded', 'lot-mode');

// üî• Clear immediately when show class is removed
if (map && map.getSource('lots-final') && window.hoveredId !== null) {
  try {
    map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
  } catch {}
}

setTimeout(() => {
  modal.style.display = 'none';

  // üü¢ SHOW FLOATING BUTTONS AGAIN
  document.getElementById('searchBtnStage')?.classList.remove('hide');
  document.getElementById('lalalandInfoBtn')?.classList.remove('hide');

  // üî• Clear hover states AFTER modal is fully closed
  if (map && map.getSource('lots-final')) {
    try {
      if (window.hoveredId !== null) {
        map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
      }

      lotData.forEach((lot, index) => {
        try {
          map.setFeatureState({ source: 'lots-final', id: index }, { hover: false });
        } catch {}
      });

      window.hoveredId = null;
    } catch {}
  }
  
  // üî• Clear one more time after another frame
  requestAnimationFrame(() => {
    if (map && map.getSource('lots-final')) {
      lotData.forEach((lot, index) => {
        try {
          map.setFeatureState({ source: 'lots-final', id: index }, { hover: false });
        } catch {}
      });
    }
  });
}, 50);
  
  // Reset internal states
  isDetailOpen = false;
  scrollHandlerAttached = true;
}


    // Handle URL changes - for browser navigation AFTER initial load
    function handleURLChange() {
      const lotName = getLotFromURL();
      if (lotName) {
        const lot = lotData.find(l => l.name === lotName) || 
                   lotData.find(l => extractLotNumber(l.name) === lotName.replace(/^lot/i, ''));
        
        if (lot && lot.center && map) {
          const [lng, lat] = lot.center;
          const isDesktop = window.innerWidth >= 768;
          const xOffset = isDesktop ? 310 : 0;
          const yOffset = isDesktop ? 0 : 180;
          
          const modal = document.getElementById('lotModal');
          const isModalOpen = modal.classList.contains('show');
          
          if (isModalOpen) {
            // üü¢ MODAL IS ALREADY OPEN - JUST UPDATE THE VIEW
            map.flyTo({
              center: [lng, lat],
              zoom: getDetailZoom(lot),
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
            
            map.once('moveend', () => {
              // üü¢ REMOVE EXISTING LABELS BEFORE SHOWING DETAIL
              removeSideLengthLabels();
              
              // Update detail view if in detail mode
              if (isDetailOpen) {
                const baseIndex = baseLots.findIndex(l => l.name === lot.name);
                if (baseIndex !== -1) {
                  const plusButton = document.querySelector('.plus-button');
                  if (plusButton) plusButton.style.display = 'none';
                  
                  const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                  if (lotMapIndex !== -1) {
                    currentLotIndex = lotMapIndex;
                    window.currentLotIndex = lotMapIndex;
                    if (window.hoveredId !== null) {
                      map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
                    }
                    map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                    window.hoveredId = lotMapIndex;
                  }

                  showDetailViewForLot(baseIndex + cloneCount, true);
                }
              }
            });
          } else {
            // üü¢ MODAL IS CLOSED - OPEN IT FIRST, THEN ZOOM
            openModal(lot);
            
            setTimeout(() => {
              map.flyTo({
                center: [lng, lat],
                zoom: getDetailZoom(lot),
                speed: 1.2,
                curve: 1.5,
                offset: [xOffset, yOffset]
              });
              
              map.once('moveend', () => {
                // üü¢ REMOVE ANY EXISTING LABELS
                removeSideLengthLabels();
                
                setTimeout(() => {
                  const baseIndex = baseLots.findIndex(l => l.name === lot.name);
                  if (baseIndex !== -1) {
                    const plusButton = document.querySelector('.plus-button');
                    if (plusButton) plusButton.style.display = 'none';
                    
                    const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                    if (lotMapIndex !== -1) {
                      currentLotIndex = lotMapIndex;
                      window.currentLotIndex = lotMapIndex;
                      if (window.hoveredId !== null) {
                        map.setFeatureState({ source: 'lots-final', id: window.hoveredId }, { hover: false });
                      }
                      map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                      window.hoveredId = lotMapIndex;
                    }

                    showDetailViewForLot(baseIndex + cloneCount);
                  }
                }, 400);
              });
            }, 100);
          }
        }
      } else {
        // No lot in URL - close modal with zoom reset
        closeModalWithZoomReset();
      }
    }

    // Listen for URL changes
    window.addEventListener('popstate', handleURLChange);

    // üü¢ REPLACE THE CLOSE MODAL FUNCTION
    window.closeModal = closeModalWithZoomReset;

    // Initialize - open lot from URL if present
    openInitialLotModal();

    console.log('üîó Deep linking initialized - fracc-aware close behavior');
  }, 2000);
})();

// Share functionality
function setupShareButton() {
  const shareButton = document.getElementById('shareButton');
  if (!shareButton) return;

  shareButton.addEventListener('click', function() {
    shareCurrentLot();
  });
}

function shareCurrentLot() {
  // Get current lot information
  let lotName = '';
  let lotNumber = '';
  
  // METHOD 1: Try to get from detail view (more reliable)
  const detailContainer = document.querySelector('.lot-details.active');
  if (detailContainer) {
    // Look for the lot number in the detail view
    const lotNumberEl = detailContainer.querySelector('.lote-number');
    if (lotNumberEl) {
      lotNumber = lotNumberEl.textContent.trim();
      
      // Also try to get the ID text if available
      const idText = detailContainer.querySelector('div[style*="font-size: 14px"]');
      if (idText && idText.textContent.includes('ID:')) {
        const idMatch = idText.textContent.match(/ID:\s*(\S+)/);
        if (idMatch) {
          lotName = idMatch[1]; // This should be the full lot name
        }
      }
    }
  }
  
  // METHOD 2: If we have lotNumber but not lotName, try to find it in the data
  if (lotNumber && !lotName) {
    // Search through all lot data to find matching lot
    const foundLot = lotData.find(l => extractLotNumber(l.name) === lotNumber);
    if (foundLot) {
      lotName = foundLot.name;
    }
  }
  
  // METHOD 3: Fallback - use currentLotIndex if available
  if (!lotName && typeof currentLotIndex !== 'undefined' && currentLotIndex !== -1) {
    const currentLot = lotData[currentLotIndex];
    if (currentLot) {
      lotName = currentLot.name;
      lotNumber = extractLotNumber(currentLot.name);
    }
  }
  
  // METHOD 4: Last resort - try to get from centered row in list
  if (!lotName) {
    const centeredRow = document.querySelector('.info-row.center .lote-number');
    if (centeredRow) {
      lotNumber = centeredRow.textContent.trim();
      const foundLot = lotData.find(l => extractLotNumber(l.name) === lotNumber);
      if (foundLot) {
        lotName = foundLot.name;
      }
    }
  }
  
  if (!lotName) {
    console.warn('No lot found to share');
    showToaster('Selecciona un lote para compartir');
    return;
  }
  
  // Get selected plan index
  const selectedPlan = document.getElementById('downPaymentCalc')?.value || '0';

  // Get community from modal dataset (current selected fracc), fallback to lot data, then default
  const modal = document.getElementById('lotModal');
  let community = modal?.dataset?.fracc;

  // If no modal fracc, try to get from lot data
  if (!community) {
    const lotObject = lotData.find(l => l.name === lotName);
    community = lotObject?.fraccionamiento || CONFIG.defaultCommunity;
  }

  const communitySlug = community.toLowerCase().replace(/\s+/g, '-');
  const communityCapitalized = community.charAt(0).toUpperCase() + community.slice(1);

  // Create share URL with community prefix and plan param
  const shareUrl = `${window.location.origin}${CONFIG.share.urlTemplate
    .replace('{slug}', CONFIG.slug)
    .replace('{communitySlug}', communitySlug)
    .replace('{lotNumber}', lotNumber)}?plan=${selectedPlan}`;
  const shareText = CONFIG.share.textTemplate
    .replace('{lotNumber}', lotNumber)
    .replace('{community}', communityCapitalized)
    .replace('{name}', CONFIG.name);

  console.log('üîó Share attempt:', { lotName, lotNumber, community, communitySlug, shareUrl });

  // Check if mobile device
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  if (isMobile) {
    // On mobile, offer WhatsApp direct share
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
    window.open(whatsappUrl, '_blank');
    showToaster('Opening WhatsApp... üì±');
  } else if (navigator.share) {
    // Desktop/tablet - try native share API
    setTimeout(() => {
      navigator.share({
        title: `Lote ${lotNumber} - Lalaland`,
        text: shareText,
        url: shareUrl
      }).then(() => {
        console.log('‚úÖ Share successful');
        showToaster('Shared successfully! üì§');
      }).catch((error) => {
        console.log('‚ùå Share failed or cancelled:', error);
        if (error.name !== 'AbortError') {
          fallbackShare(shareUrl, lotNumber, communityCapitalized);
        }
      });
    }, 100);
  } else {
    fallbackShare(shareUrl, lotNumber, communityCapitalized);
  }
}

function fallbackShare(url, lotNumber, community) {
  // üü¢ IMPROVED FALLBACK WITH BETTER UX
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(url).then(() => {
      showToaster(`Link to Lote ${lotNumber} de ${community} copied! üìã`);
    }).catch(() => {
      // Clipboard failed, use prompt
      copyViaPrompt(url, lotNumber, community);
    });
  } else {
    // No clipboard API
    copyViaPrompt(url, lotNumber, community);
  }
}

function copyViaPrompt(url, lotNumber, community) {
  const input = document.createElement('input');
  input.value = url;
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);

  try {
    const successful = document.execCommand('copy');
    document.body.removeChild(input);
    if (successful) {
      showToaster(`Link to Lote ${lotNumber} de ${community} copied! üìã`);
    } else {
      showToaster(`Select and copy this link:\n${url}`);
    }
  } catch (err) {
    document.body.removeChild(input);
    showToaster(`Share this link:\n${url}`);
  }
}

// Initialize share button when page loads
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(setupShareButton, 1000);
});


// Add this function to check current time in Mexico City (Monday-Friday only)
// Add this function to check current time in Mexico City (Monday-Friday only)
function isBusinessHours() {
  const now = new Date();
  
  // Convert to Mexico City time using toLocaleString
  const mexicoCityTime = now.toLocaleString("en-US", {
    timeZone: "America/Mexico_City",
    hour: "2-digit",
    hour12: false,
    weekday: "long"
  });
  
  // Parse the formatted string - it will be like "Monday, 14" or "Friday, 09"
  const [weekday, hourPart] = mexicoCityTime.split(', ');
  const mexicoCityHour = parseInt(hourPart);
  
  console.log('Mexico City time:', { weekday, hour: mexicoCityHour }); // Debug log
  
  // Business hours: Monday-Friday, 8am to 8pm (9-20 in 24h format)
  const isWeekday = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].includes(weekday);
  const isBusinessHour = mexicoCityHour >= 8 && mexicoCityHour < 20;
  
  return isWeekday && isBusinessHour;
}

// Alternative simpler version if the above doesn't work:
function isBusinessHoursSimple() {
  const now = new Date();
  
  // Use UTC methods with Mexico City offset (UTC-6 for CST, UTC-5 for CDT)
  // This is a simplified approach that should work
  const utcHour = now.getUTCHours();
  const utcDay = now.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  
  // Mexico City is UTC-6 (CST) or UTC-5 (CDT)
  // For simplicity, we'll use UTC-6 (you may need to adjust for daylight saving)
  const mexicoCityHour = (utcHour - 6 + 24) % 24;
  
  // Business hours: Monday-Friday (1-5), 8am to 8pm
  const isWeekday = utcDay >= 1 && utcDay <= 5; // Monday to Friday
  const isBusinessHour = mexicoCityHour >= 8 && mexicoCityHour < 20;
  
  console.log('Simple check:', { utcHour, mexicoCityHour, utcDay, isWeekday, isBusinessHour });
  
  return isWeekday && isBusinessHour;
}

// Use the simple version for now to test
function isBusinessHours() {
  return isBusinessHoursSimple();
}

// Function to update header visibility with clock icon
function updateChatHeaderVisibility() {
  // Select all cta-header-label elements and get the last one (the one with inline color styling)
  const allLabels = document.querySelectorAll('.cta-header-label');
  const ctaHeaderLabel = allLabels[allLabels.length - 1];

  if (ctaHeaderLabel) {
    const isOpen = isBusinessHours();
    
    if (isOpen) {
      ctaHeaderLabel.innerHTML = `
<svg width="12" height="12" viewBox="0 0 24 24" fill="${CONFIG.colors.primary}" style="margin-right:4px; vertical-align:middle;">
  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/>
</svg>
        DISPONIBLE AHORA
      `;
      ctaHeaderLabel.style.visibility = 'visible';
      ctaHeaderLabel.style.opacity = '1';
    } else {
      ctaHeaderLabel.style.visibility = 'hidden';
      ctaHeaderLabel.style.opacity = '0';
    }
  }
}

// Update the button click handler to always open WhatsApp
function setupChatButton() {
  const chatButton = document.getElementById('chatearBtn');
  if (chatButton) {
    chatButton.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      window.open('https://wa.me/5218185261819', '_blank');
    });
  }
}

// Initialize and set up interval to check time
function initChatAvailability() {
  updateChatHeaderVisibility();
  setupChatButton();
  
  // Check every minute to update status
  setInterval(updateChatHeaderVisibility, 60000);
}

// Call this function when your detail view is created
// Add this to your showDetailViewForLot function after creating the CTA section:
function initChatAvailability() {
  updateChatHeaderVisibility();
  setupChatButton();
  
  // Check every minute to update status
  setInterval(updateChatHeaderVisibility, 60000);
}
</script>

<script>
// ===== EDIT MODE FUNCTIONALITY =====
// Declare on window object to ensure global access
window.window.editMode = false;
window.compareMode = false;
window.window.selectedLots = new Set();

// Compare button event listener
document.getElementById('compareBtn').addEventListener('click', function() {
    window.compareMode = !window.compareMode;

    if (window.compareMode) {
        // Enter compare mode
        this.classList.add('active');
        showToaster('üîç Compare mode ON - Click lots to compare');
        console.log('Compare mode ON');

        // üü¢ AUTO-SELECT currently centered lot as first comparison
        const centeredRow = document.querySelector('.info-row.center, .info-row.active');
        if (centeredRow) {
            const baseIndex = parseInt(centeredRow.dataset.baseIndex, 10);
            if (!isNaN(baseIndex) && baseIndex >= 0 && baseLots[baseIndex]) {
                const lot = baseLots[baseIndex];
                const lotName = `lot${lot.number}`;
                window.window.selectedLots.add(lotName);
                console.log('Auto-selected centered lot:', lotName);

                // Apply visual overlay
                if (typeof updateEditOutlines === 'function') {
                    updateEditOutlines();
                }
            }
        }

        // üü¢ FIX: Ensure data is loaded before compare mode
        if (!isDataLoaded) {
            fetchLots().then(() => {
                console.log('Data loaded for compare mode');
            });
        }
    } else {
        // Exit compare mode
        this.classList.remove('active');
        window.window.selectedLots.clear();
        removeEditOutlines();
        
        // üü¢ RESTORE original baseLots
        if (window.originalBaseLots) {
            baseLots = window.originalBaseLots;
            updateLotsArray();
            window.originalBaseLots = null; // Clean up
        }
        
        // Restore normal list
        if (isDataLoaded) {
            render();
        }
        showToaster('Compare mode OFF');
        console.log('Compare mode OFF');
    }
});

// Edit button event listener
document.getElementById('editBtn').addEventListener('click', function() {
    window.editMode = !window.editMode;
    
    if (window.editMode) {
        // Enter edit mode
        this.style.boxShadow = `0 0 0 3px ${CONFIG.colors.primaryFull}`;
        this.style.backgroundColor = CONFIG.colors.primary;
        showToaster('‚úèÔ∏è Edit mode ON - Edit prices in detail view');
        console.log('Edit mode ON');
} else {
    // Exit edit mode
    this.style.boxShadow = '';
    this.style.backgroundColor = CONFIG.colors.cream;
    showToaster('Edit mode OFF');
    console.log('Edit mode OFF');
}
});

// Compare mode click handler (renamed from handleEditClick)
function handleEditClick(e) {
  if (!window.compareMode) return false;
  
  // üü¢ CHECK IF CLICKING ON MARBLES (NOT LOTS)
  const marbleFeatures = map.queryRenderedFeatures(e.point, { 
    layers: ['marbles-click-layer'] 
  });
  
  if (marbleFeatures.length > 0) {
    // This is a marble click, not a lot click - let the marble handler deal with it
    return false;
  }
  
  console.log('Compare click detected');
  
  // Rest of your existing edit mode logic...
  if (e.features && e.features.length > 0) {
    const feature = e.features[0];
    const lotName = feature.properties.name;
    const lotNumber = extractLotNumber(lotName);
    
    // Toggle selection
    if (window.selectedLots.has(lotName)) {
      window.selectedLots.delete(lotName);
      showToaster(`‚ùå Removed ${lotNumber}`);
    } else {
      window.selectedLots.add(lotName);
      showToaster(`‚úÖ Added ${lotNumber}`);
    }
    
    console.log('Selected lots:', Array.from(window.selectedLots));
    
    // Update visuals
    updateEditOutlines();
    updateModalList();
    
    // Stop normal modal from opening
    e.preventDefault();
    if (e.originalEvent) {
      e.originalEvent.stopPropagation();
    }
    return true;
  }
  return false;
}

// Update outlines - SIMPLE ORANGE LINES
// Update outlines - WHITE FILL INSTEAD OF ORANGE OUTLINE
function updateEditOutlines() {
    // Remove old outlines
    removeEditOutlines();
    
    if (!map || window.selectedLots.size === 0) return;
    
    // Add white fill using map layers
    window.selectedLots.forEach(lotName => {
        const lot = lotData.find(l => l.name === lotName);
        if (lot) {
            // Create a simple source for this lot
            const sourceId = `edit-outline-${lotName}`;
            const layerId = `edit-outline-layer-${lotName}`;
            
            // Remove existing if any
            if (map.getLayer(layerId)) map.removeLayer(layerId);
            if (map.getSource(sourceId)) map.removeSource(sourceId);
            
            // Create source with lot polygon
            const coords = [...lot.coords];
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push(coords[0]);
            }
            
            map.addSource(sourceId, {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [coords]
                    }
                }
            });
            
            // Add white fill layer instead of orange outline
            map.addLayer({
                id: layerId,
                type: 'fill',
                source: sourceId,
paint: {
    'fill-color': CONFIG.colors.cream,
    'fill-opacity': 0.4, // Very subtle orange

}
            }, 'lots-final-click'); // Add above existing layers
        }
    });
}

// Remove outlines
function removeEditOutlines() {
    if (!map) return;
    
    try {
        // Get current style
        const style = map.getStyle();
        if (!style || !style.layers) return;
        
        // Remove all edit outline layers and sources safely
        style.layers.forEach(layer => {
            if (layer.id && layer.id.startsWith('edit-outline-layer-')) {
                try {
                    if (map.getLayer(layer.id)) {
                        map.removeLayer(layer.id);
                    }
                } catch (e) {
                    console.log('Could not remove layer:', layer.id);
                }
            }
        });
        
        // Remove sources
        Object.keys(style.sources || {}).forEach(sourceId => {
            if (sourceId.startsWith('edit-outline-')) {
                try {
                    if (map.getSource(sourceId)) {
                        map.removeSource(sourceId);
                    }
                } catch (e) {
                    console.log('Could not remove source:', sourceId);
                }
            }
        });
    } catch (error) {
        console.log('Error removing edit outlines:', error);
    }
}


// Update modal list - FIXED VERSION with multiple communities support
function updateModalList() {
    const modal = document.getElementById('lotModal');
    const modalInfo = document.getElementById('modalInfo');
    
    if (window.selectedLots.size === 0) {
        if (modal.classList.contains('show')) {
            modalInfo.innerHTML = `<div style="padding:20px; text-align:center; color:${CONFIG.colors.textLight};">Select lots to compare</div>`;
            // Restore normal baseLots if no selections
            if (window.originalBaseLots) {
                baseLots = window.originalBaseLots;
                updateLotsArray();
                window.originalBaseLots = null;
            }
        }
        return;
    }
    
    // üü¢ FIX: Don't call openModal() - just show modal if needed
    if (!modal.classList.contains('show')) {
        modal.classList.add('show', 'lot-mode');
        modal.style.display = 'block';
        adjustMapForModal();
        
        // Hide floating buttons
        document.getElementById('searchBtnStage')?.classList.add('hide');
        document.getElementById('lalalandInfoBtn')?.classList.add('hide');
    }
    
    // Get selected lots data
    const selectedBaseLots = [];
    let uniqueFraccs = new Set(); // üü¢ NEW: Track communities

    window.selectedLots.forEach(lotName => {
        const baseLot = window.baseLotsAll.find(bl => bl.name === lotName);
        if (baseLot) {
            selectedBaseLots.push({...baseLot});
            // üü¢ NEW: Collect all unique communities
            if (baseLot.fraccionamiento) {
                uniqueFraccs.add(baseLot.fraccionamiento);
            }
        }
    });
    
    console.log('Selected base lots:', selectedBaseLots);
    console.log('Unique communities:', Array.from(uniqueFraccs)); // üü¢ NEW: Debug log
    
    if (selectedBaseLots.length > 0) {
        // üü¢ STORE original and REPLACE baseLots completely
        if (!window.originalBaseLots) {
            window.originalBaseLots = [...baseLots];
        }
        
        baseLots = selectedBaseLots;
        updateLotsArray();
        
        // üü¢ NEW: Update header for single or multiple communities
        let headerText;
        if (uniqueFraccs.size === 1) {
            headerText = Array.from(uniqueFraccs)[0].toUpperCase();
        } else if (uniqueFraccs.size > 1) {
            headerText = 'MULTIPLE COMMUNITIES';
        } else {
            headerText = 'COMPARING LOTS';
        }
        
        document.getElementById('headerFracc').textContent = headerText;
        modal.dataset.fracc = 'multiple';
        
        render();
    }
}

// Update outlines on map move
if (map) {
    map.on('move', function() {
        if (window.compareMode && window.selectedLots.size > 0) {
            // For map layers, they auto-update with map movement
        }
    });
}
</script>

<script>
// ===== MISSING UTILITY FUNCTIONS =====
function calculateBounds(coordinates) {
  if (!coordinates.length) return null;
  const b = new mapboxgl.LngLatBounds();
  coordinates.forEach(c => b.extend(c));
  return b;
}

// UI status function
function setStatus(msg) { 
  console.log(msg); 
  // Optional: show in your toaster if you want
  // showToaster(msg);
}

async function selectTrackAndThenMarble(trackId, marbleId) {
  if (isSwitchingTrack) return;
  isSwitchingTrack = true;

  const prevTrackId = currentTrackId;
  try {
    // Await track switch to ensure images are loaded before showing marble
    await selectTrackWithoutMapReset(trackId);

    selectMarble(marbleId);

    // üü¢ Use showMarbleImage to properly handle viewer initialization
    showMarbleImage(marbleId);

    console.log(`Switched to ${allTracks.get(trackId).name} and selected marble`);
  } catch (err) {
    console.error('Switch error', err);
    if (prevTrackId) await selectTrackWithoutMapReset(prevTrackId);
  } finally {
    isSwitchingTrack = false;
  }
}

function resetViewerState() {
  // Reset 360 viewer globals
  currentTrackId = null;
  selectedMarbleId = null;
  currentImages = [];
  currentImageIndex = -1;
  isSwitchingTrack = false;

  // Reset any Three.js scene if needed
  if (renderer) {
    // Clean up Three.js resources if necessary
  }
}

// ===== STRIPE PAYMENT INTEGRATION =====
let stripe;
let elements;
let currentLotForPayment = null;

// Initialize Stripe (replace with your publishable key from Stripe Dashboard)
// Get from: https://dashboard.stripe.com/apikeys
const STRIPE_PUBLISHABLE_KEY = 'pk_live_51SUyrPAEnfV8qRCZ8Yk6sDkOXmTXXErSyH2KrMwyMxm3URTaR0apwHYf6iZb7JHYRRXAkLsHhXYdcCWuFd34WBJM00DnuDoOwX';

// Fixed reservation amount
const RESERVATION_AMOUNT = 5000; // 5,000 MXN

// Show payment view in the existing modal (like a second page)
async function showPaymentViewInModal(lot) {
  currentLotForPayment = lot;

  // Store the lot index for going back
  const baseIndex = baseLots.findIndex(l => l.name === lot.name);
  if (baseIndex !== -1) {
    lastOpenedBaseIndex = baseIndex;
  }
  const lotDetails = document.getElementById('lotDetails');

  // Clear and create payment content
  lotDetails.innerHTML = '';

  // Enable payment mode styling for scrolling
  lotDetails.classList.add('payment-mode');

  lotDetails.innerHTML = `
    <div class="payment-scroll-wrapper" style="height: 100%; overflow-y: auto; overflow-x: hidden; padding: 16px; padding-bottom: 80px;">
      <div style="margin-bottom: 24px;">
        <h2 style="font-size: 28px; font-weight: 700; color: ${CONFIG.colors.primary}; text-align: center; margin-bottom: 8px;">APARTAR LOTE ${lot.number}</h2>
        <p style="font-size: 16px; color: ${CONFIG.colors.textLight}; text-align: center; margin-bottom: 24px;">Monto de separaci√≥n: <span style="color: ${CONFIG.colors.primary}; font-weight: 700; font-size: 20px;">$${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN</span></p>
      </div>

<!-- Reservation Process Steps -->
<div style="background: ${CONFIG.colors.primaryFaint}; border-left: 4px solid ${CONFIG.colors.primary}; padding: 16px; margin-bottom: 24px; border-radius: 4px;">
  <h3 style="color: ${CONFIG.colors.primary}; font-size: 18px; font-weight: 700; margin-bottom: 12px;">üìç Separa con $5,000 MXN:</h3>
  <p style="color: ${CONFIG.colors.textDark}; font-size: 14px; line-height: 1.6; margin-bottom: 16px;">
    Elige tu lote y realiza tu primera separaci√≥n de $5,000 MXN. 
    <strong>Recibir√°s $4,758.72 MXN de reembolso</strong> si cambias de opini√≥n 
    (equivalente al monto total menos cargos de procesamiento).
    <br><span style="color: ${CONFIG.colors.primary}; font-weight: 600;">¬°Aseguras el lote y tu inversi√≥n est√° protegida!</span>
  </p>

  <h3 style="color: ${CONFIG.colors.primary}; font-size: 18px; font-weight: 700; margin-bottom: 12px;">‚úÖ Confirma en 24 Horas:</h3>
  <p style="color: ${CONFIG.colors.textDark}; font-size: 14px; line-height: 1.6; margin-bottom: 16px;">
    Tienes 24 horas para completar tu separaci√≥n con un segundo dep√≥sito de $5,000 MXN
    <span id="paymentMessageText">${CONFIG.contact.paymentMessage}</span>
    <br><span id="ctaMessageText" style="font-weight: 600; color: ${CONFIG.misc.ctaColor};">${CONFIG.misc.ctaMessage}</span>
  </p>

  <h3 style="color: ${CONFIG.colors.primary}; font-size: 18px; font-weight: 700; margin-bottom: 12px;">üìù Firma tu Contrato en 10 D√≠as:</h3>
  <p style="color: ${CONFIG.colors.textDark}; font-size: 14px; line-height: 1.6;">
    Durante la semana siguiente, nuestro equipo te ayudar√° con toda la papeler√≠a 
    y la firma formal de tu contrato de compraventa.
    <br><span style="color: ${CONFIG.colors.primary}; font-weight: 600;">Tiempo m√°s que suficiente para tomar la mejor decisi√≥n con tranquilidad.</span>
  </p>
</div>

      <!-- Contact Information -->
      <div style="background: white; padding: 12px; border-radius: 4px; box-shadow: 0 1px 3px ${CONFIG.colors.overlayFaint}; margin-bottom: 12px;">
        <h3 style="color: ${CONFIG.colors.primary}; font-size: 14px; font-weight: 700; margin-bottom: 10px;">Informaci√≥n de Contacto</h3>

        <div style="margin-bottom: 10px;">
          <label style="display: block; color: ${CONFIG.colors.textDark}; font-size: 13px; font-weight: 600; margin-bottom: 4px;">Nombre Completo *</label>
          <input type="text" id="customer-name" required style="width: 100%; padding: 8px; border: 1px solid ${CONFIG.colors.grayLightest}; border-radius: 3px; font-size: 13px; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif; box-sizing: border-box;" placeholder="Juan P√©rez">
        </div>

        <div style="margin-bottom: 10px;">
          <label style="display: block; color: ${CONFIG.colors.textDark}; font-size: 13px; font-weight: 600; margin-bottom: 4px;">Email *</label>
          <input type="email" id="customer-email" required style="width: 100%; padding: 8px; border: 1px solid ${CONFIG.colors.grayLightest}; border-radius: 3px; font-size: 13px; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif; box-sizing: border-box;" placeholder="tu@email.com">
        </div>

        <div style="margin-bottom: 0;">
          <label style="display: block; color: ${CONFIG.colors.textDark}; font-size: 13px; font-weight: 600; margin-bottom: 4px;">Tel√©fono *</label>
          <input type="tel" id="customer-phone" required style="width: 100%; padding: 8px; border: 1px solid ${CONFIG.colors.grayLightest}; border-radius: 3px; font-size: 13px; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif; box-sizing: border-box;" placeholder="55 1234 5678">
        </div>
      </div>

      <!-- Stripe Payment Element -->
      <div id="stripe-payment-element" style="margin-bottom: 16px; width: 100%; padding: 0; background: white; border-radius: 4px; box-shadow: 0 1px 3px ${CONFIG.colors.overlayFaint}; box-sizing: border-box;">
        <div style="text-align: center; color: ${CONFIG.colors.textLight}; padding: 20px 10px;">Cargando formulario de pago...</div>
      </div>

      <!-- Error message -->
      <div id="payment-error" style="color: ${CONFIG.colors.error}; margin-bottom: 16px; text-align: center; display: none; font-size: 14px;"></div>

      <!-- Payment Button (Single Step) -->
      <div id="payment-button-wrapper" style="text-align: center; margin-bottom: 60px;">
        <button id="submit-payment" style="width: 100%; max-width: 400px; padding: 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: 700; background: ${CONFIG.colors.primary}; color: ${CONFIG.colors.cream}; font-family: '${CONFIG.misc.fontFamily}', Arial, sans-serif; font-size: 18px;">
          PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN
        </button>
      </div>
    </div>
  `;

  // Initialize payment immediately (single-step flow)
  initializePayment();
}

// Initialize payment immediately (single-step flow)
async function initializePayment() {
  // Show loading in payment button
  const submitBtn = document.getElementById('submit-payment');
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.textContent = 'CARGANDO...';
  }

  // Initialize Stripe and create payment
  try {
    // Check if Stripe key is configured
    if (STRIPE_PUBLISHABLE_KEY === 'pk_test_YOUR_PUBLISHABLE_KEY_HERE') {
      throw new Error('Stripe publishable key not configured. Get key from https://dashboard.stripe.com/apikeys');
    }

    // Initialize Stripe if not already done
    if (!stripe) {
      stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
    }

    // Create payment intent using Supabase Edge Function
    await window.supabaseReady;
    const supabaseUrl = window.supabaseClient?.supabaseUrl;
    const supabaseKey = window.supabaseClient?.supabaseKey;

    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Supabase not initialized. Check Supabase configuration.');
    }

    const lot = currentLotForPayment;
    if (!lot) {
      throw new Error('No lot selected for payment');
    }

    // Find the lot_name from lotData for database update via webhook
    const lotMapData = lotData.find(l => extractLotNumber(l.name) === lot.number);
    const lotName = lotMapData?.name || '';

    // Get customer info from form (will be validated on submission)
    const emailInput = document.getElementById('customer-email');
    const phoneInput = document.getElementById('customer-phone');

    // Call Supabase Edge Function with customer info
    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/create-payment-intent`;

    const response = await fetch(edgeFunctionUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': supabaseKey, // Required for non-authenticated edge function calls
      },
      body: JSON.stringify({
        amount: RESERVATION_AMOUNT * 100, // Stripe expects cents
        lotNumber: lot.number,
        lotName: lotName, // For webhook to update database (e.g., "lotinverta17-17")
        lotId: lot.id,
        client_id: CURRENT_CLIENT, // Add client_id for non-authenticated purchases
        customer_email: emailInput?.value || 'guest', // Use form value or guest
        customer_phone: phoneInput?.value || ''  // Use form value or empty
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Edge function error: ${response.status} - ${errorText}`);
    }

    const { clientSecret } = await response.json();

    if (!clientSecret) {
      throw new Error('No client secret returned from payment intent');
    }

    // Create Elements instance (disable Link for cleaner UX)
    elements = stripe.elements({
      clientSecret,
      appearance: {
        theme: 'stripe'
      },
      loader: 'auto',
      locale: 'es' // Use Spanish locale
    });

    // Create and mount Payment Element (billing info collected in our form)
    const paymentElement = elements.create('payment', {
      layout: {
        type: 'tabs',
        defaultCollapsed: false
      },
      terms: {
        card: 'never'
      },
      wallets: {
        applePay: 'never',
        googlePay: 'never'
      }
    });
    paymentElement.mount('#stripe-payment-element');

    // Re-enable submit button now that form is ready
    const submitBtn = document.getElementById('submit-payment');
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.textContent = `PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN`;
    }

    // Add event listener for payment submission
    document.getElementById('submit-payment')?.addEventListener('click', handlePaymentSubmit);

  } catch (error) {
    console.error('Error initializing payment:', error);
    showPaymentError(error.message || 'Error al inicializar el pago. Por favor intenta de nuevo.');

    // Re-enable submit button on error
    const submitBtn = document.getElementById('submit-payment');
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.textContent = `PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN`;
    }
  }
}

// Show payment error
function showPaymentError(message) {
  const errorDiv = document.getElementById('payment-error');
  if (errorDiv) {
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }
}

// Handle payment submission
async function handlePaymentSubmit(e) {
  e?.preventDefault();

  if (!stripe || !elements) {
    showPaymentError('Error al procesar el pago');
    return;
  }

  // Get customer info for validation and billing details
  const nameInput = document.getElementById('customer-name');
  const emailInput = document.getElementById('customer-email');
  const phoneInput = document.getElementById('customer-phone');

  // Validate customer info first
  if (!nameInput?.value || nameInput.value.trim().length < 3) {
    showPaymentError('Por favor ingresa tu nombre completo');
    return;
  }

  if (!emailInput?.value || !emailInput.value.includes('@')) {
    showPaymentError('Por favor ingresa un email v√°lido');
    return;
  }

  if (!phoneInput?.value || phoneInput.value.length < 10) {
    showPaymentError('Por favor ingresa un tel√©fono v√°lido');
    return;
  }

  const submitBtn = document.getElementById('submit-payment');
  if (!submitBtn) return;

  // Disable submit button
  submitBtn.disabled = true;
  submitBtn.textContent = 'PROCESANDO...';

  try {
    // Validate Stripe elements
    const { error: submitError } = await elements.submit();
    if (submitError) {
      showPaymentError(submitError.message);
      submitBtn.disabled = false;
      submitBtn.textContent = `PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN`;
      return;
    }

    // Confirm payment with billing details
    const { error } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: window.location.href,
        payment_method_data: {
          billing_details: {
            name: nameInput.value,
            email: emailInput.value,
            phone: phoneInput.value,
          }
        }
      },
      redirect: 'if_required',
    });

    if (error) {
      showPaymentError(error.message);
      submitBtn.disabled = false;
      submitBtn.textContent = `PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN`;
    } else {
      // Payment successful! Webhook will update database automatically
      console.log('Payment succeeded - webhook will update lot status');

      // Change button to VENDIDO state (don't close modal)
      submitBtn.textContent = 'APARTADO';
      submitBtn.disabled = true;
      submitBtn.style.opacity = '0.5';
      submitBtn.style.cursor = 'not-allowed';
      submitBtn.style.background = CONFIG.colors.textLight; // Grayed out

      // Show success message
      window.showToaster?.('¬°Pago exitoso! El lote ha sido apartado.');

      // Trigger confetti in bottom 50% of screen with high z-index
      if (typeof confetti !== 'undefined') {
        const confettiCanvas = document.createElement('canvas');
        confettiCanvas.style.position = 'fixed';
        confettiCanvas.style.top = '0';
        confettiCanvas.style.left = '0';
        confettiCanvas.style.width = '100%';
        confettiCanvas.style.height = '100%';
        confettiCanvas.style.pointerEvents = 'none';
        confettiCanvas.style.zIndex = '999999'; // Higher than modal
        document.body.appendChild(confettiCanvas);

        const myConfetti = confetti.create(confettiCanvas, { resize: true });

        // Confetti in bottom 50% of screen
        myConfetti({
          particleCount: 150,
          spread: 90,
          origin: { x: 0.5, y: 0.75 }, // Bottom 50% (75% from top)
          colors: [CONFIG.colors.primary, CONFIG.colors.cream, CONFIG.colors.textTan],
          ticks: 200
        });

        // Additional burst
        setTimeout(() => {
          myConfetti({
            particleCount: 100,
            spread: 70,
            origin: { x: 0.5, y: 0.75 },
            colors: [CONFIG.colors.primary, CONFIG.colors.cream, CONFIG.colors.textTan],
            ticks: 150
          });
        }, 250);

        // Clean up canvas after animation
        setTimeout(() => {
          document.body.removeChild(confettiCanvas);
        }, 5000);
      }

      // Refresh lot data after webhook processes
      setTimeout(async () => {
        if (typeof loadBaseLots === 'function') {
          await loadBaseLots();
        }
      }, 3000);
    }
  } catch (error) {
    console.error('Payment error:', error);
    showPaymentError('Error al procesar el pago');
    submitBtn.disabled = false;
    submitBtn.textContent = `PAGAR $${RESERVATION_AMOUNT.toLocaleString('en-US')} MXN`;
  }
}

// Mark lot as sold in database
async function markLotAsSold(lot) {
  try {
    await window.supabaseReady;

    // Find the lot_name from lotData using lot.number
    const lotMapData = lotData.find(l => extractLotNumber(l.name) === lot.number);
    if (!lotMapData) {
      throw new Error(`Could not find lot_name for lot number ${lot.number}`);
    }

    const { error } = await window.supabaseClient
      .from('lots')
      .update({ availability: 'Sold' })
      .eq('lot_name', lotMapData.name)
      .eq('client_id', CURRENT_CLIENT);

    if (error) {
      console.error('Error updating lot availability:', error);
      throw error;
    }

    console.log(`Lot ${lot.number} (${lotMapData.name}) marked as sold`);
  } catch (error) {
    console.error('Error marking lot as sold:', error);
    throw error;
  }
}

// Export function to global scope
window.showPaymentViewInModal = showPaymentViewInModal;
</script>

<!-- ===== SEARCH BUTTON COMPONENT ===== -->
<div class="search-btn-stage" id="searchBtnStage">
  <div class="search-btn-rotator" id="searchBtnRotator">
    <!-- dots injected here -->
  </div>
  <button class="search-btn-center" id="searchBtnCenter">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor">
      <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke-width="2" stroke-linecap="round" fill="none"/>
    </svg>
  </button>
</div>

<script>
(function(){
  const stage = document.getElementById('searchBtnStage');
  const rotator = document.getElementById('searchBtnRotator');
  const centerBtn = document.getElementById('searchBtnCenter');

  let config = null;
  let dots = [];
  let menuActive = false;

  function setCSSVar(name, value) {
    stage.style.setProperty(name, value);
  }

  function textToHTML(text) {
    return text.split('\n').map(line => `<div>${line || '&nbsp;'}</div>`).join('');
  }

  function applyConfig() {
    setCSSVar('--orbit-radius', config.radius);
    setCSSVar('--dot', config.dotSize + 'px');
    setCSSVar('--dot-font-size', config.fontSize + 'px');
    setCSSVar('--dot-color', config.dotColor);
    setCSSVar('--btn', config.center + 'px');
    setCSSVar('--center-color', config.centerColor);
    setCSSVar('--mini-orbit-radius', config.miniRadius);
    setCSSVar('--mini-dot', config.miniSize + 'px');
    setCSSVar('--mini-dot-font-size', config.miniFontSize + 'px');
    setCSSVar('--mini-dot-color', config.miniDotColor);
    setCSSVar('--tiny-orbit-radius', config.tinyRadius || 24);
    setCSSVar('--tiny-dot', (config.tinySize || 16) + 'px');
    setCSSVar('--tiny-dot-font-size', (config.tinyFontSize || 8) + 'px');
    setCSSVar('--tiny-dot-color', config.tinyDotColor || '#34d399');
    setCSSVar('--rotate-deg', config.rotation + 'deg');

    // Initialize logo on page load
    updateLogo(config.defaultLogo || '');
  }

  function updateLogo(logoUrl) {
    const communityLogo = document.getElementById('communityLogo');
    const communityLogoImg = document.getElementById('communityLogoImg');

    if (!communityLogo || !communityLogoImg) return;

    if (logoUrl && logoUrl.trim() !== '') {
      communityLogo.style.display = 'block';
      communityLogoImg.src = logoUrl;
    } else {
      communityLogo.style.display = 'none';
      communityLogoImg.src = '';
    }
  }

  function buildDots() {
  rotator.innerHTML = '';
  dots = [];
  const count = config.count;
  const cx = stage.clientWidth / 2;
  const cy = stage.clientHeight / 2;
  for (let i = 0; i < count; i++) {
    if (config.dotVisibility[i] === false) continue;
    const container = document.createElement('div');
    container.className = 'search-btn-dot-container';
    const el = document.createElement('button');
    el.className = 'search-btn-dot';
    const dotText = document.createElement('div');
    dotText.className = 'search-btn-dot-text';
    const labelText = config.dotLabels[i] || (i + 1).toString();
    dotText.innerHTML = textToHTML(labelText);
    el.appendChild(dotText);
    
    // Position - Add Math.PI to start at 9 o'clock
    const angle = (2 * Math.PI * i) / count + Math.PI;
    const x = cx + config.radius * Math.cos(angle);
    const y = cy + config.radius * Math.sin(angle);
    container.style.left = x + 'px';
    container.style.top = y + 'px';
    
    // Keep text upright (cancel out parent rotation)
    dotText.style.transform = `rotate(${-config.rotation}deg)`;
    
    container.appendChild(el);
    rotator.appendChild(container);
    const dotObj = { el, container, i, miniDots: [], miniRing: null, miniDotsActive: false };
    
    // Build mini-dots if enabled
    if (config.miniDotsEnabled && config.miniDotsVisibility[i] !== false) {
      buildMiniDots(dotObj, container);
    }
    
    // Click handler - navigate, update logo, and show mini-dots OR close menu
    el.addEventListener('click', (e) => {
      e.stopPropagation();
      if (menuActive) {
        navigateTo(String(i)); // Navigate to main dot coords

        // Update logo from config
        if (config.dotLogos && config.dotLogos[i]) {
          updateLogo(config.dotLogos[i]);
        }
        if (config.miniDotsEnabled && config.miniDotsVisibility[i] !== false) {
          // If mini-dots are enabled, toggle them
          toggleMiniDotsForDot(dotObj);
        } else {
          // If mini-dots are disabled, close the menu (same as mini-dot behavior)
          toggleMenu();
        }
      }
    });
    dots.push(dotObj);
  }
  applyAnimationDelays();
}

  function buildMiniDots(dot, container) {
    const ring = document.createElement('div');
    ring.className = 'search-btn-mini-ring';
    ring.style.width = (config.miniRadius * 2) + 'px';
    ring.style.height = (config.miniRadius * 2) + 'px';

    const shouldMirror = config.miniDotsMirror && config.miniDotsMirror[dot.i];
    const effectiveRotation = shouldMirror ? -config.miniRotation : config.miniRotation;

    for (let j = 0; j < config.miniCount; j++) {
      if (config.individualMiniVisibility[dot.i] && config.individualMiniVisibility[dot.i][j] === false) continue;

      const miniContainer = document.createElement('div');
      miniContainer.className = 'search-btn-mini-container';

      const miniEl = document.createElement('button');
      miniEl.className = 'search-btn-mini-dot';

      const miniKey = `${dot.i}-${j}`;
      const miniText = document.createElement('div');
      miniText.className = 'search-btn-mini-text';
      const miniLabelText = config.miniDotLabels[miniKey] || (j + 1).toString();
      miniText.innerHTML = textToHTML(miniLabelText);
      miniEl.appendChild(miniText);

      // Position
      const baseAngle = (2 * Math.PI * j) / config.miniCount;
      const angle = baseAngle + (effectiveRotation * Math.PI / 180);
      const x = config.miniRadius + config.miniRadius * Math.cos(angle);
      const y = config.miniRadius + config.miniRadius * Math.sin(angle);
      miniContainer.style.left = x + 'px';
      miniContainer.style.top = y + 'px';

      miniContainer.appendChild(miniEl);
      ring.appendChild(miniContainer);

      const miniDotObj = { el: miniEl, container: miniContainer, index: j, key: miniKey, tinyDots: [], tinyRing: null, tinyDotsActive: false };

      miniEl.addEventListener('click', (e) => {
        e.stopPropagation();
        if (dot.miniDotsActive) {
          // Navigate to this mini-dot's location
          navigateTo(miniKey);

          // Update logo from config
          if (config.miniDotLogos && config.miniDotLogos[miniKey]) {
            updateLogo(config.miniDotLogos[miniKey]);
          }

          // Check if tiny-dots are enabled for this mini-dot
          if (config.tinyDotsEnabled && config.tinyDotsVisibility && config.tinyDotsVisibility[miniKey] !== false) {
            toggleTinyDotsForMiniDot(miniDotObj);
          } else {
            toggleMenu();
          }
        }
      });

      // Build tiny-dots for this mini-dot if enabled
      if (config.tinyDotsEnabled && config.tinyDotsVisibility && config.tinyDotsVisibility[miniKey] !== false) {
        buildTinyDots(miniDotObj, miniContainer, dot.i, j);
      }

      dot.miniDots.push(miniDotObj);
    }

    container.appendChild(ring);
    dot.miniRing = ring;
  }

  function buildTinyDots(miniDot, miniContainer, dotIndex, miniIndex) {
    const ring = document.createElement('div');
    ring.className = 'search-btn-tiny-ring';
    ring.style.width = ((config.tinyRadius || 24) * 2) + 'px';
    ring.style.height = ((config.tinyRadius || 24) * 2) + 'px';

    const miniKey = `${dotIndex}-${miniIndex}`;
    const shouldMirror = config.tinyDotsMirror && config.tinyDotsMirror[miniKey];
    const effectiveRotation = shouldMirror ? -(config.tinyRotation || 0) : (config.tinyRotation || 0);

    for (let k = 0; k < (config.tinyCount || 4); k++) {
      if (config.individualTinyVisibility && config.individualTinyVisibility[miniKey] && config.individualTinyVisibility[miniKey][k] === false) continue;

      const tinyContainer = document.createElement('div');
      tinyContainer.className = 'search-btn-tiny-container';

      const tinyEl = document.createElement('button');
      tinyEl.className = 'search-btn-tiny-dot';

      const tinyKey = `${dotIndex}-${miniIndex}-${k}`;
      const tinyText = document.createElement('div');
      tinyText.className = 'search-btn-tiny-text';
      const tinyLabelText = (config.tinyDotLabels && config.tinyDotLabels[tinyKey]) || (k + 1).toString();
      tinyText.innerHTML = textToHTML(tinyLabelText);
      tinyEl.appendChild(tinyText);

      // Position
      const tinyRadius = config.tinyRadius || 24;
      const baseAngle = (2 * Math.PI * k) / (config.tinyCount || 4);
      const angle = baseAngle + (effectiveRotation * Math.PI / 180);
      const x = tinyRadius + tinyRadius * Math.cos(angle);
      const y = tinyRadius + tinyRadius * Math.sin(angle);
      tinyContainer.style.left = x + 'px';
      tinyContainer.style.top = y + 'px';

      tinyContainer.appendChild(tinyEl);
      ring.appendChild(tinyContainer);

      tinyEl.addEventListener('click', (e) => {
        e.stopPropagation();
        if (miniDot.tinyDotsActive) {
          // Navigate to this tiny-dot's location
          navigateTo(tinyKey);

          // Update logo from config
          if (config.tinyDotLogos && config.tinyDotLogos[tinyKey]) {
            updateLogo(config.tinyDotLogos[tinyKey]);
          }

          toggleMenu();
        }
      });

      miniDot.tinyDots.push({ el: tinyEl, container: tinyContainer, index: k, key: tinyKey });
    }

    miniContainer.appendChild(ring);
    miniDot.tinyRing = ring;
  }

  function toggleTinyDotsForMiniDot(miniDot) {
    miniDot.tinyDotsActive = !miniDot.tinyDotsActive;

    if (miniDot.tinyDotsActive) {
      miniDot.el.classList.add('hidden');
      miniDot.tinyDots.forEach(({ el }) => {
        el.classList.add('visible');
      });
    } else {
      miniDot.el.classList.remove('hidden');
      miniDot.tinyDots.forEach(({ el }) => {
        el.classList.remove('visible');
      });
    }
  }

  function applyAnimationDelays() {
    let visibleIndex = 0;
    dots.forEach((dot) => {
      dot.el.style.animationDelay = (visibleIndex * config.animDelay) + 'ms';
      visibleIndex++;
    });
  }

  function toggleMiniDotsForDot(dot) {
    dot.miniDotsActive = !dot.miniDotsActive;

    if (dot.miniDotsActive) {
      dot.el.classList.add('hidden');
      dot.miniDots.forEach(({ el }) => {
        el.classList.add('visible');
      });
    } else {
      dot.el.classList.remove('hidden');
      dot.miniDots.forEach((miniDot) => {
        miniDot.el.classList.remove('visible');
        // Also hide any active tiny-dots
        if (miniDot.tinyDotsActive) {
          miniDot.tinyDots.forEach(({ el }) => {
            el.classList.remove('visible');
          });
          miniDot.tinyDotsActive = false;
        }
      });
    }
  }

  function navigateTo(key) {
    // Get coords from config.navigation (loaded from saved.json)
    const nav = config.navigation && config.navigation[key];

    if (!nav || !nav.center) {
      console.log('No navigation data for:', key);
      return;
    }

    // Update current fraccionamiento if specified in nav config
    // Add "fracc": "fraccionamiento_name" to saved.json navigation entries
    if (nav.fracc) {
      currentFraccionamiento = nav.fracc;
      console.log('Updated currentFraccionamiento to:', nav.fracc);
    }

    if (typeof map !== 'undefined' && map.flyTo) {
      map.flyTo({
        center: nav.center,
        zoom: nav.zoom,
        speed: 1.2,
        curve: 1.5
      });
      console.log('Navigating to:', key, nav);
    } else {
      console.log('Map not available, would navigate to:', key, nav);
    }
  }


  function toggleMenu() {
    menuActive = !menuActive;
    if (menuActive) {
      rotator.classList.add('search-btn-menu-active');
      dots.forEach((dot) => {
        dot.el.classList.add('visible');
        dot.el.classList.remove('hidden');
      });
    } else {
      rotator.classList.remove('search-btn-menu-active');
      dots.forEach((dot) => {
        dot.el.classList.remove('visible');
        dot.el.classList.remove('hidden');
        if (dot.miniDotsActive) {
          dot.miniDots.forEach((miniDot) => {
            miniDot.el.classList.remove('visible');
            // Also hide any active tiny-dots
            if (miniDot.tinyDotsActive) {
              miniDot.tinyDots.forEach(({ el }) => {
                el.classList.remove('visible');
              });
              miniDot.tinyDotsActive = false;
            }
          });
          dot.miniDotsActive = false;
        }
      });
    }
  }

  centerBtn.addEventListener('click', toggleMenu);

  // Load config and initialize
  fetch('saved.json')
    .then(res => res.json())
    .then(data => {
      config = data;
      applyConfig();
      buildDots();
      console.log('‚úÖ Search button loaded from saved.json');
    })
    .catch(err => {
      console.error('‚ùå Failed to load saved.json:', err);
    });
})();
</script>

<script>
(function() {
  // PDF Generation for Agora - Multi-template support based on community group

  async function generateMultiPagePDF(lot, dynamicText, financingOptions = {}) {
    if (!lot) {
      console.error('No lot data provided');
      window.showToaster?.('Error: No se pudo obtener datos del lote');
      return;
    }

    // Default financing options (matches modal defaults)
    const financing = {
      downpaymentPercent: financingOptions.downpaymentPercent || 30,
      installmentMonths: financingOptions.installmentMonths || 48
    };

    // Determine community group from fraccionamiento
    const fraccionamiento = lot.fraccionamiento || lot.community || '';
    const communityGroup = getCommunityGroup('agora', fraccionamiento);

    if (!communityGroup) {
      console.error('Could not determine community group for:', fraccionamiento);
      window.showToaster?.('Error: Plantilla no disponible para esta comunidad');
      return;
    }

    // Create progress overlay
    const progressOverlay = document.createElement('div');
    progressOverlay.id = 'pdf-progress-overlay';
    progressOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 99999;
    `;
    progressOverlay.innerHTML = `
      <div style="background: white; padding: 32px 48px; border-radius: 12px; text-align: center; font-family: Arial, sans-serif;">
        <div style="font-size: 18px; font-weight: 600; margin-bottom: 16px;">Generando PDF...</div>
        <div id="pdf-progress-text" style="font-size: 14px; color: #666; margin-bottom: 12px;">Cargando plantilla...</div>
        <div style="width: 200px; height: 8px; background: #eee; border-radius: 4px; overflow: hidden;">
          <div id="pdf-progress-bar" style="width: 0%; height: 100%; background: ${CONFIG?.colors?.primary || '#007bff'}; transition: width 0.3s;"></div>
        </div>
      </div>
    `;
    document.body.appendChild(progressOverlay);

    const progressText = document.getElementById('pdf-progress-text');
    const progressBar = document.getElementById('pdf-progress-bar');

    // Create hidden container for rendering pages
    const pdfContainer = document.createElement('div');
    pdfContainer.id = 'pdf-generation-container';
    pdfContainer.style.cssText = 'position: fixed; left: -9999px; top: 0; z-index: -1;';
    document.body.appendChild(pdfContainer);

    // Calculate lot values for placeholders
    function getLotValues(lot, dynamicText, financingOpts = {}) {
      const size = parseFloat(String(lot.size || '0').replace(/[^0-9.]/g, '')) || 0;
      const priceM2 = parseFloat(String(lot.priceM2 || lot.price_m2 || '0').replace(/[^0-9.]/g, '')) || 0;
      const totalPrice = size * priceM2;

      // Calculate category based on priceM2 tier
      const allLotsData = lotData || window.baseLotsAll || baseLots || [];
      const uniquePrices = [...new Set(allLotsData.map(l =>
        parseFloat(String(l.priceM2 || l.price_m2 || '0').replace(/[^0-9.]/g, '')) || 0
      ))].filter(p => p > 0).sort((a, b) => b - a);

      const categories = ['AAA+', 'AAA', 'AA', 'A'];
      const priceIndex = uniquePrices.findIndex(p => Math.abs(p - priceM2) < 0.01);
      const category = priceIndex >= 0 && priceIndex < categories.length ? categories[priceIndex] : 'A';

      // Format helpers
      const formatCurrency = (num) => '$' + num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      const formatNumber = (num) => num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

      // Discount calculations
      const discount5 = totalPrice * 0.05;
      const discount12 = totalPrice * 0.12;
      const priceWith5Discount = totalPrice * 0.95;
      const priceWith12Discount = totalPrice * 0.88;

      // 25% plan: no discount, 25% down, 45% in 24 months, 30% contra escritura
      const downpayment25 = totalPrice * 0.25;
      const monthly25 = (totalPrice * 0.45) / 24;
      const contraEscritura30 = totalPrice * 0.30;

      // 50% plan: 5% discount, 50% down, 50% contra escritura
      const downpayment50 = priceWith5Discount * 0.50;
      const contraEscritura50 = priceWith5Discount * 0.50;

      // 85% plan: 12% discount, 85% down, 15% contra escritura
      const downpayment85 = priceWith12Discount * 0.85;
      const contraEscritura15 = priceWith12Discount * 0.15;

      // Dynamic financing calculations based on selected options
      const selectedDownpaymentPercent = financingOpts.downpaymentPercent || 30;
      const selectedInstallmentMonths = financingOpts.installmentMonths || 48;

      // Interest rates by month term
      const INTEREST_RATES = { 24: 0.13, 36: 0.14, 48: 0.15, 60: 0.16, 72: 0.17 };
      const selectedInterestRate = INTEREST_RATES[selectedInstallmentMonths] || 0.15;

      // Calculate dynamic financing values
      const selectedDownpaymentAmount = totalPrice * (selectedDownpaymentPercent / 100);
      const amountToFinance = totalPrice - selectedDownpaymentAmount;

      // Monthly payment calculation helper
      function calcMonthlyPayment(principal, annualRate, months) {
        const monthlyRate = annualRate / 12;
        if (monthlyRate === 0) return principal / months;
        const numerator = principal * monthlyRate * Math.pow(1 + monthlyRate, months);
        const denominator = Math.pow(1 + monthlyRate, months) - 1;
        return numerator / denominator;
      }

      // Selected term calculation
      const selectedMonthlyPayment = calcMonthlyPayment(amountToFinance, selectedInterestRate, selectedInstallmentMonths);
      const selectedTotalFinancedPrice = selectedDownpaymentAmount + (selectedMonthlyPayment * selectedInstallmentMonths);

      // Calculate all term options (using selected downpayment)
      const terms = [24, 36, 48, 60, 72];
      const termCalcs = {};
      terms.forEach(months => {
        const rate = INTEREST_RATES[months];
        const monthly = calcMonthlyPayment(amountToFinance, rate, months);
        const total = selectedDownpaymentAmount + (monthly * months);
        termCalcs[months] = { rate, monthly, total };
      });

      // Parse lot number (e.g., "10-11" ‚Üí "MZ10L11")
      const lotNumberParts = (lot.number || '').split('-');
      const lotFormatted = lotNumberParts.length === 2
        ? `MZ${lotNumberParts[0]}L${lotNumberParts[1]}`
        : lot.number || '';

      // Current date in Spanish format (e.g., "28 ENE 2026")
      const spanishMonths = ['ENE', 'FEB', 'MAR', 'ABR', 'MAY', 'JUN', 'JUL', 'AGO', 'SEP', 'OCT', 'NOV', 'DIC'];
      const today = new Date();
      const dateFormatted = `${today.getDate()} ${spanishMonths[today.getMonth()]} ${today.getFullYear()}`;

      return {
        'dynamicText': dynamicText,
        'lot.number': lot.number || '',
        'lot.nameA': lotNumberParts[0] || '',
        'lot.nameB': lotNumberParts[1] || '',
        'lot.numberFormatted': lotFormatted,
        'lot.date': dateFormatted,
        'lot.category': category || 'A',
        'lot.size': formatNumber(size) + ' m¬≤',
        'lot.pricePerM2': formatCurrency(priceM2),
        'lot.totalPrice': formatCurrency(totalPrice),
        'lot.downpayment25': formatCurrency(downpayment25),
        'lot.downpayment50': formatCurrency(downpayment50),
        'lot.downpayment85': formatCurrency(downpayment85),
        'lot.monthly25': formatCurrency(monthly25),
        'lot.discount0': formatCurrency(0),
        'lot.discount5': formatCurrency(discount5),
        'lot.discount12': formatCurrency(discount12),
        'lot.priceWith5Discount': formatCurrency(priceWith5Discount),
        'lot.priceWith12Discount': formatCurrency(priceWith12Discount),
        'lot.contraEscritura30': formatCurrency(contraEscritura30),
        'lot.contraEscritura50': formatCurrency(contraEscritura50),
        'lot.contraEscritura15': formatCurrency(contraEscritura15),
        // New dynamic financing placeholders (selected)
        'lot.selectedDownpaymentPercent': selectedDownpaymentPercent + '%',
        'lot.selectedDownpaymentAmount': formatCurrency(selectedDownpaymentAmount),
        'lot.selectedInstallmentMonths': String(selectedInstallmentMonths),
        'lot.selectedMonthlyPayment': formatCurrency(selectedMonthlyPayment),
        'lot.selectedInterestRate': (selectedInterestRate * 100).toFixed(0) + '%',
        'lot.selectedTotalFinancedPrice': formatCurrency(selectedTotalFinancedPrice),
        // All term options (using selected downpayment)
        'lot.monthly24': formatCurrency(termCalcs[24].monthly),
        'lot.rate24': (termCalcs[24].rate * 100).toFixed(0) + '%',
        'lot.totalFinanced24': formatCurrency(termCalcs[24].total),
        'lot.monthly36': formatCurrency(termCalcs[36].monthly),
        'lot.rate36': (termCalcs[36].rate * 100).toFixed(0) + '%',
        'lot.totalFinanced36': formatCurrency(termCalcs[36].total),
        'lot.monthly48': formatCurrency(termCalcs[48].monthly),
        'lot.rate48': (termCalcs[48].rate * 100).toFixed(0) + '%',
        'lot.totalFinanced48': formatCurrency(termCalcs[48].total),
        'lot.monthly60': formatCurrency(termCalcs[60].monthly),
        'lot.rate60': (termCalcs[60].rate * 100).toFixed(0) + '%',
        'lot.totalFinanced60': formatCurrency(termCalcs[60].total),
        'lot.monthly72': formatCurrency(termCalcs[72].monthly),
        'lot.rate72': (termCalcs[72].rate * 100).toFixed(0) + '%',
        'lot.totalFinanced72': formatCurrency(termCalcs[72].total)
      };
    }

    // Replace placeholders in text
    function replacePlaceholders(text, values) {
      if (!text) return '';
      return text.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
        return values[key.trim()] !== undefined ? values[key.trim()] : match;
      });
    }

    // Function to create a page with template elements
    function createPage(pageNum, template, lotValues, settings) {
      const pageBackgroundBaseUrl = settings.pageBackgroundBaseUrl || `/agora/pdf/${communityGroup}/`;
      const lotImageBaseUrl = settings.lotImageBaseUrl || `/agora/pdf/${communityGroup}/`;
      const lotImagePrefix = settings.lotImagePrefix || '';
      const pageWidth = settings.pageWidth || 1224;
      const pageHeight = settings.pageHeight || 1584;

      const pdfPage = document.createElement('div');
      pdfPage.style.cssText = `
        width: ${pageWidth}px;
        height: ${pageHeight}px;
        position: relative;
        overflow: visible;
        background-image: url("${pageBackgroundBaseUrl}page.${pageNum}.png");
        background-size: cover;
        background-repeat: no-repeat;
        background-position: top left;
      `;

      // Get page data from template
      const pageIndex = parseInt(pageNum, 10);
      const pageData = template?.pages?.[pageIndex];

      if (pageData) {
        // Render text boxes
        if (pageData.textBoxes) {
          pageData.textBoxes.forEach(tb => {
            const textEl = document.createElement('div');
            textEl.textContent = replacePlaceholders(tb.content, lotValues);
            textEl.style.cssText = `
              position: absolute;
              left: ${tb.x}px;
              top: ${tb.y}px;
              ${tb.width ? `width: ${tb.width}px;` : ''}
              ${tb.height ? `height: ${tb.height}px;` : ''}
              font-size: ${tb.fontSize || 24}px;
              font-family: "${tb.fontFamily || 'Arial'}", sans-serif;
              color: ${tb.color || '#000000'};
              font-weight: ${tb.bold ? '700' : '400'};
              font-style: ${tb.italic ? 'italic' : 'normal'};
              text-decoration: ${tb.underline ? 'underline' : 'none'};
              text-align: ${tb.textAlign || 'left'};
              white-space: pre-wrap;
              ${tb.zIndex !== undefined ? `z-index: ${tb.zIndex};` : ''}
            `;
            pdfPage.appendChild(textEl);
          });
        }

        // Render tables
        if (pageData.tables) {
          pageData.tables.forEach(tableData => {
            const colWidths = tableData.colWidths || Array(tableData.cols).fill(100);
            const rowHeights = tableData.rowHeights || Array(tableData.rows).fill(30);
            const totalWidth = colWidths.reduce((sum, w) => sum + w, 0);

            const tableContainer = document.createElement('div');
            tableContainer.style.cssText = `
              position: absolute;
              left: ${tableData.x}px;
              top: ${tableData.y}px;
              ${tableData.zIndex !== undefined ? `z-index: ${tableData.zIndex};` : ''}
            `;

            const table = document.createElement('table');
            table.style.cssText = `
              border-collapse: collapse;
              table-layout: fixed;
              width: ${totalWidth}px;
            `;

            for (let r = 0; r < tableData.rows; r++) {
              const tr = document.createElement('tr');
              tr.style.height = rowHeights[r] + 'px';

              for (let c = 0; c < tableData.cols; c++) {
                const cellData = tableData.cells?.[r]?.[c];
                if (!cellData || cellData.hidden) continue;

                const td = document.createElement('td');
                td.textContent = replacePlaceholders(cellData.content || '', lotValues);

                const borderWidth = cellData.borderWidth || 1;
                const borderStyle = cellData.borderStyle || 'solid';
                const borderColor = cellData.borderColor || '#000000';
                const borderPosition = cellData.borderPosition || 'all';

                let borderCss = '';
                if (borderPosition === 'bottom') {
                  borderCss = `border: none; border-bottom: ${borderWidth}px ${borderStyle} ${borderColor};`;
                } else if (borderPosition === 'top') {
                  borderCss = `border: none; border-top: ${borderWidth}px ${borderStyle} ${borderColor};`;
                } else {
                  borderCss = `border: ${borderWidth}px ${borderStyle} ${borderColor};`;
                }

                td.style.cssText = `
                  width: ${colWidths[c]}px;
                  height: ${rowHeights[r]}px;
                  box-sizing: border-box;
                  overflow: hidden;
                  background-color: ${cellData.bgColor || '#ffffff'};
                  color: ${cellData.textColor || '#000000'};
                  font-family: "${cellData.fontFamily || 'Arial'}", sans-serif;
                  font-size: ${cellData.fontSize || 14}px;
                  font-weight: ${cellData.bold ? '700' : '400'};
                  font-style: ${cellData.italic ? 'italic' : 'normal'};
                  text-decoration: ${cellData.underline ? 'underline' : 'none'};
                  ${borderCss}
                  padding: 0;
                  text-align: ${cellData.textAlign || 'left'};
                  vertical-align: middle;
                `;

                if (cellData.colSpan > 1) td.colSpan = cellData.colSpan;
                if (cellData.rowSpan > 1) td.rowSpan = cellData.rowSpan;

                tr.appendChild(td);
              }
              table.appendChild(tr);
            }

            tableContainer.appendChild(table);
            pdfPage.appendChild(tableContainer);
          });
        }

        // Render images
        if (pageData.images) {
          pageData.images.forEach(imgData => {
            const imgEl = document.createElement('div');

            // Determine image URL based on type
            let imageUrl = '';
            if (imgData.type === '{{lot.landscape}}') {
              imageUrl = `${lotImageBaseUrl}${lotImagePrefix}${lotValues['lot.number']}_landscape.jpg`;
            } else if (imgData.type === '{{lot.map}}') {
              imageUrl = `${lotImageBaseUrl}${lotImagePrefix}${lotValues['lot.number']}_map.jpg`;
            } else if (imgData.type === 'static' && imgData.url) {
              imageUrl = imgData.url;
            }

            imgEl.style.cssText = `
              position: absolute;
              left: ${imgData.x}px;
              top: ${imgData.y}px;
              width: ${imgData.width}px;
              height: ${imgData.height}px;
              background-image: url("${imageUrl}");
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              ${imgData.borderWidth > 0 ? `border: ${imgData.borderWidth}px solid ${imgData.borderColor || '#000000'}; box-sizing: border-box;` : ''}
              ${imgData.zIndex !== undefined ? `z-index: ${imgData.zIndex};` : ''}
            `;
            pdfPage.appendChild(imgEl);
          });
        }
      }

      return pdfPage;
    }

    try {
      // Step 1: Fetch template for this community group
      progressText.textContent = 'Cargando plantilla...';
      const templatePath = `/agora/pdf/${communityGroup}/pdf-template.json`;

      let template = { pages: {}, settings: {} };
      try {
        const response = await fetch(templatePath);
        if (response.ok) {
          template = await response.json();
        } else {
          throw new Error(`Template not found: ${templatePath}`);
        }
      } catch (err) {
        console.error('Could not load PDF template:', err);
        window.showToaster?.('Error: No se pudo cargar la plantilla PDF');
        document.body.removeChild(progressOverlay);
        document.body.removeChild(pdfContainer);
        return;
      }

      // Get settings from template or use defaults
      const settings = template.settings || {};
      const totalPages = settings.totalPages || Object.keys(template.pages || {}).length || 8;

      // Calculate lot values with financing options
      const lotValues = getLotValues(lot, dynamicText, financing);

      // Step 2: Preload ALL images in parallel
      progressText.textContent = 'Cargando im√°genes...';
      progressBar.style.width = '10%';

      const pageBackgroundBaseUrl = settings.pageBackgroundBaseUrl || `/agora/pdf/${communityGroup}/`;
      const lotImageBaseUrl = settings.lotImageBaseUrl || `/agora/pdf/${communityGroup}/`;
      const lotImagePrefix = settings.lotImagePrefix || '';

      const imagePromises = [];

      // Preload page backgrounds
      for (let i = 1; i <= totalPages; i++) {
        const pageNum = String(i).padStart(3, '0');
        imagePromises.push(new Promise(resolve => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = resolve;
          img.onerror = resolve;
          img.src = `${pageBackgroundBaseUrl}page.${pageNum}.png`;
        }));
      }

      // Preload lot-specific images (landscape and map)
      const lotNum = lotValues['lot.number'];
      if (lotNum) {
        ['landscape', 'map'].forEach(type => {
          imagePromises.push(new Promise(resolve => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = resolve;
            img.onerror = resolve;
            img.src = `${lotImageBaseUrl}${lotImagePrefix}${lotNum}_${type}.jpg`;
          }));
        });

        // Preload any static images from the template
        Object.values(template.pages || {}).forEach(pageData => {
          (pageData.images || []).forEach(imgData => {
            if (imgData.type === 'static' && imgData.url) {
              imagePromises.push(new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = resolve;
                img.onerror = resolve;
                img.src = imgData.url;
              }));
            }
          });
        });
      }

      await Promise.all(imagePromises);
      progressBar.style.width = '40%';

      // Step 3: Generate PDF pages sequentially (required by jsPDF)
      progressText.textContent = 'Generando PDF...';

      // Use page dimensions from template or defaults
      const pageWidth = settings.pageWidth || 1224;
      const pageHeight = settings.pageHeight || 1584;
      const orientation = pageWidth > pageHeight ? 'landscape' : 'portrait';

      const worker = html2pdf().set({
        margin: 0,
        filename: `Agora-${communityGroup}-lote-${lotValues['lot.number']}.pdf`,
        image: { type: 'jpeg', quality: 1 },
        html2canvas: { scale: 1, useCORS: true },
        jsPDF: { unit: 'px', format: [pageWidth, pageHeight], orientation: orientation }
      });

      for (let i = 1; i <= totalPages; i++) {
        progressText.textContent = `Renderizando p√°gina ${i} de ${totalPages}`;
        progressBar.style.width = `${40 + (i / totalPages) * 55}%`;

        const pageNum = String(i).padStart(3, '0');

        // Create page with template elements
        const page = createPage(pageNum, template, lotValues, settings);
        pdfContainer.innerHTML = '';
        pdfContainer.appendChild(page);

        if (i === 1) {
          await worker.from(page).toContainer().toCanvas().toPdf();
        } else {
          await worker.get('pdf').then(pdf => {
            pdf.addPage([pageWidth, pageHeight], orientation);
          });
          await worker.from(page).toContainer().toCanvas().toPdf();
        }
      }

      // Save the final PDF
      progressText.textContent = 'Descargando...';
      progressBar.style.width = '100%';
      await worker.save();

      // Clean up
      document.body.removeChild(pdfContainer);
      document.body.removeChild(progressOverlay);

    } catch (err) {
      console.error('PDF generation error:', err);
      window.showToaster?.('Error al generar el PDF');
      if (document.getElementById('pdf-progress-overlay')) {
        document.body.removeChild(progressOverlay);
      }
      if (document.getElementById('pdf-generation-container')) {
        document.body.removeChild(pdfContainer);
      }
    }
  }

  // Expose to global scope
  window.generateMultiPagePDF = generateMultiPagePDF;
})();
</script>

</body>
</html>