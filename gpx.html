
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-GPX Editor with Mapbox</title>
    
    <!-- Mapbox CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background: #f5f5f5;
        }
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
        } 
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1;
            width: 320px;
            overflow-y: auto;
            display:none;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .control-group:last-child {
            border-bottom: none;
        }
        button {
            padding: 8px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        button:hover {
            background: #e9ecef;
        }
        button.active {
            background: #4285F4;
            color: white;
            border-color: #4285F4;
        }
        .track-active {
            background: #e6f3ff !important;
            border-color: #4285F4 !important;
        }
        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285F4;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285F4;
            cursor: pointer;
            border: none;
        }
        .tracks-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            margin-top: 5px;
        }
        .track-item {
            padding: 5px 8px;
            margin: 2px 0;
            border: 1px solid #eee;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        .track-item:hover {
            background: #f8f9fa;
        }
        .track-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .track-info {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .track-actions {
            display: flex;
            gap: 4px;
        }
        .small-btn {
            padding: 2px 6px;
            font-size: 10px;
        }
        .stats-container {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-container input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .file-input-button {
            display: block;
            padding: 10px;
            background: #4285F4;
            color: white;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
        }
        .export-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .export-buttons button {
            flex: 1;
        }
        .mode-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .mode-buttons button {
            flex: 1;
            min-width: 80px;
        }
        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }

        /* 360 Viewer Styles */
#viewer-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: #000;
    z-index: 0;
}

#panorama-viewer {
    width: 100%;
    height: 100%;
    background: #1a1a1a;
}

/* Adjust map position for split screen */
#map {
    position: absolute;
    top: 50%; /* Start at 50% for bottom half */
    bottom: 0;
    width: 100%;
}




/* === NEW 360 VIEWER STYLES === */
#viewer-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: #0b1020;
    z-index: 0;
}

#canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    touch-action: none; /* Important: prevents browser from handling touch gestures */
    pointer-events: auto;
    -webkit-user-select: none; /* Prevent text selection on iOS */
    user-select: none;
}

.viewer-controls {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 1000;
    display: flex;
    gap: 20px;
    align-items: center;
    color: white;
    font-size: 14px;
    display:none;
}

.viewer-controls button {
    background: #4285F4;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
}

.viewer-controls button:hover {
    background: #3367d6;
}

.image-controls {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 20;
    pointer-events:none;

}

.navigation-ring {
    position: relative;
    width: 160px;
    height: 160px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: transform 0.3s ease;
    pointer-events: none; 
}

.nav-button.ring-button {
    position: absolute;
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 50%;
    background: rgba(0,0,0,0);
    color: #fcfaf3;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transform: translateX(-50%);
    pointer-events: auto; 
    z-index:21;
    
    
}

#nextImageBtn.ring-button {
    top: 15px;
    left: 50%;
}

#prevImageBtn.ring-button {
    bottom: 15px;
    left: 50%;
}

/* Branch button positions based on position class */
/* 3 o'clock - right side (default) */
#branchImageBtn.ring-button,
.navigation-ring.branch-right #branchImageBtn.ring-button {
    right: 15px;
    top: 50%;
    left: auto;
    bottom: auto;
    transform: translateY(-50%);
}

/* 9 o'clock - left side */
.navigation-ring.branch-left #branchImageBtn.ring-button {
    left: 15px;
    top: 50%;
    right: auto;
    bottom: auto;
    transform: translateY(-50%) rotate(180deg);
}

/* 12 o'clock - top (when at last marble, no next button) */
.navigation-ring.branch-top #branchImageBtn.ring-button {
    top: 15px;
    left: 50%;
    right: auto;
    bottom: auto;
    transform: translateX(-50%) rotate(-90deg);
}

/* 6 o'clock - bottom (when at first marble, no prev button) */
.navigation-ring.branch-bottom #branchImageBtn.ring-button {
    bottom: 15px;
    left: 50%;
    right: auto;
    top: auto;
    transform: translateX(-50%) rotate(90deg);
}

.nav-button.ring-button:hover {
    transform: translateX(-50%) scale(1.2);
}

#branchImageBtn.ring-button:hover {
    transform: translateY(-50%) scale(1.2);
}

.time {
    position: absolute;
    right: 20px;
    bottom: 20px;
    color: #22d3ee;
    font-weight: 600;
    font-size: 14px;
    z-index: 25;
    display:none;
}

.zoom-controls {
    position: absolute;
    right: 10px;
    top: 60px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 5;
    display:none;
}

.zoom-btn {
    width: 40px;
    height: 40px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #ccc;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
}

.zoom-btn:hover {
    background: rgba(0,0,0,0.9);
}

#viewer-loading {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    background: rgba(0,0,0,0.7);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    color: white;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255,255,255,0.1);
    border-radius: 50%;
    border-top: 4px solid #22d3ee;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* View cone on map */
.mapboxgl-marker.view-cone {
    z-index: 10;
}
    </style>
</head>
<body>
    <div id="map"></div>


    <div id="controls">
    <h3>GPX Track Editor</h3>
    
    <div class="control-group">
        <div class="file-input-container">
            <div class="file-input-button">Load GPX Files</div>
            <input type="file" id="gpx-file" accept=".gpx" multiple>
        </div>
        <div class="tracks-list" id="tracks-list">
            <div style="text-align: center; padding: 10px; color: #666; font-size: 12px;">
                No tracks loaded
            </div>
        </div>
    </div>
    
    <div class="control-group">
        <button onclick="toggleEditMode()" id="edit-btn">Edit Mode: OFF</button>
        <button onclick="clearAllRoutes()">Clear All</button>
    </div>
    
    <div class="control-group">
        <div class="slider-container">
            <div class="slider-label">
                <span>Point Density:</span>
                <span id="density-value">100%</span>
            </div>
            <input type="range" min="1" max="100" value="100" class="slider" id="density-slider">
            <div class="slider-label">
                <small id="points-count">0 points</small>
                <small id="original-count"></small>
            </div>
        </div>
    </div>
    
    <div class="control-group">
        <button onclick="toggleCatmullRom()" id="catmull-btn">Catmull-Rom: OFF</button>
        <button onclick="resetCurrentTrack()">Reset Current</button>
    </div>
    
    <div class="control-group">
        <div class="mode-buttons">
            <button onclick="addPointMode()">Add Points</button>
            <button onclick="removePointMode()">Remove Points</button>
            <button onclick="movePointMode()">Move Points</button>
        </div>
    </div>
    
    <div class="control-group">
        <div class="stats-container">
            <div class="slider-label">
                <small>Distance: <span id="total-distance">0 km</span></small>
                <small>Avg Speed: <span id="avg-speed">0 km/h</span></small>
            </div>
            <div class="slider-label">
                <small>Points: <span id="stats-points">0</span></small>
                <small>Duration: <span id="total-duration">0s</span></small>
            </div>
        </div>
    </div>

<div class="control-group">
    <div class="slider-label">
        <span>Marble Controls:</span>
        <div>
            <button class="small-btn" onclick="addMarble()" title="Add marble at end">+</button>
            <button class="small-btn" onclick="removeMarble()" title="Remove last marble">-</button>
            <button class="small-btn" onclick="initializeMarbles()" title="Rebuild all marbles">Rebuild</button>
            <button class="small-btn" onclick="lockSelectedMarble()" title="Lock selected marble">üîí Lock</button>

<button onclick="repairImageAssignment()" class="small-btn">1:1</button>
        </div>
    </div>
    <div class="slider-label">
        <small id="marble-count">0 marbles</small>
        <small>Spacing: <span id="marble-spacing">10</span>m</small>
    </div>
    <div class="slider-label">
        <input type="range" min="1" max="50" value="10" class="slider" id="marble-spacing-slider">
    </div>
    <div style="margin-top:10px;">
        <div class="slider-label"><span>Local Frames:</span> <small id="local-frames-count">0 loaded</small></div>
        <div class="file-input-container" style="margin-top:5px;">
            <div class="file-input-button" style="font-size:12px;padding:8px;">Select Folder</div>
            <input type="file" id="local-frames-input" webkitdirectory multiple accept="image/*">
        </div>
    </div>
</div>
    
    
    <div class="control-group">
        <div class="slider-label"><span>Image Overlay:</span></div>
        <input type="text" id="overlay-url" placeholder="Image URL" style="width:100%;box-sizing:border-box;padding:6px;margin:4px 0;border:1px solid #ddd;border-radius:4px;font-size:12px;">
        <textarea id="overlay-bounds" placeholder="Bounds: [[lng,lat],[lng,lat],[lng,lat],[lng,lat]]" style="width:100%;box-sizing:border-box;padding:6px;margin:4px 0;border:1px solid #ddd;border-radius:4px;font-size:11px;height:50px;resize:none;">[[-99.957219,25.155959],[-99.939253,25.155959],[-99.939253,25.139696],[-99.957219,25.139696]]</textarea>
        <div style="display:flex;gap:5px;margin:4px 0;">
            <button onclick="addImageOverlay()" style="flex:1;">Add Overlay</button>
            <button onclick="removeImageOverlay()" style="flex:1;">Remove</button>
        </div>
        <div class="slider-container" id="overlay-opacity-container" style="display:none;">
            <div class="slider-label">
                <span>Overlay Opacity:</span>
                <span id="overlay-opacity-value">80%</span>
            </div>
            <input type="range" min="0" max="100" value="80" class="slider" id="overlay-opacity-slider" oninput="updateOverlayOpacity(this.value)">
        </div>
    </div>

    <div class="control-group">
        <div class="export-buttons">
            <button onclick="exportCurrentTrack()">Export Current</button>
            <button onclick="exportAllTracksAsZip()">Export All (ZIP)</button>
        </div>
    </div>

    <!-- Marriage Controls -->
    <div class="control-group">
        <div class="slider-label">
            <span>Marble Marriages:</span>
            <small id="marriage-count">0 groups</small>
        </div>
        <div style="display:flex;gap:5px;margin:4px 0;flex-wrap:wrap;">
            <button onclick="toggleMarryMode()" id="marry-mode-btn" style="flex:1;">Marry Mode: OFF</button>
            <button onclick="marrySelected()" id="marry-btn" style="flex:1;" disabled>Marry Selected</button>
        </div>
        <div style="display:flex;gap:5px;margin:4px 0;">
            <button onclick="divorceSelectedMarble()" id="divorce-btn" style="flex:1;" disabled>Divorce Selected</button>
            <button onclick="clearAllMarriages()" style="flex:1;">Clear All</button>
        </div>
        <div id="marry-selection-info" style="font-size:11px;color:#666;margin-top:4px;display:none;">
            Selected for marriage: <span id="marry-selection-count">0</span> marbles
        </div>
    </div>

    <!-- Index JSON Controls -->
    <div class="control-group">
        <div class="slider-label"><span>Index JSON:</span></div>
        <div style="display:flex;gap:5px;margin:4px 0;">
            <button onclick="exportIndexJson()" style="flex:1;">Export JSON</button>
            <div class="file-input-container" style="flex:1;">
                <button style="width:100%;">Import JSON</button>
                <input type="file" id="import-json-input" accept=".json" onchange="importIndexJson(this.files[0])">
            </div>
        </div>
    </div>

    <div class="status" id="status">Ready - Load GPX files to start</div>
</div>

<!-- NEW 360 VIEWER -->
<div id="viewer-container">
    <canvas id="canvas"></canvas>
    
    <!-- Loading spinner -->
    <div class="loading" id="viewer-loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading 360¬∞ image...</div>
    </div>
    
    <!-- Navigation controls -->
    <div class="viewer-controls">
        <button onclick="previousImage()">‚Üê Previous</button>
        <span id="viewer-info">No images loaded</span>
        <button onclick="nextImage()">Next ‚Üí</button>
    </div>
    
    <!-- Navigation ring -->
    <div class="image-controls">
        <div class="navigation-ring">
            <button class="nav-button ring-button" id="nextImageBtn">‚ñ≥</button>
            <button class="nav-button ring-button" id="prevImageBtn">‚ñΩ</button>
            <button class="nav-button ring-button" id="branchImageBtn">‚ñ∑</button>
        </div>
          <!-- Branch choices (clickable) -->
  <div id="branch-buttons" style="margin-top:8px; display:flex; gap:6px; pointer-events:auto;"></div>

    </div>
    
    <!-- Image counter -->
    <div class="time" id="time">-/-</div>
    
    <!-- Zoom controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn">+</button>
        <button class="zoom-btn" id="zoomOut">-</button>
    </div>
</div>

    <!-- Mapbox JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@4.5.0/dist/togeojson.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    

<script>
    // Initialize Mapbox
    mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';

    // Global variables
    let map;
    let isEditMode = false;
    let currentMode = 'view';
    let allTracks = new Map();
    let currentTrackId = null;
    let currentDensity = 100;
    let isDragging = false;
    let dragPointId = -1;
    let nextPointId = 1000;
    let nextTrackId = 1;
    let isCatmullRomEnabled = false;
    let wasCatmullRomEnabledBeforeEdit = false;
    // ===== 360 VIEWER VARIABLES =====
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;
let viewConeMarker = null;
let isGoingForward = true;


let lastHopBearingDeg = null; // optional bias to "keep going straight"

    // Marble system variables - now track-specific
    let isDraggingMarble = false;
    let dragMarbleIndex = -1;
    let selectedMarbleId = null;

    // Marriage system variables
    let marriageGroups = []; // Array of arrays: [["senterra1.gpx:15", "senterra2.gpx:42"], ...]
    let marryModeActive = false;
    let marrySelection = new Set(); // Set of marble IDs currently selected for marriage

    // 360 Viewer variables
    let viewer;
    let currentImages = [];
    // Frames folder (same-origin)
    const FRAMES_BASE = 'https://andresmtzc.github.io/geepeeX/senterra/frames/';
    let currentImageIndex = -1;
    let imageAssignments = new Map(); // marbleId -> imageIndex

    // Color palette for tracks
    const trackColors = [
        '#EA4335', '#4285F4', '#34A853', '#FBBC05', '#FF6D01',
        '#46BDC6', '#9334E6', '#E67C73', '#109D58', '#3F51B5'
    ];

    // Color palette for marriage groups (distinct, visible colors)
    const marriageColors = [
        '#FF00FF', // Magenta
        '#00FFFF', // Cyan
        '#FFD700', // Gold
        '#FF1493', // DeepPink
        '#00FF7F', // SpringGreen
        '#FF4500', // OrangeRed
        '#9400D3', // DarkViolet
        '#00CED1', // DarkTurquoise
        '#FF69B4', // HotPink
        '#32CD32', // LimeGreen
        '#FF6347', // Tomato
        '#4169E1', // RoyalBlue
    ];

    // Initialize map and viewer
function initializeApp() {
    // Initialize Mapbox map
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/outdoors-v12',
        center: [0, 0],
        zoom: 1,
        cooperativeGestures: false
    });

    // Wait for map to load
    map.on('load', async () => {
        console.log('Map loaded successfully');
        document.getElementById('gpx-file').addEventListener('change', handleGPXUpload);

        // Setup local frames folder picker
        document.getElementById('local-frames-input').addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                loadLocalFrames(e.target.files);
            }
        });

        // Setup density slider
        const densitySlider = document.getElementById('density-slider');
        densitySlider.addEventListener('input', handleDensityChange);
        
        // Setup marble spacing slider
        const marbleSpacingSlider = document.getElementById('marble-spacing-slider');
        marbleSpacingSlider.addEventListener('input', updateMarbleSpacing);
        
        // Create sources for tracks
        map.addSource('tracks-line', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
        });

        map.addSource('control-points', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
        });

        // Create source for marbles
        map.addSource('marbles', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
        });

            // Add tracks line layer
            map.addLayer({
                id: 'gpx-tracks-line',
                type: 'line',
                source: 'tracks-line',
    paint: {
        'line-color': ['get', 'color'],
        'line-width': ['case', ['==', ['get', 'isActive'], true], 4, 2],
        'line-opacity': ['case', ['==', ['get', 'isActive'], true], 0.8, 0.5]
    },
    layout: {
        'visibility': 'none' // HIDDEN BY DEFAULT
    }
            });

            // Add control points layer
            map.addLayer({
                id: 'gpx-control-points',
                type: 'circle',
                source: 'control-points',
                paint: {
                    'circle-radius': 6,
                    'circle-color': '#EA4335',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff',
                    'circle-opacity': ['case', 
                        ['all', 
                ['==', ['get', 'isActive'], true],
                ['==', ['get', 'isEditMode'], true]
            ], 1, 0
        ]
    },
    layout: {
        'visibility': 'none' // HIDDEN BY DEFAULT
    }
            });

            // Add marbles layer - FIXED: removed broken comment
            map.addLayer({
                id: 'marbles-layer',
                type: 'circle',
                source: 'marbles',
                paint: {
                    'circle-radius': ['case',
                        ['==', ['get', 'isDragging'], true], 7,
                        ['==', ['get', 'isMarrySelected'], true], 8, // Larger when selected for marriage
                        ['==', ['get', 'isSelected'], true], 6,
                        ['==', ['get', 'isMarried'], true], 6, // Married marbles are larger
                        ['==', ['get', 'isFixed'], true], 5,
                        ['==', ['get', 'isLocked'], true], 4.5,
                        ['==', ['get', 'hasImage'], true], 2,
                        4
                    ],
                    'circle-color': ['case',
                        ['==', ['get', 'isDragging'], true], '#FFD700',
                        ['==', ['get', 'isMarrySelected'], true], '#00FFFF', // Cyan when selected for marriage
                        ['==', ['get', 'isSelected'], true], '#ff8400',
                        ['==', ['get', 'isMarried'], true], ['get', 'marriageColor'], // Use marriage group color
                        ['==', ['get', 'isFixed'], true], '#FF0000',
                        ['==', ['get', 'isLocked'], true], '#FF6B35',
                        ['==', ['get', 'hasImage'], true], 'rgba(52, 168, 83, 0)',
                        '#8B4513'
                    ],
                    'circle-stroke-width': ['case',
                        ['==', ['get', 'isMarrySelected'], true], 3, // Thick stroke when selected for marriage
                        ['==', ['get', 'isMarried'], true], 2, // Stroke for married marbles
                        ['==', ['get', 'isSelected'], true], 0,
                        ['==', ['get', 'hasImage'], true], 1,
                        0
                    ],
                    'circle-stroke-color': ['case',
                        ['==', ['get', 'isMarrySelected'], true], '#FFFFFF',
                        ['==', ['get', 'isMarried'], true], '#FFFFFF',
                        '#FFFFFF'
                    ]
                }
            });

            // Add INVISIBLE click layer (LARGE click area)
map.addLayer({
    id: 'marbles-click-layer',
    type: 'circle',
    source: 'marbles',
    paint: {
        'circle-radius': 8, // Large click area
        'circle-opacity': 0, // Completely invisible
        'circle-stroke-width': 0
    }
});

            // Add a symbol layer for image numbers on marbles
map.addLayer({
    id: 'marble-labels',
    type: 'symbol',
    source: 'marbles',
    layout: {
        'text-field': ['case',
            ['==', ['get', 'hasImage'], true],
            ['concat', ['get', 'imageIndex']],
            '' // No text for marbles without images
        ],
        'text-size': 10,
        'text-offset': [1, 0],
        'text-anchor': 'center',
        'visibility': 'none' // HIDDEN BY DEFAULT
    },
    paint: {
        'text-color': '#FFFFFF',
        'text-halo-color': '#000000',
        'text-halo-width': 1
    }
});
 addTrackToggle();
        initConeSystem();
        addMarbleNavigationButtons();
        setupMapInteractions();

    setTimeout(() => {
        try {
            addCustomImage(map);
        } catch (error) {
            console.error('Drone image failed, but continuing:', error);
        }
    }, 1000);

        // AUTO-LOAD GPX FILES FROM MANIFEST
        await loadGPXFromManifest();
    });

    // Initialize 360 viewer
    initializeViewer();
}



    // Setup map interactions
    function setupMapInteractions() {
    map.on('mouseup', () => {
        if (isDragging) {
            setTimeout(() => {
                isDragging = false;
                dragPointId = -1;
                map.getCanvas().style.cursor = 'move';
                enableMapInteractions();
            }, 50);
        }
        if (isDraggingMarble) {
            stopMarbleDrag();
        }
    });
    
    // ADD THESE: Update view cone on map interactions
    map.on('zoom', () => {
        if (selectedMarbleId) {
            updateViewCone();
        }
    });
    
    map.on('move', () => {
        if (selectedMarbleId) {
            updateViewCone();
        }
    });
}

// DRONE IMAGE - Add custom recent drone satellite image as a raster layer
function addCustomImage(map) {
  try {
    // Coordinates for the custom drone image (georeferenced)
    const imageBounds = [
      [-100.16483, 25.467111], // Top-left corner [lng, lat]
      [-100.154874, 25.467111], // Top-right corner [lng, lat]
      [-100.154874, 25.457155], // Bottom-right corner [lng, lat]
      [-100.16483, 25.457155],  // Bottom-left corner [lng, lat]
    ];

    map.addSource('drone-satellite', { 
      type: 'image',
      url: 'https://la-la.land/santte2.jpg', // Your drone image URL
      coordinates: imageBounds // Set the coordinates for where the image will be placed
    });

    map.addLayer({
      id: 'drone-satellite-layer',
      type: 'raster',
      source: 'drone-satellite',
      paint: {
        'raster-opacity': 1
      }
    }, 'gpx-tracks-line');  // Insert BELOW 'road' layer, so roads are on top

    console.log('Drone image loaded successfully');
    // showToaster("Cargamos la im√°gen a√©rea m√°s actual ‚Äî (marzo 2025)");
    
  } catch (error) {
    console.error('Error loading drone image:', error);
  }
}

async function loadGPXFromManifest() {
    try {
        setStatus('Loading predefined tracks...');
        
        // Hardcoded URL to the manifest
        const MANIFEST_URL = 'https://andresmtzc.github.io/geepeeX/senterra/frames/index.json';
        
        console.log('Fetching manifest from:', MANIFEST_URL);
        
        const res = await fetch(MANIFEST_URL, { cache: 'no-store' });
        if (!res.ok) {
            console.log('No manifest found or unable to load');
            setStatus('No predefined tracks found');
            return;
        }
        
        const manifest = await res.json();
        console.log('Manifest loaded:', manifest);

        // Store files array for export
        if (manifest.files) {
            window.loadedManifestFiles = manifest.files;
        }

        // üîπ Load yaw fixes from manifest
        window.yawFixesByFile = manifest.yawfixes || {};
        console.log('Yaw fixes loaded:', window.yawFixesByFile);

        // Load marriages if present
        if (manifest.marriages && Array.isArray(manifest.marriages)) {
            marriageGroups = manifest.marriages;
            console.log('Loaded marriages:', marriageGroups);
        }

        let gpxFiles = [];
        
        // Your manifest has BOTH files and gpxFiles arrays
        if (manifest.gpxFiles && manifest.gpxFiles.length > 0) {
            // Use the gpxFiles array specifically
            gpxFiles = manifest.gpxFiles;
            console.log('Using gpxFiles array:', gpxFiles);
        } else if (manifest.files) {
            // Fallback: look for .gpx files in the main files array
            gpxFiles = manifest.files.filter(file => file.toLowerCase().endsWith('.gpx'));
            console.log('Found GPX files in files array:', gpxFiles);
        }
        
        console.log('Final GPX files to load:', gpxFiles);
        
        if (gpxFiles.length === 0) {
            console.log('No GPX files found in manifest');
            setStatus('No predefined tracks in manifest');
            return;
        }
        
        setStatus(`Loading ${gpxFiles.length} predefined tracks...`);
        
        // Load each GPX file
        let loadedCount = 0;
        for (const gpxFile of gpxFiles) {
            try {
                console.log(`Loading GPX: ${gpxFile}`);
                await loadSingleGPX(gpxFile);
                loadedCount++;
            } catch (error) {
                console.error(`Failed to load ${gpxFile}:`, error);
                setStatus(`Failed to load ${gpxFile}`);
            }
        }
        
        console.log(`Successfully loaded ${loadedCount} tracks`);
        setStatus(`Auto-loaded ${loadedCount} predefined tracks`);
        
        // Auto-select the first track if any were loaded
        if (loadedCount > 0 && allTracks.size > 0) {
            const firstTrackId = Array.from(allTracks.keys())[0];
            if (firstTrackId) {
                selectTrack(firstTrackId);
                const track = allTracks.get(firstTrackId);
                setStatus(`Auto-selected: ${track.name}`);
            }
        } else {
            setStatus('No tracks were successfully loaded');
        }
        
    } catch (error) {
        console.error('Error loading GPX from manifest:', error);
        setStatus('Error loading predefined tracks - check console');
    }
}

async function loadSingleGPX(filename) {
    try {
        // Ensure filename has correct path
        const fullPath = filename.startsWith(FRAMES_BASE) ? filename : FRAMES_BASE + filename;
        const response = await fetch(fullPath);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const gpxContent = await response.text();

        // üîπ Extract yaw fix for this GPX file
        const baseName = filename.split('/').pop();
        const yawFixDeg = window.yawFixesByFile?.[baseName] ?? 0;
        console.log(`Applying yaw fix ${yawFixDeg}¬∞ to ${baseName}`);

        // PASS isPredefined = true and yawFixDeg for manifest-loaded files
        parseGPX(gpxContent, baseName, true, yawFixDeg);

    } catch (error) {
        console.error(`Error loading GPX file ${filename}:`, error);
        throw error;
    }
}

    // Handle multiple GPX file upload
function handleGPXUpload(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;

    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = function(e) {
            const gpxContent = e.target.result;
            parseGPX(gpxContent, file.name, false); // User-uploaded files are not predefined
        };
        reader.readAsText(file);
    });
}

    // Parse GPX and add as new track
   function parseGPX(gpxContent, fileName, isPredefined = false, yawFixDeg = 0) {
    try {
        const parser = new DOMParser();
        const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');
        
        // Extract ALL track points with their times
        const trkpts = gpxDoc.querySelectorAll('trkpt');
        const pointsWithTime = [];
        
        trkpts.forEach((trkpt, index) => {
            const lat = parseFloat(trkpt.getAttribute('lat'));
            const lon = parseFloat(trkpt.getAttribute('lon'));
            const timeElement = trkpt.querySelector('time');
            
            pointsWithTime.push({
                id: index,
                coordinates: [lon, lat],
                originalIndex: index,
                time: timeElement ? timeElement.textContent : null
            });
        });
        
        if (pointsWithTime.length === 0) {
            if (!isPredefined) { // Only alert for user-uploaded files
                alert(`No track points found in ${fileName}`);
            }
            return;
        }
        
        // Create track with original statistics
        const trackId = `track-${nextTrackId++}`;
        const trackColor = trackColors[(nextTrackId - 2) % trackColors.length];
        
        const trackData = {
            id: trackId,
            name: fileName.replace('.gpx', ''),
            color: trackColor,
            yawFixDeg: yawFixDeg, // üîπ Store the per-track yaw correction
            originalPoints: pointsWithTime,
            activePoints: [],
            density: 100,
            isActive: false,
            isPredefined: isPredefined, // Mark as predefined
            originalStats: calculateOriginalStatsFromPoints(pointsWithTime),
            marbles: [],
            marbleSpacing: 10
        };
        
        // Apply initial density
        applyDensityFilterToTrack(trackData, currentDensity);
        
        // Parse waypoints and create marbles
        parseWaypointsFromGPX(gpxDoc, trackData);
        
        // Add to tracks map
        allTracks.set(trackId, trackData);
        
        // Rebuild navigation graph for waypoints
                
        // If first track, select it
        if (allTracks.size === 1) {
            selectTrack(trackId);
        } else {
            updateTracksList();
            updateAllTracksVisualization();
            setStatus(`Loaded ${fileName} with ${trackData.originalPoints.length} points and ${trackData.marbles.length} waypoints`);
        }
        
    } catch (error) {
        console.error('Error parsing GPX:', error);
        if (!isPredefined) { // Only alert for user-uploaded files
            alert(`Error parsing ${fileName}. Please check the file format.`);
        }
    }
}
 
function parseWaypointsFromGPX(gpxDoc, trackData) {
    const waypoints = gpxDoc.querySelectorAll('wpt');
    const coordinates = getDisplayCoordinates(trackData);
    const totalDistance = calculateTotalDistance(coordinates);
    
    waypoints.forEach((wpt, index) => {
        const lat = parseFloat(wpt.getAttribute('lat'));
        const lon = parseFloat(wpt.getAttribute('lon'));
        const nameElement = wpt.querySelector('name');
        const descElement = wpt.querySelector('desc');
        const timeElement = wpt.querySelector('time');
        
        const name = nameElement ? nameElement.textContent : `Waypoint_${index + 1}`;
        const description = descElement ? descElement.textContent : '';
        const time = timeElement ? timeElement.textContent : null;
        
        // USE EXACT POSITION - don't recalculate based on track
        const marble = {
            id: `${trackData.name}-${index}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            index: trackData.marbles.length,
            position: [lon, lat], // This is the exact exported position
            distanceAlongRoute: 0, // We'll set this below
            isLocked: false,
            isFixed: false,
            assignedImage: extractImageIndexFromWaypoint(name, description),
            isWaypoint: true,
            originalName: name,
            description: description,
            time: time
        };
        
        // Only find distance for ordering, don't change position
        const closestPoint = findClosestPointOnRoute([lon, lat], coordinates);
        if (closestPoint) {
            marble.distanceAlongRoute = closestPoint.distance;
            // DON'T change marble.position!
        }
        
        trackData.marbles.push(marble);
    });
    
    // Keep the sorting to maintain order
    trackData.marbles.sort((a, b) => a.distanceAlongRoute - b.distanceAlongRoute);
    trackData.marbles.forEach((marble, index) => {
        marble.index = index;
    });
    
    console.log(`Created ${trackData.marbles.length} marbles from waypoints - USING EXACT POSITIONS`);
}

function extractImageIndexFromWaypoint(name, description) {
    // Try to extract image index from waypoint name or description
    // Looks for patterns like "Image 1" or "Photo_1" etc.
    
    const text = (name + ' ' + description).toLowerCase();
    
    // Look for "image X" pattern
    const imageMatch = text.match(/image[^\d]*(\d+)/);
    if (imageMatch) {
        return parseInt(imageMatch[1]) - 1; // Convert to 0-based index
    }
    
    // Look for "photo X" pattern  
    const photoMatch = text.match(/photo[^\d]*(\d+)/);
    if (photoMatch) {
        return parseInt(photoMatch[1]) - 1;
    }
    
    // Look for numbers at the end of the name
    const numberMatch = name.match(/(\d+)$/);
    if (numberMatch) {
        return parseInt(numberMatch[1]) - 1;
    }
    
    return null; // No image index found
}

    // Calculate stats directly from points array
    function calculateOriginalStatsFromPoints(points) {
        const coordinates = points.map(p => p.coordinates);
        const timeData = points.map(p => p.time).filter(t => t);
        
        const distance = calculateTotalDistance(coordinates);
        const duration = calculateDurationFromTimes(timeData);
        const avgSpeed = calculateAverageSpeedFromStats(distance, duration);
        
        return {
            distance: distance,
            duration: duration,
            avgSpeed: avgSpeed,
            pointCount: points.length
        };
    }

    // Calculate distance between two coordinates (haversine formula) in meters
    function calculateDistance(coord1, coord2) {
        const R = 6371000; // Earth radius in meters
        const dLat = (coord2[1] - coord1[1]) * Math.PI / 180;
        const dLon = (coord2[0] - coord1[0]) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(coord1[1] * Math.PI / 180) * Math.cos(coord2[1] * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }


// ---- Bearing & angle helpers ----
function bearingDeg(a, b) { // [lng,lat] -> degrees 0..360
  const toRad = d => d * Math.PI/180, toDeg = r => r * 180/Math.PI;
  const œÜ1 = toRad(a[1]), œÜ2 = toRad(b[1]);
  const Œª1 = toRad(a[0]), Œª2 = toRad(b[0]);
  const y = Math.sin(Œª2-Œª1) * Math.cos(œÜ2);
  const x = Math.cos(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1) - Math.sin(œÜ1)*Math.sin(œÜ2);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}
function angularDiffDeg(a, b) { // smallest |a-b|
  let d = Math.abs(a-b) % 360;
  return d > 180 ? 360 - d : d;
}


    // Calculate total distance of a track in meters
    function calculateTotalDistance(points) {
        if (points.length < 2) return 0;
        
        let totalDistance = 0;
        for (let i = 1; i < points.length; i++) {
            totalDistance += calculateDistance(points[i-1], points[i]);
        }
        return totalDistance;
    }

    // Calculate duration from time array
    function calculateDurationFromTimes(timeData) {
        if (timeData.length < 2) return '0s';
        
        try {
            const startTime = new Date(timeData[0]);
            const endTime = new Date(timeData[timeData.length - 1]);
            const durationMs = endTime - startTime;
            
            const hours = Math.floor(durationMs / (1000 * 60 * 60));
            const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        } catch (e) {
            return '0s';
        }
    }

    // Calculate average speed from distance and duration
    function calculateAverageSpeedFromStats(distanceMeters, durationString) {
        if (durationString === '0s' || distanceMeters === 0) return 0;
        
        try {
            let totalHours = 0;
            
            if (durationString.includes('h')) {
                const hoursMatch = durationString.match(/(\d+)h/);
                const minutesMatch = durationString.match(/(\d+)m/);
                const secondsMatch = durationString.match(/(\d+)s/);
                
                const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = hours + (minutes / 60) + (seconds / 3600);
            } else if (durationString.includes('m')) {
                const minutesMatch = durationString.match(/(\d+)m/);
                const secondsMatch = durationString.match(/(\d+)s/);
                
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = (minutes / 60) + (seconds / 3600);
            } else if (durationString.includes('s')) {
                const secondsMatch = durationString.match(/(\d+)s/);
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = seconds / 3600;
            }
            
            const distanceKm = distanceMeters / 1000;
            return totalHours > 0 ? distanceKm / totalHours : 0;
            
        } catch (e) {
            return 0;
        }
    }

    // Apply density filter to a specific track
    function applyDensityFilterToTrack(trackData, densityPercent) {
        const totalPoints = trackData.originalPoints.length;
        const targetCount = Math.max(2, Math.floor((totalPoints * densityPercent) / 100));
        
        if (targetCount >= totalPoints) {
            trackData.activePoints = trackData.originalPoints.map(p => ({...p}));
        } else {
            trackData.activePoints = selectPointsEvenlyImproved(trackData.originalPoints, targetCount);
        }
        
        trackData.density = densityPercent;
    }

    // Select points evenly distributed
    function selectPointsEvenlyImproved(points, targetCount) {
        if (points.length <= targetCount) return points.map(p => ({...p}));
        if (targetCount <= 2) return [points[0], points[points.length - 1]].map(p => ({...p}));
        
        const selected = [];
        const totalSegments = targetCount - 1;
        const segmentSize = (points.length - 1) / totalSegments;
        
        selected.push({...points[0]});
        
        for (let i = 1; i < targetCount - 1; i++) {
            const index = Math.round(i * segmentSize);
            const safeIndex = Math.min(Math.max(index, 1), points.length - 2);
            selected.push({...points[safeIndex]});
        }
        
        selected.push({...points[points.length - 1]});
        
        return removeDuplicatesPreserveOrder(selected);
    }

    // Remove duplicates while preserving order
    function removeDuplicatesPreserveOrder(points) {
        const unique = [];
        const seenIds = new Set();
        
        for (const point of points) {
            if (!seenIds.has(point.id)) {
                unique.push(point);
                seenIds.add(point.id);
            }
        }
        
        return unique;
    }

    // Calculate bounds from coordinates
    function calculateBounds(coordinates) {
        if (coordinates.length === 0) return null;
        
        const bounds = new mapboxgl.LngLatBounds();
        coordinates.forEach(coord => {
            bounds.extend(coord);
        });
        return bounds;
    }

    // Fly to track bounds
    function flyToTrack(trackData) {
        const coordinates = trackData.activePoints.map(p => p.coordinates);
        const bounds = calculateBounds(coordinates);
        
        if (bounds) {
            map.fitBounds(bounds, {
                padding: 50,
                duration: 1000,
                essential: true
            });
        }
    }

    // Select a track for editing
    function selectTrack(trackId) {
    // Deselect previous track
    if (currentTrackId && allTracks.has(currentTrackId)) {
        allTracks.get(currentTrackId).isActive = false;
    }
    
    // Select new track
    currentTrackId = trackId;
    const track = allTracks.get(trackId);
    track.isActive = true;
    
    // Update density slider to match selected track
    currentDensity = track.density;
    document.getElementById('density-slider').value = currentDensity;
    document.getElementById('density-value').textContent = currentDensity + '%';
    
    // Update marble spacing slider to match current track
    document.getElementById('marble-spacing-slider').value = track.marbleSpacing;
    document.getElementById('marble-spacing').textContent = track.marbleSpacing;
    
    // Update point counts
    document.getElementById('points-count').textContent = track.activePoints.length + ' points';
    document.getElementById('original-count').textContent = 'of ' + track.originalPoints.length;

    updateStatistics();
    
    // Reset edit mode but KEEP Catmull-Rom state
    if (isEditMode) {
        disableEditing();
        isEditMode = false;
        document.getElementById('edit-btn').textContent = 'Edit Mode: OFF';
        document.getElementById('edit-btn').classList.remove('active');
    }

    // Keep Catmull-Rom state as is
    document.getElementById('catmull-btn').textContent = isCatmullRomEnabled ? 'Catmull-Rom: ON' : 'Catmull-Rom: OFF';
    document.getElementById('catmull-btn').classList.toggle('active', isCatmullRomEnabled);
    
    // Clear marble selection state (but keep the track's marbles)
    selectedMarbleId = null;
    isDraggingMarble = false;
    dragMarbleIndex = -1;
    
    updateTracksList();
    updateAllTracksVisualization();
    updateMarbleDisplay(); // Show current track's marbles
    
    // FLY TO THE TRACK BOUNDS
    flyToTrack(track);
    
    // AUTO-LOAD IMAGES WHEN TRACK IS SELECTED
    load360Images();
    
    setStatus(`Selected: ${track.name} - ${track.marbles.length} marbles`);
}

    // Update statistics display
    function updateStatistics() {
        const track = getCurrentTrack();
        if (!track) {
            clearStatistics();
            return;
        }
        
        const stats = track.originalStats;
        const distanceKm = stats.distance / 1000;
        
        document.getElementById('total-distance').textContent = 
            distanceKm < 1 ? 
            `${stats.distance.toFixed(0)} m` : 
            `${distanceKm.toFixed(2)} km`;
        
        document.getElementById('avg-speed').textContent = 
            `${stats.avgSpeed.toFixed(1)} km/h`;
        
        document.getElementById('stats-points').textContent = 
            stats.pointCount;
        
        document.getElementById('total-duration').textContent = 
            stats.duration;
    }

    // Clear statistics when no track is selected
    function clearStatistics() {
        document.getElementById('total-distance').textContent = '0 km';
        document.getElementById('avg-speed').textContent = '0 km/h';
        document.getElementById('stats-points').textContent = '0';
        document.getElementById('total-duration').textContent = '0s';
    }

    // Remove a track
    function removeTrack(trackId) {
        allTracks.delete(trackId);
        
        if (currentTrackId === trackId) {
            currentTrackId = null;
            if (allTracks.size > 0) {
                selectTrack(Array.from(allTracks.keys())[0]);
            } else {
                document.getElementById('points-count').textContent = '0 points';
                document.getElementById('original-count').textContent = '';
                isCatmullRomEnabled = false;
                document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
                document.getElementById('catmull-btn').classList.remove('active');
                clearStatistics();
            }
        }
        
        updateTracksList();
        updateAllTracksVisualization();
    }

    // Update tracks list UI
    function updateTracksList() {
    const tracksList = document.getElementById('tracks-list');
    tracksList.innerHTML = '';
    
    if (allTracks.size === 0) {
        tracksList.innerHTML = `
            <div style="text-align: center; padding: 10px; color: #666; font-size: 12px;">
                No tracks loaded<br>
                <small>Drop GPX files or they will auto-load from manifest</small>
            </div>
        `;
        return;
    }
    
    allTracks.forEach((track, trackId) => {
        const trackItem = document.createElement('div');
        trackItem.className = `track-item ${track.isActive ? 'track-active' : ''}`;
        
        // Add a small indicator for predefined tracks
        const isPredefined = track.isPredefined ? ' üìÅ' : '';
        
        trackItem.innerHTML = `
            <div class="track-info">
                <div class="track-color" style="background-color: ${track.color}"></div>
                <span title="${track.name}">
                    ${track.name.length > 20 ? track.name.substring(0, 20) + '...' : track.name}
                    ${isPredefined}
                </span>
            </div>
            <div class="track-actions">
                <button class="small-btn" onclick="selectTrack('${trackId}')">Edit</button>
                <button class="small-btn" onclick="exportSingleTrack('${trackId}')" title="Export this track">üíæ</button>
                <button class="small-btn" onclick="removeTrack('${trackId}')">√ó</button>
            </div>
        `;
        
        trackItem.onclick = (e) => {
            if (!e.target.closest('.track-actions')) {
                selectTrack(trackId);
            }
        };
        
        tracksList.appendChild(trackItem);
    });
}

    // Get current track data
    function getCurrentTrack() {
        return currentTrackId ? allTracks.get(currentTrackId) : null;
    }

    // Get current track's marbles
    function getCurrentMarbles() {
        const track = getCurrentTrack();
        return track ? track.marbles : [];
    }

    // Update visualization of all tracks
    function updateAllTracksVisualization(fitBounds = false) {
        if (!map.getSource('tracks-line')) return;

        const features = [];
        let activeTrackCoordinates = [];
        
        allTracks.forEach(track => {
            let displayCoordinates;
            
            if (isCatmullRomEnabled) {
                displayCoordinates = catmullRomSmooth(
                    track.activePoints.map(p => p.coordinates), 
                    15, 
                    0.5
                );
            } else {
                displayCoordinates = track.activePoints.map(p => p.coordinates);
            }
            
            if (track.isActive) {
                activeTrackCoordinates = displayCoordinates;
            }
            
            features.push({
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: displayCoordinates
                },
                properties: {
                    trackId: track.id,
                    color: track.color,
                    isActive: track.isActive
                }
            });
        });
        
        map.getSource('tracks-line').setData({
            type: 'FeatureCollection',
            features: features
        });

        // Update control points for active track
        const track = getCurrentTrack();
        if (track && isEditMode) {
            const controlPointFeatures = track.activePoints.map((point, index) => {
                return {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: point.coordinates
                    },
                    properties: {
                        id: point.id,
                        trackId: track.id,
                        isActive: true,
                        isEditMode: isEditMode
                    }
                };
            });

            map.getSource('control-points').setData({
                type: 'FeatureCollection',
                features: controlPointFeatures
            });
        } else {
            map.getSource('control-points').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        if (fitBounds && activeTrackCoordinates.length > 0) {
            const bounds = calculateBounds(activeTrackCoordinates);
            if (bounds) {
                map.fitBounds(bounds, { padding: 50, duration: 1000 });
            }
        }
    }

    // Handle density slider change for current track
    function handleDensityChange(e) {
    currentDensity = parseInt(e.target.value);
    document.getElementById('density-value').textContent = currentDensity + '%';
    
    const track = getCurrentTrack();
    if (track) {
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        applyDensityFilterToTrack(track, currentDensity);
        updateAllTracksVisualization(false);
        
        // AUTO-UPDATE MARBLES AFTER DENSITY CHANGE
        if (track.marbles.length > 0) {
            reattachMarblesToTrack(track);
        }
        
        document.getElementById('points-count').textContent = track.activePoints.length + ' points';
        document.getElementById('original-count').textContent = 'of ' + track.originalPoints.length;
        
        if (wasCatmullRomEnabledBeforeEdit) {
            setTimeout(() => enableCatmullRom(), 10);
        }
    }
}

    // Catmull-Rom smoothing
    function catmullRomSmooth(points, segments = 20, tension = 0.5) {
        if (points.length < 3) return points;
        
        const smoothed = [points[0]];
        
        for (let i = 0; i < points.length - 1; i++) {
            const p0 = i > 0 ? points[i - 1] : points[i];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = i < points.length - 2 ? points[i + 2] : p2;
            
            for (let t = 1; t <= segments; t++) {
                const percentage = t / segments;
                
                const x = catmullRom(percentage, p0[0], p1[0], p2[0], p3[0], tension);
                const y = catmullRom(percentage, p0[1], p1[1], p2[1], p3[1], tension);
                
                smoothed.push([x, y]);
            }
        }
        
        smoothed.push(points[points.length - 1]);
        return smoothed;
    }

    function catmullRom(t, p0, p1, p2, p3, tension) {
        const v0 = (p2 - p0) * tension;
        const v1 = (p3 - p1) * tension;
        const t2 = t * t;
        const t3 = t * t2;
        
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + 
               (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + 
               v0 * t + p1;
    }

    // Toggle Catmull-Rom for current track
    function toggleCatmullRom() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        } else {
            enableCatmullRom();
        }
    }

function fitMapToTrackAndMarbles(track) {
    if (!track) return;
    
    const allCoordinates = [
        ...track.activePoints.map(p => p.coordinates),
        ...track.marbles.map(m => m.position)
    ];
    
    if (allCoordinates.length === 0) return;
    
    const bounds = new mapboxgl.LngLatBounds();
    allCoordinates.forEach(coord => {
        bounds.extend(coord);
    });
    
    map.fitBounds(bounds, {
        padding: 50,
        duration: 1000
    });
}

function enableCatmullRom() {
    isCatmullRomEnabled = true;
    document.getElementById('catmull-btn').textContent = 'Catmull-Rom: ON';
    document.getElementById('catmull-btn').classList.add('active');
    updateAllTracksVisualization(false);
    
    const track = getCurrentTrack();
    if (track && track.marbles.length > 0) {
        snapWaypointsToSmoothedTrack(track);
        fitMapToTrackAndMarbles(track); // AUTO-FIT
    }
    
    setStatus('Catmull-Rom smoothing applied');
}

function disableCatmullRom() {
    isCatmullRomEnabled = false;
    document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
    document.getElementById('catmull-btn').classList.remove('active');
    updateAllTracksVisualization(false);
    
    // REATTACH marbles to the original track
    const track = getCurrentTrack();
    if (track && track.marbles.length > 0) {
        reattachMarblesToTrack(track);
    }
    
    setStatus('Catmull-Rom smoothing disabled');
}

    // Clear marbles when edit mode is toggled
    function toggleEditMode() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('Please select a track first!');
        return;
    }

    isEditMode = !isEditMode;
    const btn = document.getElementById('edit-btn');
    
    if (isEditMode) {
        btn.textContent = 'Edit Mode: ON';
        btn.classList.add('active');
        enableEditing();
        
        // KEEP marbles instead of clearing them
        if (track.marbles.length > 0) {
            setStatus(`Editing track - ${track.marbles.length} marbles preserved`);
            // Marbles will auto-reposition when track changes
        } else {
            setStatus('Editing track - no marbles to preserve');
        }
        
    } else {
        btn.textContent = 'Edit Mode: OFF';
        btn.classList.remove('active');
        disableEditing();
        
        // REATTACH marbles to the updated track
        if (track.marbles.length > 0) {
            reattachMarblesToTrack(track);
            setStatus(`Edit complete - ${track.marbles.length} marbles reattached`);
        } else {
            setStatus('Edit mode disabled');
        }
    }
    
    updateAllTracksVisualization(false);
}

function reattachMarblesToTrack(track) {
    if (!track || track.marbles.length === 0) return;
    
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    
    track.marbles.forEach(marble => {
        // Find new position along the updated track
        const safeDistance = Math.min(marble.distanceAlongRoute, totalDistance);
        marble.position = findPositionAtDistance(coordinates, safeDistance);
        marble.distanceAlongRoute = safeDistance;
    });
    
    updateMarbleDisplay();
        setStatus(`Reattached ${track.marbles.length} marbles to updated track`);
}

    // Enable editing functionality
    function enableEditing() {
        map.getCanvas().style.cursor = 'crosshair';
    }

    // Disable editing functionality
    function disableEditing() {
        map.getCanvas().style.cursor = '';
        currentMode = 'view';
        
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
    }

    // Set current editing mode
    function addPointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'add';
        map.getCanvas().style.cursor = 'crosshair';
        setStatus('Add Points: Click on map to add points to current track');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        map.off('click', handlePointAdd);
        map.on('click', handlePointAdd);
    }

    function removePointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'remove';
        map.getCanvas().style.cursor = 'not-allowed';
        setStatus('Remove Points: Click on points to remove them');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.on('click', handlePointRemove);
    }

    function movePointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'move';
        map.getCanvas().style.cursor = 'move';
        setStatus('Move Points: Click and drag points to move them');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        
        enablePointDragging();
    }

    // Handle adding points to current track
    function handlePointAdd(e) {
    if (currentMode !== 'add') return;
    const track = getCurrentTrack();
    if (!track) return;
    
    if (isCatmullRomEnabled) {
        disableCatmullRom();
    }
    
    const newPoint = {
        id: nextPointId++,
        coordinates: [e.lngLat.lng, e.lngLat.lat],
        originalIndex: -1
    };
    
    const insertIndex = findBestInsertPosition(newPoint.coordinates, track.activePoints);
    track.activePoints.splice(insertIndex, 0, newPoint);
    
    updateAllTracksVisualization(false);
    
    // AUTO-UPDATE MARBLES AFTER POINT ADDITION
    if (track.marbles.length > 0) {
        reattachMarblesToTrack(track);
    }
    
    if (wasCatmullRomEnabledBeforeEdit) {
        setTimeout(() => enableCatmullRom(), 10);
    }
    
    document.getElementById('points-count').textContent = track.activePoints.length + ' points';
    setStatus(`Point added. Total: ${track.activePoints.length}`);
}

    // Find best position to insert point
    function findBestInsertPosition(newCoord, points) {
        if (points.length < 2) return points.length;
        
        let bestIndex = points.length - 1;
        let minDistance = Infinity;
        
        for (let i = 0; i < points.length - 1; i++) {
            const segmentStart = points[i].coordinates;
            const segmentEnd = points[i + 1].coordinates;
            const distance = distanceToSegment(newCoord, segmentStart, segmentEnd);
            
            if (distance < minDistance) {
                minDistance = distance;
                bestIndex = i + 1;
            }
        }
        
        return bestIndex;
    }

    // Calculate distance from point to line segment
    function distanceToSegment(point, segmentStart, segmentEnd) {
        const A = point[0] - segmentStart[0];
        const B = point[1] - segmentStart[1];
        const C = segmentEnd[0] - segmentStart[0];
        const D = segmentEnd[1] - segmentStart[1];

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
            xx = segmentStart[0];
            yy = segmentStart[1];
        } else if (param > 1) {
            xx = segmentEnd[0];
            yy = segmentEnd[1];
        } else {
            xx = segmentStart[0] + param * C;
            yy = segmentStart[1] + param * D;
        }

        const dx = point[0] - xx;
        const dy = point[1] - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Handle removing points from current track
   function handlePointRemove(e) {
    if (currentMode !== 'remove') return;
    const track = getCurrentTrack();
    if (!track) return;
    
    if (isCatmullRomEnabled) {
        disableCatmullRom();
    }
    
    const features = map.queryRenderedFeatures(e.point, {
        layers: ['gpx-control-points']
    });
    
    if (features.length > 0) {
        const pointId = features[0].properties.id;
        const pointIndex = track.activePoints.findIndex(p => p.id === pointId);
        
        if (pointIndex !== -1 && track.activePoints.length > 2) {
            track.activePoints.splice(pointIndex, 1);
            updateAllTracksVisualization(false);
            
            // AUTO-UPDATE MARBLES AFTER POINT REMOVAL
            if (track.marbles.length > 0) {
                reattachMarblesToTrack(track);
            }
            
            if (wasCatmullRomEnabledBeforeEdit) {
                setTimeout(() => enableCatmullRom(), 10);
            }
            
            document.getElementById('points-count').textContent = track.activePoints.length + ' points';
            setStatus(`Point removed. Total: ${track.activePoints.length}`);
        } else if (track.activePoints.length <= 2) {
            setStatus('Cannot remove point - track must have at least 2 points');
        }
    }
}

    // Enable point dragging
    function enablePointDragging() {
        map.on('mousedown', 'gpx-control-points', startPointDrag);
        map.on('mousemove', handlePointDrag);
        map.on('mouseup', stopPointDrag);
    }

    function startPointDrag(e) {
        if (currentMode !== 'move') return;
        const track = getCurrentTrack();
        if (!track) return;
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        }
        
        e.preventDefault();
        isDragging = true;
        dragPointId = e.features[0].properties.id;
        map.getCanvas().style.cursor = 'grabbing';
        disableMapInteractions();
    }

function handlePointDrag(e) {
    if (!isDragging || dragPointId === -1) return;
    const track = getCurrentTrack();
    if (!track) return;
    
    const pointIndex = track.activePoints.findIndex(p => p.id === dragPointId);
    if (pointIndex !== -1) {
        track.activePoints[pointIndex].coordinates = [e.lngLat.lng, e.lngLat.lat];
        updateAllTracksVisualization(false);
        
        // AUTO-UPDATE MARBLES DURING DRAG (real-time)
        if (track.marbles.length > 0) {
            reattachMarblesToTrack(track);
        }
    }
}

    function stopPointDrag() {
        if (isDragging) {
            isDragging = false;
            dragPointId = -1;
            map.getCanvas().style.cursor = 'move';
            enableMapInteractions();
            
            if (wasCatmullRomEnabledBeforeEdit) {
                setTimeout(() => enableCatmullRom(), 10);
            }
            
            setStatus('Point moved');
        }
    }

    // Reset current track to original
    function resetCurrentTrack() {
        const track = getCurrentTrack();
        if (track) {
            applyDensityFilterToTrack(track, 100);
            currentDensity = 100;
            document.getElementById('density-slider').value = 100;
            document.getElementById('density-value').textContent = '100%';
            document.getElementById('points-count').textContent = track.activePoints.length + ' points';
            updateAllTracksVisualization(false);
            setStatus(`Reset ${track.name} to original`);
        }
    }

    // Clear all tracks
    function clearAllRoutes() {
        allTracks.clear();
        currentTrackId = null;
        resetState();
        updateTracksList();
        updateAllTracksVisualization(false);
        setStatus('All tracks cleared');
    }

    // Image overlay functions
    const OVERLAY_SOURCE_ID = 'image-overlay-source';
    const OVERLAY_LAYER_ID = 'image-overlay-layer';

    function addImageOverlay() {
        const urlInput = document.getElementById('overlay-url');
        const boundsInput = document.getElementById('overlay-bounds');
        const url = urlInput.value.trim();
        const boundsText = boundsInput.value.trim();

        if (!url) {
            setStatus('Please enter an image URL');
            return;
        }

        let bounds;
        try {
            bounds = JSON.parse(boundsText);
            if (!Array.isArray(bounds) || bounds.length !== 4) {
                throw new Error('Need 4 coordinates');
            }
        } catch (e) {
            setStatus('Invalid bounds format. Use: [[lng,lat],[lng,lat],[lng,lat],[lng,lat]]');
            return;
        }

        // Remove existing overlay if any
        removeImageOverlay();

        // Add the image source
        map.addSource(OVERLAY_SOURCE_ID, {
            type: 'image',
            url: url,
            coordinates: bounds
        });

        // Add the layer behind GPX tracks (use 'beforeId' to place it under tracks)
        const firstTrackLayer = map.getLayer('gpx-tracks-line') ? 'gpx-tracks-line' : undefined;
        map.addLayer({
            id: OVERLAY_LAYER_ID,
            type: 'raster',
            source: OVERLAY_SOURCE_ID,
            paint: {
                'raster-opacity': 0.8
            }
        }, firstTrackLayer);

        // Show opacity slider
        document.getElementById('overlay-opacity-container').style.display = 'block';

        // Fit map to the overlay bounds
        const lngs = bounds.map(b => b[0]);
        const lats = bounds.map(b => b[1]);
        map.fitBounds([
            [Math.min(...lngs), Math.min(...lats)],
            [Math.max(...lngs), Math.max(...lats)]
        ], { padding: 50 });

        setStatus('Image overlay added');
    }

    function removeImageOverlay() {
        if (map.getLayer(OVERLAY_LAYER_ID)) {
            map.removeLayer(OVERLAY_LAYER_ID);
        }
        if (map.getSource(OVERLAY_SOURCE_ID)) {
            map.removeSource(OVERLAY_SOURCE_ID);
        }
        document.getElementById('overlay-opacity-container').style.display = 'none';
        setStatus('Image overlay removed');
    }

    function updateOverlayOpacity(value) {
        document.getElementById('overlay-opacity-value').textContent = value + '%';
        if (map.getLayer(OVERLAY_LAYER_ID)) {
            map.setPaintProperty(OVERLAY_LAYER_ID, 'raster-opacity', value / 100);
        }
    }

    // Reset state
    function resetState() {
        currentDensity = 100;
        isCatmullRomEnabled = false;
        wasCatmullRomEnabledBeforeEdit = false;
        document.getElementById('density-slider').value = 100;
        document.getElementById('density-value').textContent = '100%';
        document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
        document.getElementById('catmull-btn').classList.remove('active');
        document.getElementById('points-count').textContent = '0 points';
        document.getElementById('original-count').textContent = '';
        
        // Clear marble selection state
        selectedMarbleId = null;
        isDraggingMarble = false;
        dragMarbleIndex = -1;
        updateMarbleDisplay();
    }

    function setStatus(message) {
        document.getElementById('status').textContent = message;
    }

    // Map interaction control functions
    function disableMapInteractions() {
        if (isDragging) {
            map.dragPan.disable();
            map.scrollZoom.disable();
            map.dragRotate.disable();
            map.boxZoom.disable();
            map.doubleClickZoom.disable();
        }
    }

    function enableMapInteractions() {
        if (!isDragging) {
            map.dragPan.enable();
            map.scrollZoom.enable();
            map.dragRotate.enable();
            map.boxZoom.enable();
            map.doubleClickZoom.enable();
        }
    }

    // ========== MARBLE SYSTEM FUNCTIONS ==========

    function initializeMarbles() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('Please select a track first!');
        return;
    }
    
    track.marbles = [];
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    
    // CREATE EXACTLY AS MANY MARBLES AS WE HAVE IMAGES
    const marbleCount = currentImages.length;
    
    if (marbleCount === 0) {
        setStatus('No images loaded - cannot create marbles');
        return;
    }
    
    for (let i = 0; i < marbleCount; i++) {
        const ratio = i / (marbleCount - 1);
        const targetDistance = ratio * totalDistance;
        const position = findPositionAtDistance(coordinates, targetDistance);
        
        track.marbles.push({
            id: `${track.name}-${i}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            index: i,
            position: position,
            distanceAlongRoute: targetDistance,
            isLocked: (i === 0 || i === marbleCount - 1),
            isFixed: (i === 0 || i === marbleCount - 1),
            assignedImage: i // DIRECT 1:1 ASSIGNMENT
        });
    }
    
    updateMarbleDisplay();
        
    setStatus(`Created ${marbleCount} marbles with 1:1 image assignment`);
}

    function getDisplayCoordinates(track) {
        if (isCatmullRomEnabled) {
            return catmullRomSmooth(
                track.activePoints.map(p => p.coordinates), 
                15, 
                0.5
            );
        } else {
            return track.activePoints.map(p => p.coordinates);
        }
    }

function addMarble() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('Please select a track first!');
        return;
    }
    
    const marbles = track.marbles;
    
    // PREVENT ADDING MARBLES BEYOND AVAILABLE IMAGES
    if (marbles.length >= currentImages.length) {
        setStatus(`Cannot add marble - only ${currentImages.length} images available`);
        return;
    }
    
    if (marbles.length === 0) {
        initializeMarbles();
        return;
    }
    
    // ADD AT THE END
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    const lastMarble = marbles[marbles.length - 1];
    const newDistance = lastMarble.distanceAlongRoute + track.marbleSpacing;
    const safeDistance = Math.min(newDistance, totalDistance);
    
    const newMarble = {
        id: `${track.name}-${marbles.length}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        index: marbles.length,
        position: findPositionAtDistance(coordinates, safeDistance),
        distanceAlongRoute: safeDistance,
        isLocked: false,
        isFixed: false,
        assignedImage: marbles.length // NEXT AVAILABLE IMAGE INDEX
    };
    
    track.marbles.push(newMarble);
    respaceAllMarbles();
    updateMarbleDisplay();
    
    setStatus(`Added marble #${marbles.length} with image ${marbles.length}/${currentImages.length}`);
    }

function repairImageAssignment() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const availableImages = currentImages.length;
    
    if (marbles.length > availableImages) {
        // Remove excess marbles
        track.marbles = marbles.slice(0, availableImages);
        setStatus(`Removed ${marbles.length - availableImages} excess marbles`);
    }
    
    // Reassign images 1:1
    marbles.forEach((marble, index) => {
        marble.assignedImage = index;
        marble.index = index;
    });
    
    updateMarbleDisplay();
    setStatus(`Repaired: ${marbles.length} marbles ‚Üî ${marbles.length} images`);
}

function autoAssignImageToNewMarble() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const newMarble = marbles[marbles.length - 1]; // The one we just added
    
    // Find the next available image
    const usedImageIndices = new Set(marbles.map(m => m.assignedImage).filter(i => i !== null));
    let nextAvailableImage = 0;
    
    while (usedImageIndices.has(nextAvailableImage) && nextAvailableImage < currentImages.length) {
        nextAvailableImage++;
    }
    
    // Assign if we have an available image
    if (nextAvailableImage < currentImages.length) {
        newMarble.assignedImage = nextAvailableImage;
        setStatus(`Assigned image ${nextAvailableImage + 1} to new marble`);
    } else {
        setStatus('No more images available for new marble');
    }
    
    updateMarbleDisplay();
}

function removeMarble() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    if (marbles.length <= 2) {
        setStatus('Cannot remove - must keep start and end marbles');
        return;
    }
    
    // REMOVE FROM THE END (not from the middle)
    let removeIndex = marbles.length - 1;
    
    // Find the last removable marble (not fixed)
    while (removeIndex > 0 && marbles[removeIndex].isFixed) {
        removeIndex--;
    }
    
    // Can't remove if we're at the first marble
    if (removeIndex <= 0) {
        setStatus('Cannot remove - only fixed marbles remain');
        return;
    }
    
    const removedMarble = marbles[removeIndex];
    const removedImageIndex = removedMarble.assignedImage;
    
    // Remove from the array
    track.marbles.splice(removeIndex, 1);
    
    // AUTO-RESPACE ALL MARBLES AFTER REMOVING
    respaceAllMarbles();
    
    // Re-index all marbles
    track.marbles.forEach((marble, index) => {
        marble.index = index;
    });
    
    // DO NOT SHIFT IMAGE ASSIGNMENTS - images stay with their original marble indices
    if (removedImageIndex !== null) {
        setStatus(`Removed marble with image ${removedImageIndex + 1} - image assignments preserved`);
    } else {
        setStatus(`Removed marble without image - ${track.marbles.length} total`);
    }
    
    updateMarbleDisplay();
    }


function respaceAllMarbles() {
    const track = getCurrentTrack();
    if (!track || track.marbles.length < 2) return;
    
    const marbles = track.marbles;
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    
    // STORE image assignments BEFORE respacing
    const imageAssignments = marbles.map(marble => ({
        id: marble.id,
        assignedImage: marble.assignedImage
    }));
    
    // Create a mapping by marble ID for easy lookup
    const assignmentMap = new Map();
    imageAssignments.forEach(assignment => {
        assignmentMap.set(assignment.id, assignment.assignedImage);
    });
    
    // Respace all marbles evenly along the entire track
    for (let i = 0; i < marbles.length; i++) {
        const ratio = i / (marbles.length - 1);
        marbles[i].distanceAlongRoute = ratio * totalDistance;
        marbles[i].position = findPositionAtDistance(coordinates, marbles[i].distanceAlongRoute);
        marbles[i].index = i;
        
        // Keep first and last marbles fixed
        marbles[i].isFixed = (i === 0 || i === marbles.length - 1);
        
        // RESTORE the image assignment using the marble ID
        marbles[i].assignedImage = assignmentMap.get(marbles[i].id);
    }
    
    }

function updateMarbleSpacing() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const spacingSlider = document.getElementById('marble-spacing-slider');
    track.marbleSpacing = parseInt(spacingSlider.value);
    document.getElementById('marble-spacing').textContent = track.marbleSpacing;
    
    if (track.marbles.length > 0) {
        initializeMarbles(); // Rebuild with new spacing
    }
}

function toggleMarbleLock(marbleId) {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
    if (marbleIndex !== -1) {
        // ALLOW unlocking any marble, including endpoints
        track.marbles[marbleIndex].isLocked = !track.marbles[marbleIndex].isLocked;
        updateMarbleDisplay();
        
        let positionText;
        if (marbleIndex === 0) {
            positionText = 'START';
        } else if (marbleIndex === track.marbles.length - 1) {
            positionText = 'END';
        } else {
            positionText = `#${marbleIndex + 1}`;
        }
        
        setStatus(`${positionText} marble ${track.marbles[marbleIndex].isLocked ? 'locked' : 'unlocked'}`);
    }
}

    // UPDATED: Handle marble click to show assigned image
function handleMarbleClick(e) {
    if (e.features.length > 0) {
        const marbleId = e.features[0].properties.id;
        const trackId = e.features[0].properties.trackId; // Get the track ID

        // If Ctrl/Cmd click, toggle lock
        if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {
            toggleMarbleLock(marbleId);
            return;
        }

        // MARRY MODE: Add/remove from marriage selection
        if (marryModeActive) {
            toggleMarrySelection(marbleId);
            return;
        }

        // CHECK IF WE NEED TO SWITCH TRACKS
        if (trackId !== currentTrackId) {
            // Switch to the marble's track first
            selectTrackAndThenMarble(trackId, marbleId);
        } else {
            // Same track - just select the marble
            selectMarble(marbleId);
            showMarbleImage(marbleId);
        }
    } else {
        deselectMarble();
    }
}

// NEW FUNCTION: Switch track then select marble
let isSwitchingToMarble = false;

async function selectTrackAndThenMarble(trackId, marbleId) {
    const previousTrackId = currentTrackId;
    
    try {
        isSwitchingToMarble = true; // SET FLAG
        
        // Switch tracks first
        selectTrackWithoutMapReset(trackId);
        
        // Wait a bit for track switch
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // NOW select the marble
        selectMarble(marbleId);
        
        // Force the image to show for this marble
        const track = getCurrentTrack();
        const marble = track.marbles.find(m => m.id === marbleId);
        if (marble && marble.assignedImage !== null) {
            showImageByIndex(marble.assignedImage);
        }
        
        setStatus(`Switched to ${allTracks.get(trackId).name} and selected marble`);
        
    } catch (error) {
        console.error('Error switching tracks:', error);
        if (previousTrackId) {
            selectTrackWithoutMapReset(previousTrackId);
        }
    } finally {
        isSwitchingToMarble = false; // CLEAR FLAG
    }
}



function navigateToAdjacentMarble(goForward) {
    const track = getCurrentTrack();
    if (!track || !selectedMarbleId) return;
    
    const marbles = track.marbles;
    const currentIndex = marbles.findIndex(m => m.id === selectedMarbleId);
    
    if (currentIndex === -1) return;
    
    let nextIndex = goForward ? currentIndex + 1 : currentIndex - 1;
    
    // DON'T wrap around - stop at endpoints
    if (nextIndex < 0 || nextIndex >= marbles.length) {
        setStatus(goForward ? 'Already at last marble' : 'Already at first marble');
        return;
    }
    
    const nextMarble = marbles[nextIndex];
    selectMarble(nextMarble.id);
    showMarbleImage(nextMarble.id);
    
    setStatus(`Moved to marble ${nextIndex + 1}/${marbles.length}`);
}

function selectMarble(marbleId) {
    // NEW: remember previous selection to compute "continue" bearing
    const prevSelected = selectedMarbleId;

    selectedMarbleId = marbleId;
    const track = getCurrentTrack();
    if (!track) return;

    const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);

    // NEW: compute bearing from previous -> current to bias "keep going straight"
    if (prevSelected) {
        try {
            const prev = track.marbles.find(m => m.id === prevSelected);
            const curr = track.marbles.find(m => m.id === marbleId);
            if (prev && curr) {
                lastHopBearingDeg = bearingDeg(prev.position, curr.position);
            }
        } catch {}
    }

    if (marbleIndex !== -1) {
        updateMarbleDisplay();
        setStatus(`Selected marble #${marbleIndex + 1} - Drag to move or Ctrl+Click to lock`);

                // UPDATE CONE POSITION
        updateViewCone();
    }

    // NEW: update branch buttons for this selection
    }

    function deselectMarble() {
        selectedMarbleId = null;
        updateMarbleDisplay();
            // HIDE CONE when no marble selected
    hideViewCone(); // ADD THIS LINE
        setStatus('Marble deselected');
    }

    function startMarbleDrag(marbleId) {
        // Only allow dragging if this marble is selected AND not locked
        if (marbleId !== selectedMarbleId) return;
        
        const track = getCurrentTrack();
        if (!track) return;
        
        const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
        if (marbleIndex === -1) return;
        
        const marble = track.marbles[marbleIndex];
        if (marble.isLocked) {
            setStatus('Marble is locked - cannot drag');
            return;
        }
        
        isDraggingMarble = true;
        dragMarbleIndex = marbleIndex;
        marble.isDragging = true;
        
        updateMarbleDisplay();
        setStatus(`Dragging marble #${marble.index + 1}`);
        
        // Prevent map dragging
        map.dragPan.disable();
        map.scrollZoom.disable();
        map.getCanvas().style.cursor = 'grabbing';
    }

    function handleMarbleDrag(e) {
        if (!isDraggingMarble || dragMarbleIndex === -1) return;
        
        const track = getCurrentTrack();
        if (!track) return;
        
        const coordinates = getDisplayCoordinates(track);
        const closestPoint = findClosestPointOnRoute([e.lngLat.lng, e.lngLat.lat], coordinates);
        
        if (closestPoint) {
            const totalDistance = calculateTotalDistance(coordinates);
            
            // Find boundaries: previous locked marble or start, next locked marble or end
            let prevBoundaryIndex = -1;
            let nextBoundaryIndex = -1;
            
            // Find previous boundary (locked marble or start)
            for (let i = dragMarbleIndex - 1; i >= 0; i--) {
                if (track.marbles[i].isLocked || i === 0) {
                    prevBoundaryIndex = i;
                    break;
                }
            }
            
            // Find next boundary (locked marble or end)
            for (let i = dragMarbleIndex + 1; i < track.marbles.length; i++) {
                if (track.marbles[i].isLocked || i === track.marbles.length - 1) {
                    nextBoundaryIndex = i;
                    break;
                }
            }
            
            // Constrain movement between boundaries
            const minDistance = prevBoundaryIndex !== -1 ? track.marbles[prevBoundaryIndex].distanceAlongRoute : 0;
            const maxDistance = nextBoundaryIndex !== -1 ? track.marbles[nextBoundaryIndex].distanceAlongRoute : totalDistance;
            
            const safeDistance = Math.max(minDistance, Math.min(closestPoint.distance, maxDistance));
            
            track.marbles[dragMarbleIndex].position = findPositionAtDistance(coordinates, safeDistance);
            track.marbles[dragMarbleIndex].distanceAlongRoute = safeDistance;
            
            // Redistribute only UNLOCKED marbles between boundaries
            redistributeMarbles();
            updateMarbleDisplay();
        }
    }

    function stopMarbleDrag() {
        if (isDraggingMarble) {
            isDraggingMarble = false;
            
            const track = getCurrentTrack();
            if (track && dragMarbleIndex !== -1) {
                track.marbles[dragMarbleIndex].isDragging = false;
            }
            
            dragMarbleIndex = -1;
            updateMarbleDisplay();
            
            // Re-enable map
            map.dragPan.enable();
            map.scrollZoom.enable();
            map.getCanvas().style.cursor = '';
            
            setStatus('Marble moved - still selected');
        }
    }

    function redistributeMarbles() {
        const track = getCurrentTrack();
        if (!track || track.marbles.length < 3 || dragMarbleIndex === -1) return;
        
        const movedMarble = track.marbles[dragMarbleIndex];
        const coordinates = getDisplayCoordinates(track);
        
        // Find boundaries around the moved marble
        let prevBoundaryIndex = -1;
        let nextBoundaryIndex = -1;
        
        // Find previous boundary (locked marble or start)
        for (let i = dragMarbleIndex - 1; i >= 0; i--) {
            if (track.marbles[i].isLocked || i === 0) {
                prevBoundaryIndex = i;
                break;
            }
        }
        
        // Find next boundary (locked marble or end)
        for (let i = dragMarbleIndex + 1; i < track.marbles.length; i++) {
            if (track.marbles[i].isLocked || i === track.marbles.length - 1) {
                nextBoundaryIndex = i;
                break;
            }
        }
        
        if (prevBoundaryIndex !== -1 && nextBoundaryIndex !== -1) {
            const startDistance = track.marbles[prevBoundaryIndex].distanceAlongRoute;
            const endDistance = track.marbles[nextBoundaryIndex].distanceAlongRoute;
            const segmentDistance = endDistance - startDistance;
            
            // Get UNLOCKED marbles between boundaries (excluding the moved one)
            const unlockedMarbles = [];
            for (let i = prevBoundaryIndex + 1; i < nextBoundaryIndex; i++) {
                if (i !== dragMarbleIndex && !track.marbles[i].isLocked) {
                    unlockedMarbles.push({ index: i, marble: track.marbles[i] });
                }
            }
            
            // Redistribute unlocked marbles proportionally
            if (unlockedMarbles.length > 0) {
                const beforeUnlocked = unlockedMarbles.filter(u => u.index < dragMarbleIndex);
                const afterUnlocked = unlockedMarbles.filter(u => u.index > dragMarbleIndex);
                
                // Redistribute marbles BEFORE the moved one
                if (beforeUnlocked.length > 0) {
                    const beforeSegmentDistance = movedMarble.distanceAlongRoute - startDistance;
                    beforeUnlocked.forEach((u, i) => {
                        const ratio = (i + 1) / (beforeUnlocked.length + 1);
                        u.marble.distanceAlongRoute = startDistance + (beforeSegmentDistance * ratio);
                        u.marble.position = findPositionAtDistance(coordinates, u.marble.distanceAlongRoute);
                    });
                }
                
                // Redistribute marbles AFTER the moved one
                if (afterUnlocked.length > 0) {
                    const afterSegmentDistance = endDistance - movedMarble.distanceAlongRoute;
                    afterUnlocked.forEach((u, i) => {
                        const ratio = (i + 1) / (afterUnlocked.length + 1);
                        u.marble.distanceAlongRoute = movedMarble.distanceAlongRoute + (afterSegmentDistance * ratio);
                        u.marble.position = findPositionAtDistance(coordinates, u.marble.distanceAlongRoute);
                    });
                }
            }
        }
    }

    // Find coordinate at specific distance along route
    function findPositionAtDistance(coordinates, targetDistance) {
        if (coordinates.length < 2) return coordinates[0];
        
        let accumulatedDistance = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
            const segmentStart = coordinates[i-1];
            const segmentEnd = coordinates[i];
            const segmentDistance = calculateDistance(segmentStart, segmentEnd);
            
            if (accumulatedDistance + segmentDistance >= targetDistance) {
                const ratio = (targetDistance - accumulatedDistance) / segmentDistance;
                return [
                    segmentStart[0] + (segmentEnd[0] - segmentStart[0]) * ratio,
                    segmentStart[1] + (segmentEnd[1] - segmentStart[1]) * ratio
                ];
            }
            
            accumulatedDistance += segmentDistance;
        }
        
        return coordinates[coordinates.length - 1];
    }

    // Find closest point on route to a given point
    function findClosestPointOnRoute(point, coordinates) {
        let closestPoint = null;
        let minDistance = Infinity;
        let accumulatedDistance = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
            const segmentStart = coordinates[i-1];
            const segmentEnd = coordinates[i];
            const segmentDistance = calculateDistance(segmentStart, segmentEnd);
            
            const closestOnSegment = findClosestPointOnSegment(point, segmentStart, segmentEnd);
            const distanceToSegment = calculateDistance(point, closestOnSegment.point);
            
            if (distanceToSegment < minDistance) {
                minDistance = distanceToSegment;
                closestPoint = {
                    point: closestOnSegment.point,
                    distance: accumulatedDistance + closestOnSegment.distance
                };
            }
            
            accumulatedDistance += segmentDistance;
        }
        
        return closestPoint;
    }

    // Find closest point on a segment
    function findClosestPointOnSegment(point, segmentStart, segmentEnd) {
        const A = point[0] - segmentStart[0];
        const B = point[1] - segmentStart[1];
        const C = segmentEnd[0] - segmentStart[0];
        const D = segmentEnd[1] - segmentStart[1];

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
            xx = segmentStart[0];
            yy = segmentStart[1];
        } else if (param > 1) {
            xx = segmentEnd[0];
            yy = segmentEnd[1];
        } else {
            xx = segmentStart[0] + param * C;
            yy = segmentStart[1] + param * D;
        }

        return {
            point: [xx, yy],
            distance: param * Math.sqrt(lenSq)
        };
    }

function updateMarbleDisplay() {
    // COLLECT MARBLES FROM ALL TRACKS
    const allMarbles = [];

    allTracks.forEach((track, trackId) => {
        track.marbles.forEach((marble, index) => {
            const hasImage = marble.assignedImage !== null;
            const imageIndex = hasImage ? marble.assignedImage + 1 : 0;
            const isWaypoint = marble.isWaypoint || false;
            const isFromCurrentTrack = (trackId === currentTrackId);

            // Get marriage info for this marble
            const marriageInfo = getMarbleMarriageInfo(marble.id, track.name);

            allMarbles.push({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: marble.position
                },
                properties: {
                    id: marble.id,
                    trackId: trackId,
                    index: index,
                    isDragging: marble.isDragging || false,
                    isLocked: marble.isLocked || false,
                    isFixed: marble.isFixed || false,
                    isSelected: (marble.id === selectedMarbleId),
                    hasImage: hasImage,
                    imageIndex: imageIndex,
                    isWaypoint: isWaypoint,
                    isFromCurrentTrack: isFromCurrentTrack,
                    originalName: marble.originalName || '',
                    position: `${index + 1}/${track.marbles.length}`,
                    distance: `${Math.round(marble.distanceAlongRoute)}m`,
                    name: isWaypoint ? (marble.originalName || `Waypoint ${index + 1}`) : `Marble ${index + 1}`,
                    trackName: track.name,
                    // Marriage properties
                    isMarrySelected: marrySelection.has(marble.id),
                    isMarried: marriageInfo.isMarried,
                    marriageColor: marriageInfo.color,
                    marriageGroupIndex: marriageInfo.groupIndex
                }
            });
        });
    });

    // UPDATE THE SOURCE WITH ALL MARBLES
    map.getSource('marbles').setData({
        type: 'FeatureCollection',
        features: allMarbles
    });

    // Update marble count for ALL tracks
    let totalMarbles = 0;
    let totalWithImages = 0;
    let totalWaypoints = 0;

    allTracks.forEach(track => {
        totalMarbles += track.marbles.length;
        totalWithImages += track.marbles.filter(m => m.assignedImage !== null).length;
        totalWaypoints += track.marbles.filter(m => m.isWaypoint).length;
    });

    document.getElementById('marble-count').textContent =
        `${totalMarbles} marbles across ${allTracks.size} tracks (${totalWaypoints} waypoints, ${totalWithImages} with images)`;

    // Update marriage count
    document.getElementById('marriage-count').textContent = `${marriageGroups.length} groups`;

    enableMarbleDragging();
}

    function enableMarbleDragging() {
        // Clear existing handlers to avoid duplicates
        map.off('click', 'marbles-click-layer', handleMarbleClick);
        map.off('mousedown', 'marbles-click-layer', handleMarbleMouseDown);
        map.off('mousemove', handleMarbleDrag);
        map.off('mouseup', stopMarbleDrag);
        map.off('click', handleMapClickForDeselect);

        // Add new handlers
        map.on('click', 'marbles-click-layer', handleMarbleClick);
        map.on('mousedown', 'marbles-click-layer', handleMarbleMouseDown);
        map.on('mousemove', handleMarbleDrag);
        map.on('mouseup', stopMarbleDrag);
        
        // Map click to deselect
        map.on('click', handleMapClickForDeselect);
    }

    function handleMarbleMouseDown(e) {
        e.preventDefault();
        if (e.features.length > 0) {
            const marbleId = e.features[0].properties.id;
            startMarbleDrag(marbleId);
        }
    }

    function handleMapClickForDeselect(e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['marbles-click-layer'] });
        if (features.length === 0) {
            deselectMarble();
        }
    }

    function lockSelectedMarble() {
        if (selectedMarbleId) {
            toggleMarbleLock(selectedMarbleId);
        } else {
            setStatus('Select a marble first by clicking on it');
        }
    }

    // ========== 360 VIEWER FUNCTIONS ==========

async function load360Images() {
  try {
    setStatus('Loading 360 images from frames folder...');
    await createImagesFromFramesFolder();

    if (currentImages.length > 0) {
      setStatus(`Loaded ${currentImages.length} images for current track`);
      
      // ONLY auto-show first image if we're NOT switching to a specific marble
      if (!isSwitchingToMarble) {
        if (selectedMarbleId) {
          const track = getCurrentTrack();
          const marble = track.marbles.find(m => m.id === selectedMarbleId);
          if (marble && marble.assignedImage !== null) {
            showImageByIndex(marble.assignedImage);
          } else {
            showImageByIndex(0);
          }
        } else {
          showImageByIndex(0);
        }
      }
      
      startBackgroundPreload(3);
    }
  } catch (error) {
    console.error('Error loading 360 images:', error);
    setStatus('Error loading 360 images');
  }
}

function addTrackToggle() {
    console.log('Adding tracks toggle button...');
    
    const controls = document.getElementById('controls');
    if (!controls) {
        console.error('Controls element not found!');
        return;
    }
    
    const toggleHTML = `
        <div class="control-group">
            <button onclick="toggleTracksVisibility()" id="tracks-toggle-btn">
                Show Tracks & Numbers: OFF
            </button>
        </div>
    `;
    
    // Try to insert after the edit mode button group
    const editGroup = controls.querySelector('.control-group:nth-child(2)');
    if (editGroup) {
        editGroup.insertAdjacentHTML('afterend', toggleHTML);
        console.log('Tracks toggle added successfully');
    } else {
        // Fallback: add to the end
        controls.insertAdjacentHTML('beforeend', toggleHTML);
        console.log('Tracks toggle added to end (fallback)');
    }
}

let tracksVisible = false;

function toggleTracksVisibility() {
    tracksVisible = !tracksVisible;
    const btn = document.getElementById('tracks-toggle-btn');
    btn.textContent = `Show Tracks & Numbers: ${tracksVisible ? 'ON' : 'OFF'}`;
    btn.classList.toggle('active', tracksVisible);
    
    // Update map layers visibility - TRACKS AND NUMBER TAGS
    if (tracksVisible) {
        map.setLayoutProperty('gpx-tracks-line', 'visibility', 'visible');
        map.setLayoutProperty('gpx-control-points', 'visibility', 'visible');
        map.setLayoutProperty('marble-labels', 'visibility', 'visible'); // SHOW NUMBER TAGS
    } else {
        map.setLayoutProperty('gpx-tracks-line', 'visibility', 'none');
        map.setLayoutProperty('gpx-control-points', 'visibility', 'none');
        map.setLayoutProperty('marble-labels', 'visibility', 'none'); // HIDE NUMBER TAGS
    }
}

async function createImagesFromFramesFolder() {
  // reset state
  currentImages = [];
  currentImageIndex = -1;

  const track = getCurrentTrack();
  if (!track) {
    setStatus?.('No track selected - cannot load frames.');
    updateImageCount?.();
    return;
  }

  // GPX base name (e.g., Santte2.gpx -> "Santte2")
  const gpxName = (track.name || '').replace(/\.[^.]+$/, '');
  if (!gpxName) {
    setStatus?.('GPX name not available.');
    return;
  }

  // case-insensitive prefix match: "<gpx>-" or "<gpx>_"
  const gpxNameLC = gpxName.toLowerCase();
  const prefixHyphen = gpxNameLC + '-';
  const prefixUnderscore = gpxNameLC + '_';

  // --- fetch manifest with hardcoded URL ---
  let list;
  try {
    const MANIFEST_URL = 'https://andresmtzc.github.io/geepeeX/senterra/frames/index.json';
    const res = await fetch(MANIFEST_URL, { cache: 'no-store' });
    if (!res.ok) {
      setStatus?.(`Could not fetch ${MANIFEST_URL} (${res.status})`);
      updateImageCount?.();
      return;
    }
    const data = await res.json();
    list = Array.isArray(data) ? data : Array.isArray(data.files) ? data.files : [];
  } catch (e) {
    console.error(e);
    setStatus?.('Error reading frames manifest.');
    return;
  }

  // ... rest of the function remains the same ...
  // normalize to bare filenames
  const files = list.map(x => String(x).split('/').pop()).filter(Boolean);

  // filter by prefix (accepts both - and _), case-insensitive, and keep only images
  const matches = files
        .filter(name => {
      const nameLC = name.toLowerCase();
      return nameLC.startsWith(prefixHyphen) || nameLC.startsWith(prefixUnderscore);
    })
    .filter(name => /\.(?:jpe?g|png)$/i.test(name))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

  if (matches.length === 0) {
    setStatus?.(`No frames for "${gpxName}". Expecting files like "${gpxName}-....jpeg" or "${gpxName}_....jpg"`);
    updateImageCount?.();
    return;
  }

  // build currentImages using absolute URLs
  currentImages = matches.map((filename, i) => ({
    url: FRAMES_BASE + filename,
    index: i,
    filename,
    timestamp: filename,
    sequence: i
  }));

  setStatus?.(`Loaded ${currentImages.length} image(s) for "${gpxName}" from ${FRAMES_BASE}`);
  updateImageCount?.();
}

// Load frames from a local folder selected by user
function loadLocalFrames(files) {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('Please select a GPX track first');
        return;
    }

    // Filter for image files ONLY in the root folder (no subdirectories)
    const imageFiles = Array.from(files).filter(file => {
        // Check if image type
        const isImage = file.type.startsWith('image/') ||
            /\.(jpg|jpeg|png|webp)$/i.test(file.name);
        if (!isImage) return false;

        // webkitRelativePath is like "foldername/IMG_0001.jpg" for root files
        // or "foldername/subfolder/IMG_0001.jpg" for nested files
        const pathParts = file.webkitRelativePath.split('/');
        // Only include if directly in root (2 parts: folder + filename)
        return pathParts.length === 2;
    });

    if (imageFiles.length === 0) {
        setStatus('No image files found in folder');
        return;
    }

    // Sort by filename (IMG_0001, IMG_0002, etc.)
    imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

    // Revoke old object URLs to free memory
    currentImages.forEach(img => {
        if (img.url && img.url.startsWith('blob:')) {
            URL.revokeObjectURL(img.url);
        }
    });

    // Create object URLs for each image
    currentImages = imageFiles.map((file, i) => ({
        url: URL.createObjectURL(file),
        index: i,
        filename: file.name,
        timestamp: file.name,
        sequence: i
    }));

    currentImageIndex = -1;

    // Update UI
    document.getElementById('local-frames-count').textContent = `${currentImages.length} loaded`;
    updateImageCount();

    // Auto-create marbles distributed along track
    initializeMarbles();

    setStatus(`Loaded ${currentImages.length} local frames - marbles created`);
}

    function clear360Images() {
        currentImages = [];
        currentImageIndex = -1;
        updateImageCount();
        updateViewerDisplay();
        setStatus('Cleared all 360 images');
    }

function assignImagesToMarbles() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('No track selected - cannot assign images to marbles');
        return;
    }
    
    const marbles = track.marbles;
    if (marbles.length === 0) {
        setStatus('No marbles created - create marbles first');
        return;
    }
    
    // Clear previous assignments
    marbles.forEach(marble => {
        marble.assignedImage = null;
    });
    
    // Assign images to marbles in 1:1 order
    const assignmentCount = Math.min(marbles.length, currentImages.length);
    
    for (let i = 0; i < assignmentCount; i++) {
        marbles[i].assignedImage = i;
    }
    
    updateMarbleDisplay();
    
    if (marbles.length > currentImages.length) {
        setStatus(`Assigned ${assignmentCount} images to ${marbles.length} marbles (${marbles.length - assignmentCount} marbles without images)`);
    } else if (marbles.length < currentImages.length) {
        setStatus(`Assigned ${assignmentCount} images to ${marbles.length} marbles (${currentImages.length - assignmentCount} images unused)`);
    } else {
        setStatus(`Perfect! All ${assignmentCount} images assigned to marbles`);
    }
    
    return assignmentCount;
}

function validateImageAssignment() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const marblesWithImages = marbles.filter(m => m.assignedImage !== null).length;
    
    if (marbles.length !== marblesWithImages) {
        console.warn(`Mismatch detected: ${marbles.length} marbles but ${marblesWithImages} have images`);
        return false;
    }
    
    return true;
}










    function updateImageCount() {
        const imageCount = document.getElementById('image-count');
        const currentImage = document.getElementById('current-image');
        
        if (imageCount) {
            imageCount.textContent = `${currentImages.length} loaded`;
        }
        if (currentImage) {
            currentImage.textContent = currentImageIndex >= 0 ? `${currentImageIndex + 1}/${currentImages.length}` : '-';
        }
    }

    // Export single track by ID
    function exportSingleTrack(trackId) {
        const track = allTracks.get(trackId);
        if (track) {
            const gpxContent = generateGPX(track);
            downloadFile(gpxContent, `${track.name}_edited.gpx`, 'application/gpx+xml');
            setStatus(`Exported: ${track.name}_edited.gpx`);
        }
    }

    // Export current track
    function exportCurrentTrack() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }
        exportSingleTrack(track.id);
    }

    // Export all tracks as ZIP
    async function exportAllTracksAsZip() {
        if (allTracks.size === 0) {
            setStatus('No tracks to export!');
            return;
        }

        try {
            const zip = new JSZip();
            
            allTracks.forEach(track => {
                const gpxContent = generateGPX(track);
                zip.file(`${track.name}_edited.gpx`, gpxContent);
            });
            
            const content = await zip.generateAsync({type: "blob"});
            downloadFile(content, 'edited_tracks.zip', 'application/zip');
            setStatus(`Exported ${allTracks.size} tracks as separate files`);
            
        } catch (error) {
            console.error('Error creating ZIP:', error);
            setStatus('Error creating ZIP file');
        }
    }

    // Generate GPX for a single track
   function generateGPX(track) {
    const coordinates = track.activePoints.map(p => p.coordinates);
    
    let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Editor" xmlns="http://www.topografix.com/GPX/1/1">
  <trk>
    <name>${escapeXML(track.name)}_edited</name>
    <trkseg>
`;
    
    coordinates.forEach(coord => {
        gpx += `      <trkpt lat="${coord[1].toFixed(6)}" lon="${coord[0].toFixed(6)}"></trkpt>\n`;
    });
    
    gpx += `    </trkseg>
  </trk>`;
    
    // ADD MARBLES AS WAYPOINTS (preserve waypoint info if available)
    track.marbles.forEach((marble, index) => {
        const imageInfo = marble.assignedImage !== null ? 
            ` - Image ${marble.assignedImage + 1}` : '';
        
        // Use original waypoint name if available, otherwise generate one
        const name = marble.originalName || `Photo_${index + 1}`;
        const desc = marble.description || `Marble position along route${imageInfo}`;
        
        gpx += `
  <wpt lat="${marble.position[1].toFixed(6)}" lon="${marble.position[0].toFixed(6)}">
    <name>${escapeXML(name)}${imageInfo}</name>
    <desc>${escapeXML(desc)}</desc>`;
    
        // Preserve time if it exists
        if (marble.time) {
            gpx += `
    <time>${marble.time}</time>`;
        }
        
        gpx += `
  </wpt>`;
    });
    
    gpx += '\n</gpx>';
    return gpx;
}

    // Escape XML special characters
    function escapeXML(str) {
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&apos;');
    }

    // Download helper function
    function downloadFile(content, fileName, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // ===== 360 VIEWER INITIALIZATION =====
function initThreeJSViewer() {
    if (viewerInitialized) return;
    
    // Scene setup
    scene = new THREE.Scene();
    panoGroup = new THREE.Group();
    scene.add(panoGroup);

    // Camera
    const canvas = document.getElementById('canvas');
    camera = new THREE.PerspectiveCamera(currentFov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 0.1);

    // Renderer - KEEP SIMPLE but add DPR
    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true,
        alpha: false,
        powerPreference: 'high-performance'
    });
    
    // ADD ONLY DPR (no tone mapping)
    const dpr = Math.min(window.devicePixelRatio || 4, 4);
    renderer.setPixelRatio(dpr);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
    
    // Event listeners
    setupViewerEventListeners();
    
    // Start animation loop
    animateViewer();
    viewerInitialized = true;
    
    console.log('Three.js viewer initialized with DPR:', dpr);
}

function animateViewer() {
    requestAnimationFrame(animateViewer);
    updateNavigationRing();
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function updateNavigationRing(instant = false) {
    const ring = document.querySelector('.navigation-ring');
    const nextBtn = document.getElementById('nextImageBtn');
    const prevBtn = document.getElementById('prevImageBtn');
    const branchBtn = document.getElementById('branchImageBtn');

    if (!ring || !sphere) return;

    // Rotate ring to match view
    let yawDegrees = THREE.MathUtils.radToDeg(currentYaw);
    ring.style.transform = `rotateZ(${-yawDegrees}deg)`;

    const track = getCurrentTrack();
    if (!track || !selectedMarbleId) return;

    const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
    const total = track.marbles.length;

    // Detect position in track
    const isFirst = marbleIndex === 0;
    const isLast = marbleIndex === total - 1;
    const canForward = !isLast;
    const canBackward = !isFirst;

    // Branch only available if marble has married partners
    const canBranch = hasMarriedPartners(selectedMarbleId);

    // Clear all branch position classes
    ring.classList.remove('branch-left', 'branch-right', 'branch-top', 'branch-bottom');

    // Determine branch button position
    if (canBranch) {
        if (isFirst && !canBackward) {
            // At first marble, no previous button - branch takes 6 o'clock
            ring.classList.add('branch-bottom');
        } else if (isLast && !canForward) {
            // At last marble, no next button - branch takes 12 o'clock
            ring.classList.add('branch-top');
        } else {
            // Middle marble - calculate if branch should be left or right
            const branchPosition = calculateBranchPosition();
            if (branchPosition === 'left') {
                ring.classList.add('branch-left');
            } else {
                // Default to right (3 o'clock)
                ring.classList.add('branch-right');
            }
        }
    }

    // Show/hide buttons based on availability
    if (nextBtn) {
        nextBtn.style.opacity = canForward ? 1 : 0;
        nextBtn.style.pointerEvents = canForward ? 'auto' : 'none';
        nextBtn.title = canForward ? 'Move forward' : 'No next marble';
    }

    if (prevBtn) {
        prevBtn.style.opacity = canBackward ? 1 : 0;
        prevBtn.style.pointerEvents = canBackward ? 'auto' : 'none';
        prevBtn.title = canBackward ? 'Move backward' : 'No previous marble';
    }

    if (branchBtn) {
        branchBtn.style.opacity = canBranch ? 1 : 0;
        branchBtn.style.pointerEvents = canBranch ? 'auto' : 'none';
        branchBtn.title = canBranch ? 'Jump to married partner' : 'No branch available';
    }

    if (instant) {
        ring.style.transition = 'none';
        requestAnimationFrame(() => {
            ring.style.transition = '';
        });
    }
}

// Calculate if branch button should be on left or right based on married marble position
function calculateBranchPosition() {
    if (!selectedMarbleId) return 'right';

    const marriedPartners = getMarriedPartners(selectedMarbleId);
    if (marriedPartners.length === 0) return 'right';

    const track = getCurrentTrack();
    if (!track) return 'right';

    const currentMarble = track.marbles.find(m => m.id === selectedMarbleId);
    if (!currentMarble) return 'right';

    // Get first married partner's position
    const partner = marriedPartners[0];
    const partnerMarble = partner.marble;

    // Calculate bearing from current marble to partner marble
    const dx = partnerMarble.position[0] - currentMarble.position[0];
    const dy = partnerMarble.position[1] - currentMarble.position[1];
    const bearingToPartner = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;

    // Get path bearing (direction cone is facing)
    const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
    let pathBearing = 0;

    if (marbleIndex < track.marbles.length - 1) {
        const nextMarble = track.marbles[marbleIndex + 1];
        const dx2 = nextMarble.position[0] - currentMarble.position[0];
        const dy2 = nextMarble.position[1] - currentMarble.position[1];
        pathBearing = (Math.atan2(dx2, dy2) * 180 / Math.PI + 360) % 360;
    } else if (marbleIndex > 0) {
        const prevMarble = track.marbles[marbleIndex - 1];
        const dx2 = currentMarble.position[0] - prevMarble.position[0];
        const dy2 = currentMarble.position[1] - prevMarble.position[1];
        pathBearing = (Math.atan2(dx2, dy2) * 180 / Math.PI + 360) % 360;
    }

    // Calculate relative angle: positive = partner is to the right, negative = to the left
    let relativeAngle = bearingToPartner - pathBearing;

    // Normalize to -180 to 180
    while (relativeAngle > 180) relativeAngle -= 360;
    while (relativeAngle < -180) relativeAngle += 360;

    // If partner is to the left (negative angle), place button on left (9 o'clock)
    // If partner is to the right (positive angle), place button on right (3 o'clock)
    return relativeAngle < 0 ? 'left' : 'right';
}

// ===== IMAGE DISPLAY =====
function showImageInViewer(imageUrl, imageData) {
    showViewerLoading('Loading 360¬∞ image...');
    
    console.log('Loading image:', imageUrl);
    
    // Initialize viewer if needed
    if (!viewerInitialized) {
        initThreeJSViewer();
    }
    
    // Check if image is already preloaded (double-check)
    if (preloadedImages[imageUrl]) {
        console.log('Image preloaded - instant display');
        hideViewerLoading();
        applyImageToSphere(preloadedImages[imageUrl], imageData);
        preloadAdjacentImages();
        return;
    }
    
    // Load new image
    const img = new Image();
    img.crossOrigin = "Anonymous";
    
    img.onload = function() {
        console.log('Image loaded successfully:', imageUrl);
        preloadedImages[imageUrl] = img; // Add to cache
        hideViewerLoading();
        applyImageToSphere(img, imageData);
        preloadAdjacentImages();
    };
    
    img.onerror = function() {
        console.error('Failed to load image:', imageUrl);
        hideViewerLoading();
        setStatus('Failed to load 360 image: ' + imageUrl);
    };
    
    const timestamp = new Date().getTime();
    const urlWithCacheBust = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + timestamp;
    img.src = urlWithCacheBust;
}

// ===== IMAGE NAVIGATION =====
function nextImage() {
    if (currentImageIndex < currentImages.length - 1) {
        currentImageIndex++;
        isGoingForward = true;
        showImageByIndex(currentImageIndex);
        updateNavigationRing(true); // ‚Üê Instant change
    }
    updateNavigationButtons();
    // NEW: update branch buttons after stepping images

}

function previousImage() {
    if (currentImageIndex > 0) {
        currentImageIndex--;
        isGoingForward = false;
        showImageByIndex(currentImageIndex);
        updateNavigationRing(true); // ‚Üê Instant change
    }
    updateNavigationButtons();
    // NEW: update branch buttons after stepping images

}

function showImageByIndex(index, preserveOrientation = false) {
    if (index >= 0 && index < currentImages.length) {
        const image = currentImages[index];
        
        // CHECK IF IMAGE IS PRELOADED
        if (preloadedImages[image.url]) {
            console.log('Image already preloaded - instant display');
            // INSTANT DISPLAY - no loading screen
            applyImageToSphere(preloadedImages[image.url], image);
            currentImageIndex = index;
            updateViewerUI();
            highlightMarbleWithImage(index);
        } else {
            console.log('Image not preloaded - showing loading screen');
            // NOT PRELOADED - show loading screen
            showImageInViewer(image.url, image);
            currentImageIndex = index;
            updateViewerUI();
            highlightMarbleWithImage(index);
                    }
        
        // PRELOAD ADJACENT IMAGES FOR NEXT NAVIGATION
        preloadAdjacentImages();
    }
}

function applyImageToSphere(img, imageData) {
    // Remove old sphere
    if (sphere) {
        panoGroup.remove(sphere);
        if (sphere.geometry) sphere.geometry.dispose();
        if (sphere.material) {
            if (sphere.material.map) sphere.material.map.dispose();
            sphere.material.dispose();
        }
    }
    
    // Create new sphere with preloaded image
    const geometry = new THREE.SphereGeometry(100, 60, 40);
    geometry.scale(-1, 1, 1);
    geometry.rotateY(Math.PI);

    // üîπ Apply per-track yaw correction from index.json
    const track = getCurrentTrack();
    if (track && track.yawFixDeg) {
        geometry.rotateY(THREE.MathUtils.degToRad(track.yawFixDeg));
        console.log(`Applied yaw fix: ${track.yawFixDeg}¬∞ to ${track.name}`);
    }

    const texture = new THREE.Texture(img);
    texture.needsUpdate = true;
    
    const material = new THREE.MeshBasicMaterial({ 
        map: texture, 
        side: THREE.DoubleSide 
    });
    
    sphere = new THREE.Mesh(geometry, material);

    // Apply the current orientation to the sphere (matching gpxviewer.html)
    sphere.rotation.y = currentYaw;
    sphere.rotation.x = currentPitch;

    panoGroup.add(sphere);

        // KEEP current orientation - don't reset!
    // panoGroup.rotation.set(0, 0, 0); ‚Üê REMOVE THIS LINE
    // currentYaw = 0; ‚Üê REMOVE THIS LINE  
    // currentPitch = 0; ‚Üê REMOVE THIS LINE
    
    // KEEP current orientation
    updateNavigationRing(true);
    
    setStatus(`Loaded image ${currentImageIndex + 1}`);
}

function preloadAdjacentImages() {
    // Quick preload of just next/previous for instant navigation
    const prevIndex = currentImageIndex - 1;
    const nextIndex = currentImageIndex + 1;
    
    if (prevIndex >= 0 && !preloadedImages[currentImages[prevIndex].url]) {
        preloadOne(prevIndex);
    }
    if (nextIndex < currentImages.length && !preloadedImages[currentImages[nextIndex].url]) {
        preloadOne(nextIndex);
    }
}

function updateViewerUI() {
    document.getElementById('time').textContent = `${currentImageIndex + 1}/${currentImages.length}`;
    document.getElementById('viewer-info').textContent = `Image ${currentImageIndex + 1}/${currentImages.length}`;
}

function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevImageBtn');
    const nextBtn = document.getElementById('nextImageBtn');
    
    if (prevBtn) prevBtn.disabled = currentImageIndex <= 0;
    if (nextBtn) nextBtn.disabled = currentImageIndex >= currentImages.length - 1;
}

// ===== MARBLE-IMAGE CONNECTION =====
function highlightMarbleWithImage(imageIndex) {
    const track = getCurrentTrack();
    if (!track) return;
    
    // Find marble with this image
    const marble = track.marbles.find(m => m.assignedImage === imageIndex);
    if (marble) {
        selectMarble(marble.id);

    }
}

// ENHANCED: Click marble to show image
function showMarbleImage(marbleId) {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marble = track.marbles.find(m => m.id === marbleId);
    if (!marble) return;
    
    if (marble.assignedImage === null) {
        setStatus(`Marble ${marble.index + 1} has no image assigned`);
        return;
    }
    
    const imageIndex = marble.assignedImage;
    showImageByIndex(imageIndex, true);
    setStatus(`Showing image ${imageIndex + 1}/${currentImages.length} for marble ${marble.index + 1}`);

    // NEW: update branch buttons after showing this image

}

function selectTrackWithoutMapReset(trackId) {
    // Deselect previous track
    if (currentTrackId && allTracks.has(currentTrackId)) {
        allTracks.get(currentTrackId).isActive = false;
    }
    
    // Select new track
    currentTrackId = trackId;
    const track = allTracks.get(trackId);
    track.isActive = true;
    
    // Update UI elements
    currentDensity = track.density;
    document.getElementById('density-slider').value = currentDensity;
    document.getElementById('density-value').textContent = currentDensity + '%';
    document.getElementById('marble-spacing-slider').value = track.marbleSpacing;
    document.getElementById('marble-spacing').textContent = track.marbleSpacing;
    document.getElementById('points-count').textContent = track.activePoints.length + ' points';
    document.getElementById('original-count').textContent = 'of ' + track.originalPoints.length;

    updateStatistics();
    
    // Reset edit mode
    if (isEditMode) {
        disableEditing();
        isEditMode = false;
        document.getElementById('edit-btn').textContent = 'Edit Mode: OFF';
        document.getElementById('edit-btn').classList.remove('active');
    }

    // Clear marble selection
    selectedMarbleId = null;
    isDraggingMarble = false;
    dragMarbleIndex = -1;
    
    updateTracksList();
    updateAllTracksVisualization(false); // Don't fit bounds!
    updateMarbleDisplay();
    
    // Remove cone when switching tracks
    if (viewConeMarker) {
        viewConeMarker.remove();
        viewConeMarker = null;
    }
     
    // IMPORTANT: Load images for the new track
    load360Images();
    
    setStatus(`Switched to: ${track.name} - ${track.marbles.length} marbles`);
}

// ===== VIEW CONE =====
// ===== CONE SYSTEM FUNCTIONS =====

// Forward geodesic (bearing+distance -> dest lon/lat)
function destFromBearingDistance(lat, lon, bearingDeg, distMeters) {
    const R = 6378137;
    const brng = degToRad(bearingDeg);
    const œÜ1 = degToRad(lat), Œª1 = degToRad(lon);
    const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(distMeters / R) +
                         Math.cos(œÜ1) * Math.sin(distMeters / R) * Math.cos(brng));
    const Œª2 = Œª1 + Math.atan2(
        Math.sin(brng) * Math.sin(distMeters / R) * Math.cos(œÜ1),
        Math.cos(distMeters / R) - Math.sin(œÜ1) * Math.sin(œÜ2)
    );
    return [radToDeg(Œª2), radToDeg(œÜ2)];
}

// Build a polygon ring for a FOV cone
function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters = 7, steps = 24) {
    // Use the fovDeg parameter to control the cone angle
    const half = Math.max(0, Math.min(89, fovDeg / 2)); // Max 89¬∞ to avoid full circle
    
    console.log(`Cone FOV: ${fovDeg}¬∞ (half: ${half}¬∞)`); // Debug log
    
    const start = headingDeg - half;
    const end = headingDeg + half;

    const ring = [[lon, lat]]; // start at origin
    for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const brg = start + (end - start) * t;
        ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
    }
    ring.push([lon, lat]); // close polygon
    return ring;
}

// Get horizontal FOV from vertical FOV
function getHorizontalFovDeg() {
    const vRad = THREE.MathUtils.degToRad(currentFov);
    const hRad = 2 * Math.atan(Math.tan(vRad / 2) * camera.aspect);
    return THREE.MathUtils.radToDeg(hRad);
}

// Update the map polygon to match current yaw + FOV
function updateViewCone() {
    if (!map || !map.getSource('view-cone')) return;
    
    const track = getCurrentTrack();
    if (!track || !selectedMarbleId) return;
    
    const marble = track.marbles.find(m => m.id === selectedMarbleId);
    if (!marble) return;

    const currentIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
    
    // 1. GET PATH DIRECTION (base bearing)
    let pathBearing = track._lastPathBearing || 0; // keep last good direction as fallback

    if (currentIndex < track.marbles.length - 1) {
        const nextMarble = track.marbles[currentIndex + 1];
        const dx = nextMarble.position[0] - marble.position[0];
        const dy = nextMarble.position[1] - marble.position[1];
        pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
    } else if (currentIndex > 0) {
        const prevMarble = track.marbles[currentIndex - 1];
        const dx = marble.position[0] - prevMarble.position[0]; // invert vector so it still points forward
        const dy = marble.position[1] - prevMarble.position[1];
        pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
    }

    // smooth continuity near endpoints (avoid 180¬∞ flip)
    if (track._lastPathBearing !== undefined) {
        const diff = pathBearing - track._lastPathBearing;
        if (Math.abs(diff) > 180) {
            pathBearing += diff > 0 ? -360 : 360;
        }
    }
    track._lastPathBearing = pathBearing;

    // 2. GET USER OFFSET (convert yaw to degrees and apply to path)
    const userYawDeg = THREE.MathUtils.radToDeg(currentYaw);
    const finalHeading = (pathBearing + userYawDeg + 360) % 360;

    console.log('Path bearing:', pathBearing, 'User yaw:', userYawDeg, 'Final heading:', finalHeading);

    const fovH = getHorizontalFovDeg();
    const radiusMeters = 15;
    
    const ring = makeViewConeRing(marble.position[1], marble.position[0], finalHeading, fovH, radiusMeters, 24);

    map.getSource('view-cone').setData({
        type: 'Feature',
        geometry: { type: 'Polygon', coordinates: [ring] }
    });
}

// Initialize the cone source and layers
function initConeSystem() {
    if (!map.getSource('view-cone')) {
        map.addSource('view-cone', {
            type: 'geojson',
            data: { 
                type: 'Feature', 
                geometry: { 
                    type: 'Polygon', 
                    coordinates: [[[0,0],[0,0],[0,0]]] 
                } 
            }
        });

        map.addLayer({
            id: 'view-cone-fill',
            type: 'fill',
            source: 'view-cone',
            paint: { 
                'fill-color': '#ff8400', 
                'fill-opacity': 0.5 
            }
        });

        map.addLayer({
            id: 'view-cone-outline',
            type: 'line',
            source: 'view-cone',
            paint: { 
                'line-color': '#ff6b6b', 
                'line-width': 2, 
                'line-opacity': 0 
            }
        });
    }
}

// Hide cone when no marble selected
function hideViewCone() {
    if (map && map.getSource('view-cone')) {
        map.getSource('view-cone').setData({
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] }
        });
    }
}

// Math helpers (add if not already in your code)
function radToDeg(r) { return r * 180 / Math.PI; }
function degToRad(d) { return d * Math.PI / 180; }
function normDeg(d) { d = d % 360; return d < 0 ? d + 360 : d; }





// ===== VIEWER CONTROLS =====
function setupViewerEventListeners() {
    const canvas = document.getElementById('canvas');
    
    // Mouse drag to look around
    let isDragging = false;
    let lastX = 0, lastY = 0;
    setupTouchGestures(canvas);
    
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        disableNavigationButtons(); 
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && sphere) {
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;

            // Rotate the sphere, not the group (matching gpxviewer.html)
            sphere.rotation.y -= deltaX * 0.01;
            sphere.rotation.x -= deltaY * 0.01;

            currentYaw = sphere.rotation.y;
            currentPitch = sphere.rotation.x;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            updateNavigationRing();
   
                    updateViewCone(); // ADD THIS LINE
                    }
    });
    
    canvas.addEventListener('mouseup', () => {
        isDragging = false;
         setTimeout(() => {
        enableNavigationButtons(); // ‚Üê Re-enable buttons after drag
    }, 50);
        canvas.style.cursor = 'grab';
    });
    
    canvas.addEventListener('mouseenter', () => {
        canvas.style.cursor = 'grab';
    });
    
    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'default';
    });
    
    
    // Zoom controls
    document.getElementById('zoomIn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut').addEventListener('click', zoomOut);

    canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
    
    // Navigation buttons
document.getElementById('nextImageBtn').addEventListener('click', navigateToBestMarbleInView);
document.getElementById('prevImageBtn').addEventListener('click', navigateToBestMarbleBehind);
    

}

function setupTouchGestures(canvas) {
    let touchStartDistance = 0;
    let touchStartFov = currentFov;
    let isTouching = false;
    let lastTouchX = 0, lastTouchY = 0;

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            // Single touch - panning (looking around)
            isTouching = true;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
            e.preventDefault();
        } else if (e.touches.length === 2) {
            // Pinch start - store initial distance and FOV
            touchStartDistance = getTouchDistance(e.touches);
            touchStartFov = currentFov;
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && isTouching) {
            // Single touch panning - look around
            const deltaX = e.touches[0].clientX - lastTouchX;
            const deltaY = e.touches[0].clientY - lastTouchY;

            // Rotate the sphere, not the group (matching gpxviewer.html)
            sphere.rotation.y -= deltaX * 0.01;
            sphere.rotation.x -= deltaY * 0.01;

            // Clamp pitch to avoid flipping
            sphere.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, sphere.rotation.x));

            currentYaw = sphere.rotation.y;
            currentPitch = sphere.rotation.x;
            
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
            
            // UPDATE CONE IN REAL-TIME DURING TOUCH PAN
            updateViewCone();
            updateNavigationRing();
                        
            e.preventDefault();
        } else if (e.touches.length === 2) {
            // Pinch gesture - zoom
            const currentDistance = getTouchDistance(e.touches);
            const scale = touchStartDistance / currentDistance;
            
            // Adjust FOV based on pinch scale
            const newFov = Math.max(30, Math.min(120, touchStartFov * scale));
            
            if (newFov !== currentFov) {
                currentFov = newFov;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                
                // Update cone and render
                updateViewCone();
                renderer.render(scene, camera);
            }
            
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (e.touches.length === 0) {
            // All touches ended
            isTouching = false;
            touchStartDistance = 0;
        } else if (e.touches.length === 1) {
            // Went from pinch to single touch - update touch position
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
        }
    }, { passive: false });
}

// Helper function to calculate distance between two touches
function getTouchDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
}

function enableNavigationButtons() {
    const buttons = document.querySelectorAll('.nav-button.ring-button');
    buttons.forEach(button => {
        button.style.pointerEvents = 'auto';
    });
}

function disableNavigationButtons() {
    const buttons = document.querySelectorAll('.nav-button.ring-button');
    buttons.forEach(button => {
        button.style.pointerEvents = 'none';
    });
}

function navigateToBestMarbleInView() {
    navigateToAdjacentMarble(true); // Always go to next marble
}

function navigateToBestMarbleBehind() {
    navigateToAdjacentMarble(false); // Always go to previous marble
}

function findClosestMarbleInViewDirection() {
    const track = getCurrentTrack();
    if (!track || track.marbles.length === 0) return null;
    
    const viewDirection = THREE.MathUtils.radToDeg(currentYaw);
    
    // Find marble that best aligns with current view direction
    let bestMarble = null;
    let bestScore = Infinity;
    
    track.marbles.forEach(marble => {
        // Calculate bearing from current view position to marble
        // For simplicity, use map center or current selected position
        const fromPosition = selectedMarbleId ? 
            track.marbles.find(m => m.id === selectedMarbleId).position : 
            [map.getCenter().lng, map.getCenter().lat];
            
        const bearingToMarble = bearingDeg(fromPosition, marble.position);
        const angleDiff = angularDiffDeg(viewDirection, bearingToMarble);
        
        // Score based on angle alignment and distance
        const distance = calculateDistance(fromPosition, marble.position);
        const score = angleDiff + (distance * 0.01); // Weight distance slightly
        
        if (score < bestScore) {
            bestScore = score;
            bestMarble = marble;
        }
    });
    
    return bestMarble;
}

function findClosestMarbleBehindView() {
    const track = getCurrentTrack();
    if (!track || track.marbles.length === 0) return null;
    
    const behindDirection = (THREE.MathUtils.radToDeg(currentYaw) + 180) % 360;
    
    let bestMarble = null;
    let bestScore = Infinity;
    
    track.marbles.forEach(marble => {
        const fromPosition = selectedMarbleId ? 
            track.marbles.find(m => m.id === selectedMarbleId).position : 
            [map.getCenter().lng, map.getCenter().lat];
            
        const bearingToMarble = bearingDeg(fromPosition, marble.position);
        const angleDiff = angularDiffDeg(behindDirection, bearingToMarble);
        
        const distance = calculateDistance(fromPosition, marble.position);
        const score = angleDiff + (distance * 0.01);
        
        if (score < bestScore) {
            bestScore = score;
            bestMarble = marble;
        }
    });
    
    return bestMarble;
}

function zoomIn() {
    if (currentFov > 30) {
        currentFov -= 5;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        updateZoomDisplay();
        updateViewCone(); // UPDATE CONE ON ZOOM
    }
}

function zoomOut() {
    if (currentFov < 120) {
        currentFov += 5;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        updateZoomDisplay();
        updateViewCone(); // UPDATE CONE ON ZOOM
    }
}

function handleWheelZoom(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Use a consistent zoom speed regardless of device
    const zoomSpeed = e.deltaMode === 0 ? 2 : 60; // Adjust for different delta modes
    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
    
    const oldFov = currentFov;
    currentFov = Math.max(30, Math.min(120, currentFov + delta));
    
    if (currentFov !== oldFov) {
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        
        updateViewCone();
        renderer.render(scene, camera);
        
        console.log(`Zoom: ${currentFov}¬∞`);
    }
}

// ===== LOADING FUNCTIONS =====
function showViewerLoading(message) {
    const loading = document.getElementById('viewer-loading');
    const loadingText = document.getElementById('loading-text');
    if (loading && loadingText) {
        loadingText.textContent = message;
        loading.style.display = 'block';
    }
}

function hideViewerLoading() {
    const loading = document.getElementById('viewer-loading');
    if (loading) loading.style.display = 'none';
}

// Function to get marble by image index
function getMarbleByImageIndex(imageIndex) {
    const track = getCurrentTrack();
    if (!track) return null;
    
    return track.marbles.find(marble => marble.assignedImage === imageIndex);
}

// Function to navigate to next/previous marble WITH image
function navigateToMarbleWithImage(direction) {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const marblesWithImages = marbles.filter(m => m.assignedImage !== null);
    
    if (marblesWithImages.length === 0) {
        setStatus('No marbles have images assigned');
        return;
    }
    
    let currentIndex = 0;
    if (selectedMarbleId) {
        const currentMarble = marbles.find(m => m.id === selectedMarbleId);
        if (currentMarble && currentMarble.assignedImage !== null) {
            currentIndex = marblesWithImages.findIndex(m => m.id === selectedMarbleId);
        }
    }
    
    let newIndex;
    if (direction === 'next') {
        newIndex = (currentIndex + 1) % marblesWithImages.length;
    } else {
        newIndex = (currentIndex - 1 + marblesWithImages.length) % marblesWithImages.length;
    }
    
    const nextMarble = marblesWithImages[newIndex];
    selectMarble(nextMarble.id);
    showMarbleImage(nextMarble.id);
}



// Add this to your existing keyboard event listeners
document.addEventListener('keydown', (e) => {
    // Use 'd' or 'D' key to toggle controls panel
    if (e.key === 'd' || e.key === 'D') {
        toggleControlsPanel();
        e.preventDefault(); // Prevent any default browser behavior
    }
});

function toggleControlsPanel() {
    const controls = document.getElementById('controls');
    if (controls.style.display === 'none' || controls.style.display === '') {
        controls.style.display = 'block';
        setStatus('Controls panel shown - press D to hide');
    } else {
        controls.style.display = 'none';
        setStatus('Controls panel hidden - press D to show');
    }
}

// Add buttons to navigate marbles with images
function addMarbleNavigationButtons() {
    // Add these buttons to your controls HTML or create them dynamically
    const marbleNavHTML = `
        <div class="control-group">
            <div class="slider-label">
                <span>Marble Navigation:</span>
                <div>
                    <button class="small-btn" onclick="navigateToMarbleWithImage('prev')">‚Üê Prev</button>
                    <button class="small-btn" onclick="navigateToMarbleWithImage('next')">Next ‚Üí</button>
                </div>
            </div>
        </div>
    `;
    
    // Add to controls (you might need to adjust the selector based on your HTML structure)
    const controls = document.getElementById('controls');
    const exportGroup = controls.querySelector('.export-buttons').parentElement;
    exportGroup.insertAdjacentHTML('beforebegin', marbleNavHTML);
}

// ===== MISSING: IMAGE PRELOADING SYSTEM =====
let preloadedImages = {}; // ADD THIS VARIABLE at the top with other globals

function startBackgroundPreload(concurrency = 3) {
    if (currentImages.length <= 1) return;
    
    const order = buildPreloadOrder(currentImageIndex, currentImages.length);
    runPreloadPool(order, concurrency);
}

function buildPreloadOrder(center, total) {
    const seq = [];
    for (let step = 1; step < total; step++) {
        const fwd = center + step;
        const back = center - step;
        if (fwd < total) seq.push(fwd);
        if (back >= 0) seq.push(back);
    }
    return seq;
}

function runPreloadPool(indexes, concurrency) {
    let i = 0;
    const workers = Array.from({ length: Math.min(concurrency, indexes.length) }, async () => {
        while (i < indexes.length) {
            const idx = indexes[i++];
            await preloadOne(idx).catch(() => {});
        }
    });
    
    Promise.all(workers).then(() => {
        console.log('Background preload complete');
    });
}

function preloadOne(index) {
    return new Promise((resolve) => {
        const item = currentImages[index];
        if (!item) return resolve();

        const src = item.url;
        if (preloadedImages[src]) return resolve(); // already cached

        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => {
            preloadedImages[src] = img;
            resolve();
        };
        img.onerror = () => resolve(); // swallow errors; keep going
        img.src = src;

        if (img.decode) img.decode().catch(() => {});
    });
}

// ===== MISSING: UPDATE VIEWER DISPLAY =====
function updateViewerDisplay() {
    const panoImage = document.getElementById('pano-image');
    const noImage = document.getElementById('no-image');
    
    if (panoImage && noImage) {
        if (currentImages.length > 0 && currentImageIndex >= 0) {
            panoImage.style.display = 'block';
            noImage.style.display = 'none';
        } else {
            panoImage.style.display = 'none';
            noImage.style.display = 'flex';
        }
    }
}

// ===== MISSING: INITIALIZE VIEWER =====
function initializeViewer() {
    // Simple initialization - the Three.js viewer will be initialized when images are loaded
    console.log('Viewer container ready');
}

// ===== MISSING: SHOW IMAGE (legacy function) =====
function showImage(index) {
    // This is called by the old viewer controls, redirect to new system
    showImageByIndex(index);
}

// ===== MARRIAGE SYSTEM FUNCTIONS =====

// Get marble identifier string for storage (gpxName:marbleIndex)
function getMarbleIdentifier(marbleId) {
    for (const [trackId, track] of allTracks) {
        const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
        if (marbleIndex !== -1) {
            return `${track.name}.gpx:${marbleIndex}`;
        }
    }
    return null;
}

// Find marble by identifier string
function findMarbleByIdentifier(identifier) {
    const [gpxName, indexStr] = identifier.split(':');
    const index = parseInt(indexStr);

    for (const [trackId, track] of allTracks) {
        // Match by track name (with or without .gpx extension)
        const trackName = track.name.replace(/\.gpx$/i, '');
        const searchName = gpxName.replace(/\.gpx$/i, '');

        if (trackName === searchName && track.marbles[index]) {
            return { marble: track.marbles[index], track, trackId };
        }
    }
    return null;
}

// Get marriage info for a marble
function getMarbleMarriageInfo(marbleId, trackName) {
    const identifier = `${trackName}.gpx:${getMarbleIndexById(marbleId, trackName)}`;

    for (let i = 0; i < marriageGroups.length; i++) {
        if (marriageGroups[i].includes(identifier)) {
            return {
                isMarried: true,
                groupIndex: i,
                color: marriageColors[i % marriageColors.length]
            };
        }
    }

    return { isMarried: false, groupIndex: -1, color: '#8B4513' };
}

// Get marble index by ID within a track
function getMarbleIndexById(marbleId, trackName) {
    for (const [trackId, track] of allTracks) {
        if (track.name === trackName) {
            return track.marbles.findIndex(m => m.id === marbleId);
        }
    }
    return -1;
}

// Toggle marry mode
function toggleMarryMode() {
    marryModeActive = !marryModeActive;
    const btn = document.getElementById('marry-mode-btn');
    const info = document.getElementById('marry-selection-info');

    if (marryModeActive) {
        btn.textContent = 'Marry Mode: ON';
        btn.classList.add('active');
        info.style.display = 'block';
        marrySelection.clear();
        updateMarrySelectionUI();
        setStatus('Marry Mode ON - Click marbles to select for marriage');
    } else {
        btn.textContent = 'Marry Mode: OFF';
        btn.classList.remove('active');
        info.style.display = 'none';
        marrySelection.clear();
        setStatus('Marry Mode OFF');
    }

    updateMarbleDisplay();
}

// Toggle marble selection for marriage
function toggleMarrySelection(marbleId) {
    if (marrySelection.has(marbleId)) {
        marrySelection.delete(marbleId);
    } else {
        marrySelection.add(marbleId);
    }

    updateMarrySelectionUI();
    updateMarbleDisplay();
}

// Update marry selection UI
function updateMarrySelectionUI() {
    const countEl = document.getElementById('marry-selection-count');
    const marryBtn = document.getElementById('marry-btn');

    countEl.textContent = marrySelection.size;
    marryBtn.disabled = marrySelection.size < 2;

    if (marrySelection.size >= 2) {
        marryBtn.classList.add('active');
    } else {
        marryBtn.classList.remove('active');
    }
}

// Marry selected marbles
function marrySelected() {
    if (marrySelection.size < 2) {
        setStatus('Select at least 2 marbles to marry');
        return;
    }

    // Convert marble IDs to identifiers
    const identifiers = [];
    for (const marbleId of marrySelection) {
        const identifier = getMarbleIdentifier(marbleId);
        if (identifier) {
            identifiers.push(identifier);
        }
    }

    if (identifiers.length < 2) {
        setStatus('Could not identify marbles for marriage');
        return;
    }

    // Check if any of these marbles are already married
    for (const identifier of identifiers) {
        for (const group of marriageGroups) {
            if (group.includes(identifier)) {
                setStatus(`Marble ${identifier} is already married. Divorce first.`);
                return;
            }
        }
    }

    // Create new marriage group
    marriageGroups.push(identifiers);

    // Clear selection and update UI
    marrySelection.clear();
    updateMarrySelectionUI();
    updateMarbleDisplay();
    updateDivorceButton();

    setStatus(`Married ${identifiers.length} marbles (Group ${marriageGroups.length})`);
}

// Divorce selected marble
function divorceSelectedMarble() {
    if (!selectedMarbleId) {
        setStatus('Select a married marble first');
        return;
    }

    const identifier = getMarbleIdentifier(selectedMarbleId);
    if (!identifier) {
        setStatus('Could not identify marble');
        return;
    }

    // Find and remove from marriage group
    for (let i = 0; i < marriageGroups.length; i++) {
        const groupIndex = marriageGroups[i].indexOf(identifier);
        if (groupIndex !== -1) {
            marriageGroups[i].splice(groupIndex, 1);

            // If group has less than 2 members, dissolve it
            if (marriageGroups[i].length < 2) {
                marriageGroups.splice(i, 1);
                setStatus(`Divorced marble and dissolved group (was only 1 left)`);
            } else {
                setStatus(`Divorced marble from group ${i + 1}`);
            }

            updateMarbleDisplay();
            updateDivorceButton();
            return;
        }
    }

    setStatus('Marble is not married');
}

// Clear all marriages
function clearAllMarriages() {
    if (marriageGroups.length === 0) {
        setStatus('No marriages to clear');
        return;
    }

    if (confirm(`Clear all ${marriageGroups.length} marriage groups?`)) {
        marriageGroups = [];
        updateMarbleDisplay();
        updateDivorceButton();
        setStatus('All marriages cleared');
    }
}

// Update divorce button state based on selected marble
function updateDivorceButton() {
    const divorceBtn = document.getElementById('divorce-btn');

    if (!selectedMarbleId) {
        divorceBtn.disabled = true;
        return;
    }

    const identifier = getMarbleIdentifier(selectedMarbleId);
    if (!identifier) {
        divorceBtn.disabled = true;
        return;
    }

    // Check if marble is married
    for (const group of marriageGroups) {
        if (group.includes(identifier)) {
            divorceBtn.disabled = false;
            return;
        }
    }

    divorceBtn.disabled = true;
}

// Export index.json with all data including marriages
function exportIndexJson() {
    // Collect all image files
    const allFiles = [];
    const gpxFiles = [];
    const yawfixes = {};

    allTracks.forEach((track, trackId) => {
        const gpxName = track.name.endsWith('.gpx') ? track.name : `${track.name}.gpx`;
        gpxFiles.push(gpxName);

        if (track.yawFixDeg) {
            yawfixes[gpxName] = track.yawFixDeg;
        }
    });

    // Build the export object
    const exportData = {
        files: allFiles, // Will be populated from existing manifest or empty
        gpxFiles: gpxFiles,
        yawfixes: yawfixes,
        marriages: marriageGroups
    };

    // Try to preserve existing files array from loaded manifest
    if (window.loadedManifestFiles) {
        exportData.files = window.loadedManifestFiles;
    }

    const jsonString = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'index.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setStatus(`Exported index.json with ${marriageGroups.length} marriage groups`);
}

// Import index.json
function importIndexJson(file) {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);

            // Load marriages
            if (data.marriages && Array.isArray(data.marriages)) {
                marriageGroups = data.marriages;
                setStatus(`Imported ${marriageGroups.length} marriage groups`);
            } else {
                marriageGroups = [];
                setStatus('Imported JSON (no marriages found)');
            }

            // Store files for later export
            if (data.files) {
                window.loadedManifestFiles = data.files;
            }

            updateMarbleDisplay();
            updateDivorceButton();

        } catch (err) {
            console.error('Error parsing JSON:', err);
            setStatus('Error parsing JSON file');
        }
    };

    reader.readAsText(file);

    // Reset the input so the same file can be selected again
    document.getElementById('import-json-input').value = '';
}

// Hook into selectMarble to update divorce button
const originalSelectMarble = selectMarble;
selectMarble = function(marbleId) {
    originalSelectMarble(marbleId);
    updateDivorceButton();
};

// Check if marble has married partners
function hasMarriedPartners(marbleId) {
    return getMarriedPartners(marbleId).length > 0;
}

// Get married partners for a marble
function getMarriedPartners(marbleId) {
    const identifier = getMarbleIdentifier(marbleId);
    if (!identifier) return [];

    for (const group of marriageGroups) {
        if (group.includes(identifier)) {
            return group.filter(id => id !== identifier).map(id => {
                const result = findMarbleByIdentifier(id);
                return result ? { ...result, identifier: id } : null;
            }).filter(Boolean);
        }
    }
    return [];
}

// Find marble by identifier string
function findMarbleByIdentifier(identifier) {
    const [gpxName, indexStr] = identifier.split(':');
    const index = parseInt(indexStr);

    for (const [trackId, track] of allTracks) {
        const trackName = track.name.replace(/\.gpx$/i, '');
        const searchName = gpxName.replace(/\.gpx$/i, '');

        if (trackName === searchName && track.marbles[index]) {
            return { marble: track.marbles[index], track, trackId };
        }
    }
    return null;
}

// Branch button click handler - jump to married partner
document.getElementById('branchImageBtn').addEventListener('click', async () => {
    if (!selectedMarbleId) return;

    // Only jump to married partners
    const marriedPartners = getMarriedPartners(selectedMarbleId);

    if (marriedPartners.length === 0) {
        setStatus('No married partner available');
        return;
    }

    // Jump to first married partner
    const target = marriedPartners[0];
    const targetTrack = target.track;
    const targetMarble = target.marble;

    if (targetTrack.id !== currentTrackId) {
        selectTrackWithoutMapReset(targetTrack.id);
        await new Promise(r => setTimeout(r, 100));
    }
    selectMarble(targetMarble.id);
    if (targetMarble.assignedImage != null) {
        showMarbleImage(targetMarble.id);
    } else {
        map.flyTo({ center: targetMarble.position, zoom: map.getZoom(), duration: 800 });
    }

    setStatus(`Jumped to married partner on ${targetTrack.name}`);
});

    // Initialize the application
    initializeApp();
</script>

</body>
</html>
